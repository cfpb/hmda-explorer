/*!                                      
            /$$$$$$          /$$        
           /$$__  $$        | $$        
  /$$$$$$$| $$  \__//$$$$$$ | $$$$$$$  
 /$$_____/| $$$$   /$$__  $$| $$__  $$  
| $$      | $$_/  | $$  \ $$| $$  \ $$
| $$      | $$    | $$  | $$| $$  | $$  
|  $$$$$$$| $$    | $$$$$$$/| $$$$$$$/  
 \_______/|__/    | $$____/ |_______/  
                  | $$                  
                  | $$                  
                  |__/                  

* public-data-platform-static - v0.14.1 - 2013-09-16
* http://consumerfinance.gov
* Copyright (c) 2013 Consumer Financial Protection Bureau; Licensed Public, Domain */

 /* ===========================================================
 * bootstrap-tooltip.js v2.3.2
 * http://twitter.github.com/bootstrap/javascript.html#tooltips
 * Inspired by the original jQuery.tipsy by Jason Frame
 * ===========================================================
 * Copyright 2012 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================== */

/*!
 * jQuery JavaScript Library v1.10.2
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2013 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2013-07-03T13:48Z
 */

/**
 * @license
 * Lo-Dash 1.3.1 <http://lodash.com/>
 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.4.4 <http://underscorejs.org/>
 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.
 * Available under MIT license <http://lodash.com/license>
 */

/**
Copyright (c) Nicolas Gallagher and Jonathan Neal

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


Copyright (c) 2012-2013 Kit Cambridge.
http://kitcambridge.be/

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

Chosen
- by Patrick Filler for [Harvest](http://getharvest.com)
- Copyright (c) 2011-2013 by Harvest

Available for use under the [MIT License](http://en.wikipedia.org/wiki/MIT_License)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

 */(function() {
    var UNDEFINED, doc = document, win = window, math = Math, mathRound = math.round, mathFloor = math.floor, mathCeil = math.ceil, mathMax = math.max, mathMin = math.min, mathAbs = math.abs, mathCos = math.cos, mathSin = math.sin, mathPI = math.PI, deg2rad = mathPI * 2 / 360, userAgent = navigator.userAgent, isOpera = win.opera, isIE = /msie/i.test(userAgent) && !isOpera, docMode8 = doc.documentMode === 8, isWebKit = /AppleWebKit/.test(userAgent), isFirefox = /Firefox/.test(userAgent), isTouchDevice = /(Mobile|Android|Windows Phone)/.test(userAgent), SVG_NS = "http://www.w3.org/2000/svg", hasSVG = !!doc.createElementNS && !!doc.createElementNS(SVG_NS, "svg").createSVGRect, hasBidiBug = isFirefox && parseInt(userAgent.split("Firefox/")[1], 10) < 4, useCanVG = !hasSVG && !isIE && !!doc.createElement("canvas").getContext, Renderer, hasTouch = doc.documentElement.ontouchstart !== UNDEFINED, symbolSizes = {}, idCounter = 0, garbageBin, defaultOptions, dateFormat, globalAnimation, pathAnim, timeUnits, noop = function() {}, charts = [], PRODUCT = "Highcharts", VERSION = "3.0.5", DIV = "div", ABSOLUTE = "absolute", RELATIVE = "relative", HIDDEN = "hidden", PREFIX = "highcharts-", VISIBLE = "visible", PX = "px", NONE = "none", M = "M", L = "L", TRACKER_FILL = "rgba(192,192,192," + (hasSVG ? 1e-4 : .002) + ")", NORMAL_STATE = "", HOVER_STATE = "hover", SELECT_STATE = "select", MILLISECOND = "millisecond", SECOND = "second", MINUTE = "minute", HOUR = "hour", DAY = "day", WEEK = "week", MONTH = "month", YEAR = "year", LINEAR_GRADIENT = "linearGradient", STOPS = "stops", STROKE_WIDTH = "stroke-width", makeTime, getMinutes, getHours, getDay, getDate, getMonth, getFullYear, setMinutes, setHours, setDate, setMonth, setFullYear, seriesTypes = {};
    win.Highcharts = win.Highcharts ? error(16, true) : {};
    function extend(a, b) {
        var n;
        if (!a) {
            a = {};
        }
        for (n in b) {
            a[n] = b[n];
        }
        return a;
    }
    function merge() {
        var i, len = arguments.length, ret = {}, doCopy = function(copy, original) {
            var value, key;
            if (typeof copy !== "object") {
                copy = {};
            }
            for (key in original) {
                if (original.hasOwnProperty(key)) {
                    value = original[key];
                    if (value && typeof value === "object" && Object.prototype.toString.call(value) !== "[object Array]" && typeof value.nodeType !== "number") {
                        copy[key] = doCopy(copy[key] || {}, value);
                    } else {
                        copy[key] = original[key];
                    }
                }
            }
            return copy;
        };
        for (i = 0; i < len; i++) {
            ret = doCopy(ret, arguments[i]);
        }
        return ret;
    }
    function hash() {
        var i = 0, args = arguments, length = args.length, obj = {};
        for (;i < length; i++) {
            obj[args[i++]] = args[i];
        }
        return obj;
    }
    function pInt(s, mag) {
        return parseInt(s, mag || 10);
    }
    function isString(s) {
        return typeof s === "string";
    }
    function isObject(obj) {
        return typeof obj === "object";
    }
    function isArray(obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
    }
    function isNumber(n) {
        return typeof n === "number";
    }
    function log2lin(num) {
        return math.log(num) / math.LN10;
    }
    function lin2log(num) {
        return math.pow(10, num);
    }
    function erase(arr, item) {
        var i = arr.length;
        while (i--) {
            if (arr[i] === item) {
                arr.splice(i, 1);
                break;
            }
        }
    }
    function defined(obj) {
        return obj !== UNDEFINED && obj !== null;
    }
    function attr(elem, prop, value) {
        var key, setAttribute = "setAttribute", ret;
        if (isString(prop)) {
            if (defined(value)) {
                elem[setAttribute](prop, value);
            } else if (elem && elem.getAttribute) {
                ret = elem.getAttribute(prop);
            }
        } else if (defined(prop) && isObject(prop)) {
            for (key in prop) {
                elem[setAttribute](key, prop[key]);
            }
        }
        return ret;
    }
    function splat(obj) {
        return isArray(obj) ? obj : [ obj ];
    }
    function pick() {
        var args = arguments, i, arg, length = args.length;
        for (i = 0; i < length; i++) {
            arg = args[i];
            if (typeof arg !== "undefined" && arg !== null) {
                return arg;
            }
        }
    }
    function css(el, styles) {
        if (isIE) {
            if (styles && styles.opacity !== UNDEFINED) {
                styles.filter = "alpha(opacity=" + styles.opacity * 100 + ")";
            }
        }
        extend(el.style, styles);
    }
    function createElement(tag, attribs, styles, parent, nopad) {
        var el = doc.createElement(tag);
        if (attribs) {
            extend(el, attribs);
        }
        if (nopad) {
            css(el, {
                padding: 0,
                border: NONE,
                margin: 0
            });
        }
        if (styles) {
            css(el, styles);
        }
        if (parent) {
            parent.appendChild(el);
        }
        return el;
    }
    function extendClass(parent, members) {
        var object = function() {};
        object.prototype = new parent();
        extend(object.prototype, members);
        return object;
    }
    function numberFormat(number, decimals, decPoint, thousandsSep) {
        var lang = defaultOptions.lang, n = +number || 0, c = decimals === -1 ? (n.toString().split(".")[1] || "").length : isNaN(decimals = mathAbs(decimals)) ? 2 : decimals, d = decPoint === undefined ? lang.decimalPoint : decPoint, t = thousandsSep === undefined ? lang.thousandsSep : thousandsSep, s = n < 0 ? "-" : "", i = String(pInt(n = mathAbs(n).toFixed(c))), j = i.length > 3 ? i.length % 3 : 0;
        return s + (j ? i.substr(0, j) + t : "") + i.substr(j).replace(/(\d{3})(?=\d)/g, "$1" + t) + (c ? d + mathAbs(n - i).toFixed(c).slice(2) : "");
    }
    function pad(number, length) {
        return new Array((length || 2) + 1 - String(number).length).join(0) + number;
    }
    function wrap(obj, method, func) {
        var proceed = obj[method];
        obj[method] = function() {
            var args = Array.prototype.slice.call(arguments);
            args.unshift(proceed);
            return func.apply(this, args);
        };
    }
    dateFormat = function(format, timestamp, capitalize) {
        if (!defined(timestamp) || isNaN(timestamp)) {
            return "Invalid date";
        }
        format = pick(format, "%Y-%m-%d %H:%M:%S");
        var date = new Date(timestamp), key, hours = date[getHours](), day = date[getDay](), dayOfMonth = date[getDate](), month = date[getMonth](), fullYear = date[getFullYear](), lang = defaultOptions.lang, langWeekdays = lang.weekdays, replacements = extend({
            a: langWeekdays[day].substr(0, 3),
            A: langWeekdays[day],
            d: pad(dayOfMonth),
            e: dayOfMonth,
            b: lang.shortMonths[month],
            B: lang.months[month],
            m: pad(month + 1),
            y: fullYear.toString().substr(2, 2),
            Y: fullYear,
            H: pad(hours),
            I: pad(hours % 12 || 12),
            l: hours % 12 || 12,
            M: pad(date[getMinutes]()),
            p: hours < 12 ? "AM" : "PM",
            P: hours < 12 ? "am" : "pm",
            S: pad(date.getSeconds()),
            L: pad(mathRound(timestamp % 1e3), 3)
        }, Highcharts.dateFormats);
        for (key in replacements) {
            while (format.indexOf("%" + key) !== -1) {
                format = format.replace("%" + key, typeof replacements[key] === "function" ? replacements[key](timestamp) : replacements[key]);
            }
        }
        return capitalize ? format.substr(0, 1).toUpperCase() + format.substr(1) : format;
    };
    function formatSingle(format, val) {
        var floatRegex = /f$/, decRegex = /\.([0-9])/, lang = defaultOptions.lang, decimals;
        if (floatRegex.test(format)) {
            decimals = format.match(decRegex);
            decimals = decimals ? decimals[1] : -1;
            val = numberFormat(val, decimals, lang.decimalPoint, format.indexOf(",") > -1 ? lang.thousandsSep : "");
        } else {
            val = dateFormat(format, val);
        }
        return val;
    }
    function format(str, ctx) {
        var splitter = "{", isInside = false, segment, valueAndFormat, path, i, len, ret = [], val, index;
        while ((index = str.indexOf(splitter)) !== -1) {
            segment = str.slice(0, index);
            if (isInside) {
                valueAndFormat = segment.split(":");
                path = valueAndFormat.shift().split(".");
                len = path.length;
                val = ctx;
                for (i = 0; i < len; i++) {
                    val = val[path[i]];
                }
                if (valueAndFormat.length) {
                    val = formatSingle(valueAndFormat.join(":"), val);
                }
                ret.push(val);
            } else {
                ret.push(segment);
            }
            str = str.slice(index + 1);
            isInside = !isInside;
            splitter = isInside ? "}" : "{";
        }
        ret.push(str);
        return ret.join("");
    }
    function getMagnitude(num) {
        return math.pow(10, mathFloor(math.log(num) / math.LN10));
    }
    function normalizeTickInterval(interval, multiples, magnitude, options) {
        var normalized, i;
        magnitude = pick(magnitude, 1);
        normalized = interval / magnitude;
        if (!multiples) {
            multiples = [ 1, 2, 2.5, 5, 10 ];
            if (options && options.allowDecimals === false) {
                if (magnitude === 1) {
                    multiples = [ 1, 2, 5, 10 ];
                } else if (magnitude <= .1) {
                    multiples = [ 1 / magnitude ];
                }
            }
        }
        for (i = 0; i < multiples.length; i++) {
            interval = multiples[i];
            if (normalized <= (multiples[i] + (multiples[i + 1] || multiples[i])) / 2) {
                break;
            }
        }
        interval *= magnitude;
        return interval;
    }
    function normalizeTimeTickInterval(tickInterval, unitsOption) {
        var units = unitsOption || [ [ MILLISECOND, [ 1, 2, 5, 10, 20, 25, 50, 100, 200, 500 ] ], [ SECOND, [ 1, 2, 5, 10, 15, 30 ] ], [ MINUTE, [ 1, 2, 5, 10, 15, 30 ] ], [ HOUR, [ 1, 2, 3, 4, 6, 8, 12 ] ], [ DAY, [ 1, 2 ] ], [ WEEK, [ 1, 2 ] ], [ MONTH, [ 1, 2, 3, 4, 6 ] ], [ YEAR, null ] ], unit = units[units.length - 1], interval = timeUnits[unit[0]], multiples = unit[1], count, i;
        for (i = 0; i < units.length; i++) {
            unit = units[i];
            interval = timeUnits[unit[0]];
            multiples = unit[1];
            if (units[i + 1]) {
                var lessThan = (interval * multiples[multiples.length - 1] + timeUnits[units[i + 1][0]]) / 2;
                if (tickInterval <= lessThan) {
                    break;
                }
            }
        }
        if (interval === timeUnits[YEAR] && tickInterval < 5 * interval) {
            multiples = [ 1, 2, 5 ];
        }
        if (interval === timeUnits[YEAR] && tickInterval < 5 * interval) {
            multiples = [ 1, 2, 5 ];
        }
        count = normalizeTickInterval(tickInterval / interval, multiples, unit[0] === YEAR ? getMagnitude(tickInterval / interval) : 1);
        return {
            unitRange: interval,
            count: count,
            unitName: unit[0]
        };
    }
    function getTimeTicks(normalizedInterval, min, max, startOfWeek) {
        var tickPositions = [], i, higherRanks = {}, useUTC = defaultOptions.global.useUTC, minYear, minDate = new Date(min), interval = normalizedInterval.unitRange, count = normalizedInterval.count;
        if (defined(min)) {
            if (interval >= timeUnits[SECOND]) {
                minDate.setMilliseconds(0);
                minDate.setSeconds(interval >= timeUnits[MINUTE] ? 0 : count * mathFloor(minDate.getSeconds() / count));
            }
            if (interval >= timeUnits[MINUTE]) {
                minDate[setMinutes](interval >= timeUnits[HOUR] ? 0 : count * mathFloor(minDate[getMinutes]() / count));
            }
            if (interval >= timeUnits[HOUR]) {
                minDate[setHours](interval >= timeUnits[DAY] ? 0 : count * mathFloor(minDate[getHours]() / count));
            }
            if (interval >= timeUnits[DAY]) {
                minDate[setDate](interval >= timeUnits[MONTH] ? 1 : count * mathFloor(minDate[getDate]() / count));
            }
            if (interval >= timeUnits[MONTH]) {
                minDate[setMonth](interval >= timeUnits[YEAR] ? 0 : count * mathFloor(minDate[getMonth]() / count));
                minYear = minDate[getFullYear]();
            }
            if (interval >= timeUnits[YEAR]) {
                minYear -= minYear % count;
                minDate[setFullYear](minYear);
            }
            if (interval === timeUnits[WEEK]) {
                minDate[setDate](minDate[getDate]() - minDate[getDay]() + pick(startOfWeek, 1));
            }
            i = 1;
            minYear = minDate[getFullYear]();
            var time = minDate.getTime(), minMonth = minDate[getMonth](), minDateDate = minDate[getDate](), timezoneOffset = useUTC ? 0 : (24 * 3600 * 1e3 + minDate.getTimezoneOffset() * 60 * 1e3) % (24 * 3600 * 1e3);
            while (time < max) {
                tickPositions.push(time);
                if (interval === timeUnits[YEAR]) {
                    time = makeTime(minYear + i * count, 0);
                } else if (interval === timeUnits[MONTH]) {
                    time = makeTime(minYear, minMonth + i * count);
                } else if (!useUTC && (interval === timeUnits[DAY] || interval === timeUnits[WEEK])) {
                    time = makeTime(minYear, minMonth, minDateDate + i * count * (interval === timeUnits[DAY] ? 1 : 7));
                } else {
                    time += interval * count;
                }
                i++;
            }
            tickPositions.push(time);
            each(grep(tickPositions, function(time) {
                return interval <= timeUnits[HOUR] && time % timeUnits[DAY] === timezoneOffset;
            }), function(time) {
                higherRanks[time] = DAY;
            });
        }
        tickPositions.info = extend(normalizedInterval, {
            higherRanks: higherRanks,
            totalRange: interval * count
        });
        return tickPositions;
    }
    function ChartCounters() {
        this.color = 0;
        this.symbol = 0;
    }
    ChartCounters.prototype = {
        wrapColor: function(length) {
            if (this.color >= length) {
                this.color = 0;
            }
        },
        wrapSymbol: function(length) {
            if (this.symbol >= length) {
                this.symbol = 0;
            }
        }
    };
    function stableSort(arr, sortFunction) {
        var length = arr.length, sortValue, i;
        for (i = 0; i < length; i++) {
            arr[i].ss_i = i;
        }
        arr.sort(function(a, b) {
            sortValue = sortFunction(a, b);
            return sortValue === 0 ? a.ss_i - b.ss_i : sortValue;
        });
        for (i = 0; i < length; i++) {
            delete arr[i].ss_i;
        }
    }
    function arrayMin(data) {
        var i = data.length, min = data[0];
        while (i--) {
            if (data[i] < min) {
                min = data[i];
            }
        }
        return min;
    }
    function arrayMax(data) {
        var i = data.length, max = data[0];
        while (i--) {
            if (data[i] > max) {
                max = data[i];
            }
        }
        return max;
    }
    function destroyObjectProperties(obj, except) {
        var n;
        for (n in obj) {
            if (obj[n] && obj[n] !== except && obj[n].destroy) {
                obj[n].destroy();
            }
            delete obj[n];
        }
    }
    function discardElement(element) {
        if (!garbageBin) {
            garbageBin = createElement(DIV);
        }
        if (element) {
            garbageBin.appendChild(element);
        }
        garbageBin.innerHTML = "";
    }
    function error(code, stop) {
        var msg = "Highcharts error #" + code + ": www.highcharts.com/errors/" + code;
        if (stop) {
            throw msg;
        } else if (win.console) {
            console.log(msg);
        }
    }
    function correctFloat(num) {
        return parseFloat(num.toPrecision(14));
    }
    function setAnimation(animation, chart) {
        globalAnimation = pick(animation, chart.animation);
    }
    timeUnits = hash(MILLISECOND, 1, SECOND, 1e3, MINUTE, 6e4, HOUR, 36e5, DAY, 24 * 36e5, WEEK, 7 * 24 * 36e5, MONTH, 31 * 24 * 36e5, YEAR, 31556952e3);
    pathAnim = {
        init: function(elem, fromD, toD) {
            fromD = fromD || "";
            var shift = elem.shift, bezier = fromD.indexOf("C") > -1, numParams = bezier ? 7 : 3, endLength, slice, i, start = fromD.split(" "), end = [].concat(toD), startBaseLine, endBaseLine, sixify = function(arr) {
                i = arr.length;
                while (i--) {
                    if (arr[i] === M) {
                        arr.splice(i + 1, 0, arr[i + 1], arr[i + 2], arr[i + 1], arr[i + 2]);
                    }
                }
            };
            if (bezier) {
                sixify(start);
                sixify(end);
            }
            if (elem.isArea) {
                startBaseLine = start.splice(start.length - 6, 6);
                endBaseLine = end.splice(end.length - 6, 6);
            }
            if (shift <= end.length / numParams) {
                while (shift--) {
                    end = [].concat(end).splice(0, numParams).concat(end);
                }
            }
            elem.shift = 0;
            if (start.length) {
                endLength = end.length;
                while (start.length < endLength) {
                    slice = [].concat(start).splice(start.length - numParams, numParams);
                    if (bezier) {
                        slice[numParams - 6] = slice[numParams - 2];
                        slice[numParams - 5] = slice[numParams - 1];
                    }
                    start = start.concat(slice);
                }
            }
            if (startBaseLine) {
                start = start.concat(startBaseLine);
                end = end.concat(endBaseLine);
            }
            return [ start, end ];
        },
        step: function(start, end, pos, complete) {
            var ret = [], i = start.length, startVal;
            if (pos === 1) {
                ret = complete;
            } else if (i === end.length && pos < 1) {
                while (i--) {
                    startVal = parseFloat(start[i]);
                    ret[i] = isNaN(startVal) ? start[i] : pos * parseFloat(end[i] - startVal) + startVal;
                }
            } else {
                ret = end;
            }
            return ret;
        }
    };
    (function($) {
        win.HighchartsAdapter = win.HighchartsAdapter || $ && {
            init: function(pathAnim) {
                var Fx = $.fx, Step = Fx.step, dSetter, Tween = $.Tween, propHooks = Tween && Tween.propHooks, opacityHook = $.cssHooks.opacity;
                $.extend($.easing, {
                    easeOutQuad: function(x, t, b, c, d) {
                        return -c * (t /= d) * (t - 2) + b;
                    }
                });
                $.each([ "cur", "_default", "width", "height", "opacity" ], function(i, fn) {
                    var obj = Step, base, elem;
                    if (fn === "cur") {
                        obj = Fx.prototype;
                    } else if (fn === "_default" && Tween) {
                        obj = propHooks[fn];
                        fn = "set";
                    }
                    base = obj[fn];
                    if (base) {
                        obj[fn] = function(fx) {
                            fx = i ? fx : this;
                            elem = fx.elem;
                            return elem.attr ? elem.attr(fx.prop, fn === "cur" ? UNDEFINED : fx.now) : base.apply(this, arguments);
                        };
                    }
                });
                wrap(opacityHook, "get", function(proceed, elem, computed) {
                    return elem.attr ? elem.opacity || 0 : proceed.call(this, elem, computed);
                });
                dSetter = function(fx) {
                    var elem = fx.elem, ends;
                    if (!fx.started) {
                        ends = pathAnim.init(elem, elem.d, elem.toD);
                        fx.start = ends[0];
                        fx.end = ends[1];
                        fx.started = true;
                    }
                    elem.attr("d", pathAnim.step(fx.start, fx.end, fx.pos, elem.toD));
                };
                if (Tween) {
                    propHooks.d = {
                        set: dSetter
                    };
                } else {
                    Step.d = dSetter;
                }
                this.each = Array.prototype.forEach ? function(arr, fn) {
                    return Array.prototype.forEach.call(arr, fn);
                } : function(arr, fn) {
                    var i = 0, len = arr.length;
                    for (;i < len; i++) {
                        if (fn.call(arr[i], arr[i], i, arr) === false) {
                            return i;
                        }
                    }
                };
                $.fn.highcharts = function() {
                    var constr = "Chart", args = arguments, options, ret, chart;
                    if (isString(args[0])) {
                        constr = args[0];
                        args = Array.prototype.slice.call(args, 1);
                    }
                    options = args[0];
                    if (options !== UNDEFINED) {
                        options.chart = options.chart || {};
                        options.chart.renderTo = this[0];
                        chart = new Highcharts[constr](options, args[1]);
                        ret = this;
                    }
                    if (options === UNDEFINED) {
                        ret = charts[attr(this[0], "data-highcharts-chart")];
                    }
                    return ret;
                };
            },
            getScript: $.getScript,
            inArray: $.inArray,
            adapterRun: function(elem, method) {
                return $(elem)[method]();
            },
            grep: $.grep,
            map: function(arr, fn) {
                var results = [], i = 0, len = arr.length;
                for (;i < len; i++) {
                    results[i] = fn.call(arr[i], arr[i], i, arr);
                }
                return results;
            },
            offset: function(el) {
                return $(el).offset();
            },
            addEvent: function(el, event, fn) {
                $(el).bind(event, fn);
            },
            removeEvent: function(el, eventType, handler) {
                var func = doc.removeEventListener ? "removeEventListener" : "detachEvent";
                if (doc[func] && el && !el[func]) {
                    el[func] = function() {};
                }
                $(el).unbind(eventType, handler);
            },
            fireEvent: function(el, type, eventArguments, defaultFunction) {
                var event = $.Event(type), detachedType = "detached" + type, defaultPrevented;
                if (!isIE && eventArguments) {
                    delete eventArguments.layerX;
                    delete eventArguments.layerY;
                }
                extend(event, eventArguments);
                if (el[type]) {
                    el[detachedType] = el[type];
                    el[type] = null;
                }
                $.each([ "preventDefault", "stopPropagation" ], function(i, fn) {
                    var base = event[fn];
                    event[fn] = function() {
                        try {
                            base.call(event);
                        } catch (e) {
                            if (fn === "preventDefault") {
                                defaultPrevented = true;
                            }
                        }
                    };
                });
                $(el).trigger(event);
                if (el[detachedType]) {
                    el[type] = el[detachedType];
                    el[detachedType] = null;
                }
                if (defaultFunction && !event.isDefaultPrevented() && !defaultPrevented) {
                    defaultFunction(event);
                }
            },
            washMouseEvent: function(e) {
                var ret = e.originalEvent || e;
                if (ret.pageX === UNDEFINED) {
                    ret.pageX = e.pageX;
                    ret.pageY = e.pageY;
                }
                return ret;
            },
            animate: function(el, params, options) {
                var $el = $(el);
                if (!el.style) {
                    el.style = {};
                }
                if (params.d) {
                    el.toD = params.d;
                    params.d = 1;
                }
                $el.stop();
                if (params.opacity !== UNDEFINED && el.attr) {
                    params.opacity += "px";
                }
                $el.animate(params, options);
            },
            stop: function(el) {
                $(el).stop();
            }
        };
    })(win.jQuery);
    var globalAdapter = win.HighchartsAdapter, adapter = globalAdapter || {};
    if (globalAdapter) {
        globalAdapter.init.call(globalAdapter, pathAnim);
    }
    var adapterRun = adapter.adapterRun, getScript = adapter.getScript, inArray = adapter.inArray, each = adapter.each, grep = adapter.grep, offset = adapter.offset, map = adapter.map, addEvent = adapter.addEvent, removeEvent = adapter.removeEvent, fireEvent = adapter.fireEvent, washMouseEvent = adapter.washMouseEvent, animate = adapter.animate, stop = adapter.stop;
    var defaultLabelOptions = {
        enabled: true,
        x: 0,
        y: 15,
        style: {
            color: "#666",
            cursor: "default",
            fontSize: "11px",
            lineHeight: "14px"
        }
    };
    defaultOptions = {
        colors: [ "#2f7ed8", "#0d233a", "#8bbc21", "#910000", "#1aadce", "#492970", "#f28f43", "#77a1e5", "#c42525", "#a6c96a" ],
        symbols: [ "circle", "diamond", "square", "triangle", "triangle-down" ],
        lang: {
            loading: "Loading...",
            months: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
            shortMonths: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ],
            weekdays: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
            decimalPoint: ".",
            numericSymbols: [ "k", "M", "G", "T", "P", "E" ],
            resetZoom: "Reset zoom",
            resetZoomTitle: "Reset zoom level 1:1",
            thousandsSep: ","
        },
        global: {
            useUTC: true,
            canvasToolsURL: "http://code.highcharts.com/3.0.5/modules/canvas-tools.js",
            VMLRadialGradientURL: "http://code.highcharts.com/3.0.5/gfx/vml-radial-gradient.png"
        },
        chart: {
            borderColor: "#4572A7",
            borderRadius: 5,
            defaultSeriesType: "line",
            ignoreHiddenSeries: true,
            spacingTop: 10,
            spacingRight: 10,
            spacingBottom: 15,
            spacingLeft: 10,
            style: {
                fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Verdana, Arial, Helvetica, sans-serif',
                fontSize: "12px"
            },
            backgroundColor: "#FFFFFF",
            plotBorderColor: "#C0C0C0",
            resetZoomButton: {
                theme: {
                    zIndex: 20
                },
                position: {
                    align: "right",
                    x: -10,
                    y: 10
                }
            }
        },
        title: {
            text: "Chart title",
            align: "center",
            margin: 15,
            style: {
                color: "#274b6d",
                fontSize: "16px"
            }
        },
        subtitle: {
            text: "",
            align: "center",
            style: {
                color: "#4d759e"
            }
        },
        plotOptions: {
            line: {
                allowPointSelect: false,
                showCheckbox: false,
                animation: {
                    duration: 1e3
                },
                events: {},
                lineWidth: 2,
                marker: {
                    enabled: true,
                    lineWidth: 0,
                    radius: 4,
                    lineColor: "#FFFFFF",
                    states: {
                        hover: {
                            enabled: true
                        },
                        select: {
                            fillColor: "#FFFFFF",
                            lineColor: "#000000",
                            lineWidth: 2
                        }
                    }
                },
                point: {
                    events: {}
                },
                dataLabels: merge(defaultLabelOptions, {
                    align: "center",
                    enabled: false,
                    formatter: function() {
                        return this.y === null ? "" : numberFormat(this.y, -1);
                    },
                    verticalAlign: "bottom",
                    y: 0
                }),
                cropThreshold: 300,
                pointRange: 0,
                showInLegend: true,
                states: {
                    hover: {
                        marker: {}
                    },
                    select: {
                        marker: {}
                    }
                },
                stickyTracking: true
            }
        },
        labels: {
            style: {
                position: ABSOLUTE,
                color: "#3E576F"
            }
        },
        legend: {
            enabled: true,
            align: "center",
            layout: "horizontal",
            labelFormatter: function() {
                return this.name;
            },
            borderWidth: 1,
            borderColor: "#909090",
            borderRadius: 5,
            navigation: {
                activeColor: "#274b6d",
                inactiveColor: "#CCC"
            },
            shadow: false,
            itemStyle: {
                cursor: "pointer",
                color: "#274b6d",
                fontSize: "12px"
            },
            itemHoverStyle: {
                color: "#000"
            },
            itemHiddenStyle: {
                color: "#CCC"
            },
            itemCheckboxStyle: {
                position: ABSOLUTE,
                width: "13px",
                height: "13px"
            },
            symbolWidth: 16,
            symbolPadding: 5,
            verticalAlign: "bottom",
            x: 0,
            y: 0,
            title: {
                style: {
                    fontWeight: "bold"
                }
            }
        },
        loading: {
            labelStyle: {
                fontWeight: "bold",
                position: RELATIVE,
                top: "1em"
            },
            style: {
                position: ABSOLUTE,
                backgroundColor: "white",
                opacity: .5,
                textAlign: "center"
            }
        },
        tooltip: {
            enabled: true,
            animation: hasSVG,
            backgroundColor: "rgba(255, 255, 255, .85)",
            borderWidth: 1,
            borderRadius: 3,
            dateTimeLabelFormats: {
                millisecond: "%A, %b %e, %H:%M:%S.%L",
                second: "%A, %b %e, %H:%M:%S",
                minute: "%A, %b %e, %H:%M",
                hour: "%A, %b %e, %H:%M",
                day: "%A, %b %e, %Y",
                week: "Week from %A, %b %e, %Y",
                month: "%B %Y",
                year: "%Y"
            },
            headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>',
            pointFormat: '<span style="color:{series.color}">{series.name}</span>: <b>{point.y}</b><br/>',
            shadow: true,
            snap: isTouchDevice ? 25 : 10,
            style: {
                color: "#333333",
                cursor: "default",
                fontSize: "12px",
                padding: "8px",
                whiteSpace: "nowrap"
            }
        },
        credits: {
            enabled: true,
            text: "Highcharts.com",
            href: "http://www.highcharts.com",
            position: {
                align: "right",
                x: -10,
                verticalAlign: "bottom",
                y: -5
            },
            style: {
                cursor: "pointer",
                color: "#909090",
                fontSize: "9px"
            }
        }
    };
    var defaultPlotOptions = defaultOptions.plotOptions, defaultSeriesOptions = defaultPlotOptions.line;
    setTimeMethods();
    function setTimeMethods() {
        var useUTC = defaultOptions.global.useUTC, GET = useUTC ? "getUTC" : "get", SET = useUTC ? "setUTC" : "set";
        makeTime = useUTC ? Date.UTC : function(year, month, date, hours, minutes, seconds) {
            return new Date(year, month, pick(date, 1), pick(hours, 0), pick(minutes, 0), pick(seconds, 0)).getTime();
        };
        getMinutes = GET + "Minutes";
        getHours = GET + "Hours";
        getDay = GET + "Day";
        getDate = GET + "Date";
        getMonth = GET + "Month";
        getFullYear = GET + "FullYear";
        setMinutes = SET + "Minutes";
        setHours = SET + "Hours";
        setDate = SET + "Date";
        setMonth = SET + "Month";
        setFullYear = SET + "FullYear";
    }
    function setOptions(options) {
        defaultOptions = merge(defaultOptions, options);
        setTimeMethods();
        return defaultOptions;
    }
    function getOptions() {
        return defaultOptions;
    }
    var Color = function(input) {
        var rgba = [], result, stops;
        function init(input) {
            if (input && input.stops) {
                stops = map(input.stops, function(stop) {
                    return Color(stop[1]);
                });
            } else {
                result = /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/.exec(input);
                if (result) {
                    rgba = [ pInt(result[1]), pInt(result[2]), pInt(result[3]), parseFloat(result[4], 10) ];
                } else {
                    result = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(input);
                    if (result) {
                        rgba = [ pInt(result[1], 16), pInt(result[2], 16), pInt(result[3], 16), 1 ];
                    } else {
                        result = /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/.exec(input);
                        if (result) {
                            rgba = [ pInt(result[1]), pInt(result[2]), pInt(result[3]), 1 ];
                        }
                    }
                }
            }
        }
        function get(format) {
            var ret;
            if (stops) {
                ret = merge(input);
                ret.stops = [].concat(ret.stops);
                each(stops, function(stop, i) {
                    ret.stops[i] = [ ret.stops[i][0], stop.get(format) ];
                });
            } else if (rgba && !isNaN(rgba[0])) {
                if (format === "rgb") {
                    ret = "rgb(" + rgba[0] + "," + rgba[1] + "," + rgba[2] + ")";
                } else if (format === "a") {
                    ret = rgba[3];
                } else {
                    ret = "rgba(" + rgba.join(",") + ")";
                }
            } else {
                ret = input;
            }
            return ret;
        }
        function brighten(alpha) {
            if (stops) {
                each(stops, function(stop) {
                    stop.brighten(alpha);
                });
            } else if (isNumber(alpha) && alpha !== 0) {
                var i;
                for (i = 0; i < 3; i++) {
                    rgba[i] += pInt(alpha * 255);
                    if (rgba[i] < 0) {
                        rgba[i] = 0;
                    }
                    if (rgba[i] > 255) {
                        rgba[i] = 255;
                    }
                }
            }
            return this;
        }
        function setOpacity(alpha) {
            rgba[3] = alpha;
            return this;
        }
        init(input);
        return {
            get: get,
            brighten: brighten,
            rgba: rgba,
            setOpacity: setOpacity
        };
    };
    function SVGElement() {}
    SVGElement.prototype = {
        init: function(renderer, nodeName) {
            var wrapper = this;
            wrapper.element = nodeName === "span" ? createElement(nodeName) : doc.createElementNS(SVG_NS, nodeName);
            wrapper.renderer = renderer;
            wrapper.attrSetters = {};
        },
        opacity: 1,
        animate: function(params, options, complete) {
            var animOptions = pick(options, globalAnimation, true);
            stop(this);
            if (animOptions) {
                animOptions = merge(animOptions);
                if (complete) {
                    animOptions.complete = complete;
                }
                animate(this, params, animOptions);
            } else {
                this.attr(params);
                if (complete) {
                    complete();
                }
            }
        },
        attr: function(hash, val) {
            var wrapper = this, key, value, result, i, child, element = wrapper.element, nodeName = element.nodeName.toLowerCase(), renderer = wrapper.renderer, skipAttr, titleNode, attrSetters = wrapper.attrSetters, shadows = wrapper.shadows, hasSetSymbolSize, doTransform, ret = wrapper;
            if (isString(hash) && defined(val)) {
                key = hash;
                hash = {};
                hash[key] = val;
            }
            if (isString(hash)) {
                key = hash;
                if (nodeName === "circle") {
                    key = {
                        x: "cx",
                        y: "cy"
                    }[key] || key;
                } else if (key === "strokeWidth") {
                    key = "stroke-width";
                }
                ret = attr(element, key) || wrapper[key] || 0;
                if (key !== "d" && key !== "visibility") {
                    ret = parseFloat(ret);
                }
            } else {
                for (key in hash) {
                    skipAttr = false;
                    value = hash[key];
                    result = attrSetters[key] && attrSetters[key].call(wrapper, value, key);
                    if (result !== false) {
                        if (result !== UNDEFINED) {
                            value = result;
                        }
                        if (key === "d") {
                            if (value && value.join) {
                                value = value.join(" ");
                            }
                            if (/(NaN| {2}|^$)/.test(value)) {
                                value = "M 0 0";
                            }
                        } else if (key === "x" && nodeName === "text") {
                            for (i = 0; i < element.childNodes.length; i++) {
                                child = element.childNodes[i];
                                if (attr(child, "x") === attr(element, "x")) {
                                    attr(child, "x", value);
                                }
                            }
                        } else if (wrapper.rotation && (key === "x" || key === "y")) {
                            doTransform = true;
                        } else if (key === "fill") {
                            value = renderer.color(value, element, key);
                        } else if (nodeName === "circle" && (key === "x" || key === "y")) {
                            key = {
                                x: "cx",
                                y: "cy"
                            }[key] || key;
                        } else if (nodeName === "rect" && key === "r") {
                            attr(element, {
                                rx: value,
                                ry: value
                            });
                            skipAttr = true;
                        } else if (key === "translateX" || key === "translateY" || key === "rotation" || key === "verticalAlign" || key === "scaleX" || key === "scaleY") {
                            doTransform = true;
                            skipAttr = true;
                        } else if (key === "stroke") {
                            value = renderer.color(value, element, key);
                        } else if (key === "dashstyle") {
                            key = "stroke-dasharray";
                            value = value && value.toLowerCase();
                            if (value === "solid") {
                                value = NONE;
                            } else if (value) {
                                value = value.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(",");
                                i = value.length;
                                while (i--) {
                                    value[i] = pInt(value[i]) * pick(hash["stroke-width"], wrapper["stroke-width"]);
                                }
                                value = value.join(",");
                            }
                        } else if (key === "width") {
                            value = pInt(value);
                        } else if (key === "align") {
                            key = "text-anchor";
                            value = {
                                left: "start",
                                center: "middle",
                                right: "end"
                            }[value];
                        } else if (key === "title") {
                            titleNode = element.getElementsByTagName("title")[0];
                            if (!titleNode) {
                                titleNode = doc.createElementNS(SVG_NS, "title");
                                element.appendChild(titleNode);
                            }
                            titleNode.textContent = value;
                        }
                        if (key === "strokeWidth") {
                            key = "stroke-width";
                        }
                        if (key === "stroke-width" || key === "stroke") {
                            wrapper[key] = value;
                            if (wrapper.stroke && wrapper["stroke-width"]) {
                                attr(element, "stroke", wrapper.stroke);
                                attr(element, "stroke-width", wrapper["stroke-width"]);
                                wrapper.hasStroke = true;
                            } else if (key === "stroke-width" && value === 0 && wrapper.hasStroke) {
                                element.removeAttribute("stroke");
                                wrapper.hasStroke = false;
                            }
                            skipAttr = true;
                        }
                        if (wrapper.symbolName && /^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)/.test(key)) {
                            if (!hasSetSymbolSize) {
                                wrapper.symbolAttr(hash);
                                hasSetSymbolSize = true;
                            }
                            skipAttr = true;
                        }
                        if (shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(key)) {
                            i = shadows.length;
                            while (i--) {
                                attr(shadows[i], key, key === "height" ? mathMax(value - (shadows[i].cutHeight || 0), 0) : value);
                            }
                        }
                        if ((key === "width" || key === "height") && nodeName === "rect" && value < 0) {
                            value = 0;
                        }
                        wrapper[key] = value;
                        if (key === "text") {
                            if (value !== wrapper.textStr) {
                                delete wrapper.bBox;
                            }
                            wrapper.textStr = value;
                            if (wrapper.added) {
                                renderer.buildText(wrapper);
                            }
                        } else if (!skipAttr) {
                            attr(element, key, value);
                        }
                    }
                }
                if (doTransform) {
                    wrapper.updateTransform();
                }
            }
            return ret;
        },
        addClass: function(className) {
            var element = this.element, currentClassName = attr(element, "class") || "";
            if (currentClassName.indexOf(className) === -1) {
                attr(element, "class", currentClassName + " " + className);
            }
            return this;
        },
        symbolAttr: function(hash) {
            var wrapper = this;
            each([ "x", "y", "r", "start", "end", "width", "height", "innerR", "anchorX", "anchorY" ], function(key) {
                wrapper[key] = pick(hash[key], wrapper[key]);
            });
            wrapper.attr({
                d: wrapper.renderer.symbols[wrapper.symbolName](wrapper.x, wrapper.y, wrapper.width, wrapper.height, wrapper)
            });
        },
        clip: function(clipRect) {
            return this.attr("clip-path", clipRect ? "url(" + this.renderer.url + "#" + clipRect.id + ")" : NONE);
        },
        crisp: function(strokeWidth, x, y, width, height) {
            var wrapper = this, key, attribs = {}, values = {}, normalizer;
            strokeWidth = strokeWidth || wrapper.strokeWidth || wrapper.attr && wrapper.attr("stroke-width") || 0;
            normalizer = mathRound(strokeWidth) % 2 / 2;
            values.x = mathFloor(x || wrapper.x || 0) + normalizer;
            values.y = mathFloor(y || wrapper.y || 0) + normalizer;
            values.width = mathFloor((width || wrapper.width || 0) - 2 * normalizer);
            values.height = mathFloor((height || wrapper.height || 0) - 2 * normalizer);
            values.strokeWidth = strokeWidth;
            for (key in values) {
                if (wrapper[key] !== values[key]) {
                    wrapper[key] = attribs[key] = values[key];
                }
            }
            return attribs;
        },
        css: function(styles) {
            var elemWrapper = this, elem = elemWrapper.element, textWidth = styles && styles.width && elem.nodeName.toLowerCase() === "text", n, serializedCss = "", hyphenate = function(a, b) {
                return "-" + b.toLowerCase();
            };
            if (styles && styles.color) {
                styles.fill = styles.color;
            }
            styles = extend(elemWrapper.styles, styles);
            elemWrapper.styles = styles;
            if (useCanVG && textWidth) {
                delete styles.width;
            }
            if (isIE && !hasSVG) {
                if (textWidth) {
                    delete styles.width;
                }
                css(elemWrapper.element, styles);
            } else {
                for (n in styles) {
                    serializedCss += n.replace(/([A-Z])/g, hyphenate) + ":" + styles[n] + ";";
                }
                attr(elem, "style", serializedCss);
            }
            if (textWidth && elemWrapper.added) {
                elemWrapper.renderer.buildText(elemWrapper);
            }
            return elemWrapper;
        },
        on: function(eventType, handler) {
            var element = this.element;
            if (hasTouch && eventType === "click") {
                element.ontouchstart = function(e) {
                    e.preventDefault();
                    handler.call(element, e);
                };
            }
            element["on" + eventType] = handler;
            return this;
        },
        setRadialReference: function(coordinates) {
            this.element.radialReference = coordinates;
            return this;
        },
        translate: function(x, y) {
            return this.attr({
                translateX: x,
                translateY: y
            });
        },
        invert: function() {
            var wrapper = this;
            wrapper.inverted = true;
            wrapper.updateTransform();
            return wrapper;
        },
        htmlCss: function(styles) {
            var wrapper = this, element = wrapper.element, textWidth = styles && element.tagName === "SPAN" && styles.width;
            if (textWidth) {
                delete styles.width;
                wrapper.textWidth = textWidth;
                wrapper.updateTransform();
            }
            wrapper.styles = extend(wrapper.styles, styles);
            css(wrapper.element, styles);
            return wrapper;
        },
        htmlGetBBox: function() {
            var wrapper = this, element = wrapper.element, bBox = wrapper.bBox;
            if (!bBox) {
                if (element.nodeName === "text") {
                    element.style.position = ABSOLUTE;
                }
                bBox = wrapper.bBox = {
                    x: element.offsetLeft,
                    y: element.offsetTop,
                    width: element.offsetWidth,
                    height: element.offsetHeight
                };
            }
            return bBox;
        },
        htmlUpdateTransform: function() {
            if (!this.added) {
                this.alignOnAdd = true;
                return;
            }
            var wrapper = this, renderer = wrapper.renderer, elem = wrapper.element, translateX = wrapper.translateX || 0, translateY = wrapper.translateY || 0, x = wrapper.x || 0, y = wrapper.y || 0, align = wrapper.textAlign || "left", alignCorrection = {
                left: 0,
                center: .5,
                right: 1
            }[align], nonLeft = align && align !== "left", shadows = wrapper.shadows;
            css(elem, {
                marginLeft: translateX,
                marginTop: translateY
            });
            if (shadows) {
                each(shadows, function(shadow) {
                    css(shadow, {
                        marginLeft: translateX + 1,
                        marginTop: translateY + 1
                    });
                });
            }
            if (wrapper.inverted) {
                each(elem.childNodes, function(child) {
                    renderer.invertChild(child, elem);
                });
            }
            if (elem.tagName === "SPAN") {
                var width, height, rotation = wrapper.rotation, baseline, radians = 0, costheta = 1, sintheta = 0, quad, textWidth = pInt(wrapper.textWidth), xCorr = wrapper.xCorr || 0, yCorr = wrapper.yCorr || 0, currentTextTransform = [ rotation, align, elem.innerHTML, wrapper.textWidth ].join(",");
                if (currentTextTransform !== wrapper.cTT) {
                    if (defined(rotation)) {
                        radians = rotation * deg2rad;
                        costheta = mathCos(radians);
                        sintheta = mathSin(radians);
                        wrapper.setSpanRotation(rotation, sintheta, costheta);
                    }
                    width = pick(wrapper.elemWidth, elem.offsetWidth);
                    height = pick(wrapper.elemHeight, elem.offsetHeight);
                    if (width > textWidth && /[ \-]/.test(elem.textContent || elem.innerText)) {
                        css(elem, {
                            width: textWidth + PX,
                            display: "block",
                            whiteSpace: "normal"
                        });
                        width = textWidth;
                    }
                    baseline = renderer.fontMetrics(elem.style.fontSize).b;
                    xCorr = costheta < 0 && -width;
                    yCorr = sintheta < 0 && -height;
                    quad = costheta * sintheta < 0;
                    xCorr += sintheta * baseline * (quad ? 1 - alignCorrection : alignCorrection);
                    yCorr -= costheta * baseline * (rotation ? quad ? alignCorrection : 1 - alignCorrection : 1);
                    if (nonLeft) {
                        xCorr -= width * alignCorrection * (costheta < 0 ? -1 : 1);
                        if (rotation) {
                            yCorr -= height * alignCorrection * (sintheta < 0 ? -1 : 1);
                        }
                        css(elem, {
                            textAlign: align
                        });
                    }
                    wrapper.xCorr = xCorr;
                    wrapper.yCorr = yCorr;
                }
                css(elem, {
                    left: x + xCorr + PX,
                    top: y + yCorr + PX
                });
                if (isWebKit) {
                    height = elem.offsetHeight;
                }
                wrapper.cTT = currentTextTransform;
            }
        },
        setSpanRotation: function(rotation) {
            var rotationStyle = {}, cssTransformKey = isIE ? "-ms-transform" : isWebKit ? "-webkit-transform" : isFirefox ? "MozTransform" : isOpera ? "-o-transform" : "";
            rotationStyle[cssTransformKey] = rotationStyle.transform = "rotate(" + rotation + "deg)";
            css(this.element, rotationStyle);
        },
        updateTransform: function() {
            var wrapper = this, translateX = wrapper.translateX || 0, translateY = wrapper.translateY || 0, scaleX = wrapper.scaleX, scaleY = wrapper.scaleY, inverted = wrapper.inverted, rotation = wrapper.rotation, transform;
            if (inverted) {
                translateX += wrapper.attr("width");
                translateY += wrapper.attr("height");
            }
            transform = [ "translate(" + translateX + "," + translateY + ")" ];
            if (inverted) {
                transform.push("rotate(90) scale(-1,1)");
            } else if (rotation) {
                transform.push("rotate(" + rotation + " " + (wrapper.x || 0) + " " + (wrapper.y || 0) + ")");
            }
            if (defined(scaleX) || defined(scaleY)) {
                transform.push("scale(" + pick(scaleX, 1) + " " + pick(scaleY, 1) + ")");
            }
            if (transform.length) {
                attr(wrapper.element, "transform", transform.join(" "));
            }
        },
        toFront: function() {
            var element = this.element;
            element.parentNode.appendChild(element);
            return this;
        },
        align: function(alignOptions, alignByTranslate, box) {
            var align, vAlign, x, y, attribs = {}, alignTo, renderer = this.renderer, alignedObjects = renderer.alignedObjects;
            if (alignOptions) {
                this.alignOptions = alignOptions;
                this.alignByTranslate = alignByTranslate;
                if (!box || isString(box)) {
                    this.alignTo = alignTo = box || "renderer";
                    erase(alignedObjects, this);
                    alignedObjects.push(this);
                    box = null;
                }
            } else {
                alignOptions = this.alignOptions;
                alignByTranslate = this.alignByTranslate;
                alignTo = this.alignTo;
            }
            box = pick(box, renderer[alignTo], renderer);
            align = alignOptions.align;
            vAlign = alignOptions.verticalAlign;
            x = (box.x || 0) + (alignOptions.x || 0);
            y = (box.y || 0) + (alignOptions.y || 0);
            if (align === "right" || align === "center") {
                x += (box.width - (alignOptions.width || 0)) / {
                    right: 1,
                    center: 2
                }[align];
            }
            attribs[alignByTranslate ? "translateX" : "x"] = mathRound(x);
            if (vAlign === "bottom" || vAlign === "middle") {
                y += (box.height - (alignOptions.height || 0)) / ({
                    bottom: 1,
                    middle: 2
                }[vAlign] || 1);
            }
            attribs[alignByTranslate ? "translateY" : "y"] = mathRound(y);
            this[this.placed ? "animate" : "attr"](attribs);
            this.placed = true;
            this.alignAttr = attribs;
            return this;
        },
        getBBox: function() {
            var wrapper = this, bBox = wrapper.bBox, renderer = wrapper.renderer, width, height, rotation = wrapper.rotation, element = wrapper.element, styles = wrapper.styles, rad = rotation * deg2rad;
            if (!bBox) {
                if (element.namespaceURI === SVG_NS || renderer.forExport) {
                    try {
                        bBox = element.getBBox ? extend({}, element.getBBox()) : {
                            width: element.offsetWidth,
                            height: element.offsetHeight
                        };
                    } catch (e) {}
                    if (!bBox || bBox.width < 0) {
                        bBox = {
                            width: 0,
                            height: 0
                        };
                    }
                } else {
                    bBox = wrapper.htmlGetBBox();
                }
                if (renderer.isSVG) {
                    width = bBox.width;
                    height = bBox.height;
                    if (isIE && styles && styles.fontSize === "11px" && height.toPrecision(3) === "22.7") {
                        bBox.height = height = 14;
                    }
                    if (rotation) {
                        bBox.width = mathAbs(height * mathSin(rad)) + mathAbs(width * mathCos(rad));
                        bBox.height = mathAbs(height * mathCos(rad)) + mathAbs(width * mathSin(rad));
                    }
                }
                wrapper.bBox = bBox;
            }
            return bBox;
        },
        show: function() {
            return this.attr({
                visibility: VISIBLE
            });
        },
        hide: function() {
            return this.attr({
                visibility: HIDDEN
            });
        },
        fadeOut: function(duration) {
            var elemWrapper = this;
            elemWrapper.animate({
                opacity: 0
            }, {
                duration: duration || 150,
                complete: function() {
                    elemWrapper.hide();
                }
            });
        },
        add: function(parent) {
            var renderer = this.renderer, parentWrapper = parent || renderer, parentNode = parentWrapper.element || renderer.box, childNodes = parentNode.childNodes, element = this.element, zIndex = attr(element, "zIndex"), otherElement, otherZIndex, i, inserted;
            if (parent) {
                this.parentGroup = parent;
            }
            this.parentInverted = parent && parent.inverted;
            if (this.textStr !== undefined) {
                renderer.buildText(this);
            }
            if (zIndex) {
                parentWrapper.handleZ = true;
                zIndex = pInt(zIndex);
            }
            if (parentWrapper.handleZ) {
                for (i = 0; i < childNodes.length; i++) {
                    otherElement = childNodes[i];
                    otherZIndex = attr(otherElement, "zIndex");
                    if (otherElement !== element && (pInt(otherZIndex) > zIndex || !defined(zIndex) && defined(otherZIndex))) {
                        parentNode.insertBefore(element, otherElement);
                        inserted = true;
                        break;
                    }
                }
            }
            if (!inserted) {
                parentNode.appendChild(element);
            }
            this.added = true;
            fireEvent(this, "add");
            return this;
        },
        safeRemoveChild: function(element) {
            var parentNode = element.parentNode;
            if (parentNode) {
                parentNode.removeChild(element);
            }
        },
        destroy: function() {
            var wrapper = this, element = wrapper.element || {}, shadows = wrapper.shadows, parentToClean = wrapper.renderer.isSVG && element.nodeName === "SPAN" && element.parentNode, grandParent, key, i;
            element.onclick = element.onmouseout = element.onmouseover = element.onmousemove = element.point = null;
            stop(wrapper);
            if (wrapper.clipPath) {
                wrapper.clipPath = wrapper.clipPath.destroy();
            }
            if (wrapper.stops) {
                for (i = 0; i < wrapper.stops.length; i++) {
                    wrapper.stops[i] = wrapper.stops[i].destroy();
                }
                wrapper.stops = null;
            }
            wrapper.safeRemoveChild(element);
            if (shadows) {
                each(shadows, function(shadow) {
                    wrapper.safeRemoveChild(shadow);
                });
            }
            while (parentToClean && parentToClean.childNodes.length === 0) {
                grandParent = parentToClean.parentNode;
                wrapper.safeRemoveChild(parentToClean);
                parentToClean = grandParent;
            }
            if (wrapper.alignTo) {
                erase(wrapper.renderer.alignedObjects, wrapper);
            }
            for (key in wrapper) {
                delete wrapper[key];
            }
            return null;
        },
        shadow: function(shadowOptions, group, cutOff) {
            var shadows = [], i, shadow, element = this.element, strokeWidth, shadowWidth, shadowElementOpacity, transform;
            if (shadowOptions) {
                shadowWidth = pick(shadowOptions.width, 3);
                shadowElementOpacity = (shadowOptions.opacity || .15) / shadowWidth;
                transform = this.parentInverted ? "(-1,-1)" : "(" + pick(shadowOptions.offsetX, 1) + ", " + pick(shadowOptions.offsetY, 1) + ")";
                for (i = 1; i <= shadowWidth; i++) {
                    shadow = element.cloneNode(0);
                    strokeWidth = shadowWidth * 2 + 1 - 2 * i;
                    attr(shadow, {
                        isShadow: "true",
                        stroke: shadowOptions.color || "black",
                        "stroke-opacity": shadowElementOpacity * i,
                        "stroke-width": strokeWidth,
                        transform: "translate" + transform,
                        fill: NONE
                    });
                    if (cutOff) {
                        attr(shadow, "height", mathMax(attr(shadow, "height") - strokeWidth, 0));
                        shadow.cutHeight = strokeWidth;
                    }
                    if (group) {
                        group.element.appendChild(shadow);
                    } else {
                        element.parentNode.insertBefore(shadow, element);
                    }
                    shadows.push(shadow);
                }
                this.shadows = shadows;
            }
            return this;
        }
    };
    var SVGRenderer = function() {
        this.init.apply(this, arguments);
    };
    SVGRenderer.prototype = {
        Element: SVGElement,
        init: function(container, width, height, forExport) {
            var renderer = this, loc = location, boxWrapper, element, desc;
            boxWrapper = renderer.createElement("svg").attr({
                version: "1.1"
            });
            element = boxWrapper.element;
            container.appendChild(element);
            if (container.innerHTML.indexOf("xmlns") === -1) {
                attr(element, "xmlns", SVG_NS);
            }
            renderer.isSVG = true;
            renderer.box = element;
            renderer.boxWrapper = boxWrapper;
            renderer.alignedObjects = [];
            renderer.url = (isFirefox || isWebKit) && doc.getElementsByTagName("base").length ? loc.href.replace(/#.*?$/, "").replace(/([\('\)])/g, "\\$1").replace(/ /g, "%20") : "";
            desc = this.createElement("desc").add();
            desc.element.appendChild(doc.createTextNode("Created with " + PRODUCT + " " + VERSION));
            renderer.defs = this.createElement("defs").add();
            renderer.forExport = forExport;
            renderer.gradients = {};
            renderer.setSize(width, height, false);
            var subPixelFix, rect;
            if (isFirefox && container.getBoundingClientRect) {
                renderer.subPixelFix = subPixelFix = function() {
                    css(container, {
                        left: 0,
                        top: 0
                    });
                    rect = container.getBoundingClientRect();
                    css(container, {
                        left: mathCeil(rect.left) - rect.left + PX,
                        top: mathCeil(rect.top) - rect.top + PX
                    });
                };
                subPixelFix();
                addEvent(win, "resize", subPixelFix);
            }
        },
        isHidden: function() {
            return !this.boxWrapper.getBBox().width;
        },
        destroy: function() {
            var renderer = this, rendererDefs = renderer.defs;
            renderer.box = null;
            renderer.boxWrapper = renderer.boxWrapper.destroy();
            destroyObjectProperties(renderer.gradients || {});
            renderer.gradients = null;
            if (rendererDefs) {
                renderer.defs = rendererDefs.destroy();
            }
            if (renderer.subPixelFix) {
                removeEvent(win, "resize", renderer.subPixelFix);
            }
            renderer.alignedObjects = null;
            return null;
        },
        createElement: function(nodeName) {
            var wrapper = new this.Element();
            wrapper.init(this, nodeName);
            return wrapper;
        },
        draw: function() {},
        buildText: function(wrapper) {
            var textNode = wrapper.element, renderer = this, forExport = renderer.forExport, lines = pick(wrapper.textStr, "").toString().replace(/<(b|strong)>/g, '<span style="font-weight:bold">').replace(/<(i|em)>/g, '<span style="font-style:italic">').replace(/<a/g, "<span").replace(/<\/(b|strong|i|em|a)>/g, "</span>").split(/<br.*?>/g), childNodes = textNode.childNodes, styleRegex = /style="([^"]+)"/, hrefRegex = /href="(http[^"]+)"/, parentX = attr(textNode, "x"), textStyles = wrapper.styles, width = textStyles && textStyles.width && pInt(textStyles.width), textLineHeight = textStyles && textStyles.lineHeight, i = childNodes.length;
            while (i--) {
                textNode.removeChild(childNodes[i]);
            }
            if (width && !wrapper.added) {
                this.box.appendChild(textNode);
            }
            if (lines[lines.length - 1] === "") {
                lines.pop();
            }
            each(lines, function(line, lineNo) {
                var spans, spanNo = 0;
                line = line.replace(/<span/g, "|||<span").replace(/<\/span>/g, "</span>|||");
                spans = line.split("|||");
                each(spans, function(span) {
                    if (span !== "" || spans.length === 1) {
                        var attributes = {}, tspan = doc.createElementNS(SVG_NS, "tspan"), spanStyle;
                        if (styleRegex.test(span)) {
                            spanStyle = span.match(styleRegex)[1].replace(/(;| |^)color([ :])/, "$1fill$2");
                            attr(tspan, "style", spanStyle);
                        }
                        if (hrefRegex.test(span) && !forExport) {
                            attr(tspan, "onclick", 'location.href="' + span.match(hrefRegex)[1] + '"');
                            css(tspan, {
                                cursor: "pointer"
                            });
                        }
                        span = (span.replace(/<(.|\n)*?>/g, "") || " ").replace(/&lt;/g, "<").replace(/&gt;/g, ">");
                        if (span !== " ") {
                            tspan.appendChild(doc.createTextNode(span));
                            if (!spanNo) {
                                attributes.x = parentX;
                            } else {
                                attributes.dx = 0;
                            }
                            attr(tspan, attributes);
                            if (!spanNo && lineNo) {
                                if (!hasSVG && forExport) {
                                    css(tspan, {
                                        display: "block"
                                    });
                                }
                                attr(tspan, "dy", textLineHeight || renderer.fontMetrics(/px$/.test(tspan.style.fontSize) ? tspan.style.fontSize : textStyles.fontSize).h, isWebKit && tspan.offsetHeight);
                            }
                            textNode.appendChild(tspan);
                            spanNo++;
                            if (width) {
                                var words = span.replace(/([^\^])-/g, "$1- ").split(" "), tooLong, actualWidth, rest = [];
                                while (words.length || rest.length) {
                                    delete wrapper.bBox;
                                    actualWidth = wrapper.getBBox().width;
                                    tooLong = actualWidth > width;
                                    if (!tooLong || words.length === 1) {
                                        words = rest;
                                        rest = [];
                                        if (words.length) {
                                            tspan = doc.createElementNS(SVG_NS, "tspan");
                                            attr(tspan, {
                                                dy: textLineHeight || 16,
                                                x: parentX
                                            });
                                            if (spanStyle) {
                                                attr(tspan, "style", spanStyle);
                                            }
                                            textNode.appendChild(tspan);
                                            if (actualWidth > width) {
                                                width = actualWidth;
                                            }
                                        }
                                    } else {
                                        tspan.removeChild(tspan.firstChild);
                                        rest.unshift(words.pop());
                                    }
                                    if (words.length) {
                                        tspan.appendChild(doc.createTextNode(words.join(" ").replace(/- /g, "-")));
                                    }
                                }
                            }
                        }
                    }
                });
            });
        },
        button: function(text, x, y, callback, normalState, hoverState, pressedState, disabledState) {
            var label = this.label(text, x, y, null, null, null, null, null, "button"), curState = 0, stateOptions, stateStyle, normalStyle, hoverStyle, pressedStyle, disabledStyle, STYLE = "style", verticalGradient = {
                x1: 0,
                y1: 0,
                x2: 0,
                y2: 1
            };
            normalState = merge({
                "stroke-width": 1,
                stroke: "#CCCCCC",
                fill: {
                    linearGradient: verticalGradient,
                    stops: [ [ 0, "#FEFEFE" ], [ 1, "#F6F6F6" ] ]
                },
                r: 2,
                padding: 5,
                style: {
                    color: "black"
                }
            }, normalState);
            normalStyle = normalState[STYLE];
            delete normalState[STYLE];
            hoverState = merge(normalState, {
                stroke: "#68A",
                fill: {
                    linearGradient: verticalGradient,
                    stops: [ [ 0, "#FFF" ], [ 1, "#ACF" ] ]
                }
            }, hoverState);
            hoverStyle = hoverState[STYLE];
            delete hoverState[STYLE];
            pressedState = merge(normalState, {
                stroke: "#68A",
                fill: {
                    linearGradient: verticalGradient,
                    stops: [ [ 0, "#9BD" ], [ 1, "#CDF" ] ]
                }
            }, pressedState);
            pressedStyle = pressedState[STYLE];
            delete pressedState[STYLE];
            disabledState = merge(normalState, {
                style: {
                    color: "#CCC"
                }
            }, disabledState);
            disabledStyle = disabledState[STYLE];
            delete disabledState[STYLE];
            addEvent(label.element, isIE ? "mouseover" : "mouseenter", function() {
                if (curState !== 3) {
                    label.attr(hoverState).css(hoverStyle);
                }
            });
            addEvent(label.element, isIE ? "mouseout" : "mouseleave", function() {
                if (curState !== 3) {
                    stateOptions = [ normalState, hoverState, pressedState ][curState];
                    stateStyle = [ normalStyle, hoverStyle, pressedStyle ][curState];
                    label.attr(stateOptions).css(stateStyle);
                }
            });
            label.setState = function(state) {
                label.state = curState = state;
                if (!state) {
                    label.attr(normalState).css(normalStyle);
                } else if (state === 2) {
                    label.attr(pressedState).css(pressedStyle);
                } else if (state === 3) {
                    label.attr(disabledState).css(disabledStyle);
                }
            };
            return label.on("click", function() {
                if (curState !== 3) {
                    callback.call(label);
                }
            }).attr(normalState).css(extend({
                cursor: "default"
            }, normalStyle));
        },
        crispLine: function(points, width) {
            if (points[1] === points[4]) {
                points[1] = points[4] = mathRound(points[1]) - width % 2 / 2;
            }
            if (points[2] === points[5]) {
                points[2] = points[5] = mathRound(points[2]) + width % 2 / 2;
            }
            return points;
        },
        path: function(path) {
            var attr = {
                fill: NONE
            };
            if (isArray(path)) {
                attr.d = path;
            } else if (isObject(path)) {
                extend(attr, path);
            }
            return this.createElement("path").attr(attr);
        },
        circle: function(x, y, r) {
            var attr = isObject(x) ? x : {
                x: x,
                y: y,
                r: r
            };
            return this.createElement("circle").attr(attr);
        },
        arc: function(x, y, r, innerR, start, end) {
            var arc;
            if (isObject(x)) {
                y = x.y;
                r = x.r;
                innerR = x.innerR;
                start = x.start;
                end = x.end;
                x = x.x;
            }
            arc = this.symbol("arc", x || 0, y || 0, r || 0, r || 0, {
                innerR: innerR || 0,
                start: start || 0,
                end: end || 0
            });
            arc.r = r;
            return arc;
        },
        rect: function(x, y, width, height, r, strokeWidth) {
            r = isObject(x) ? x.r : r;
            var wrapper = this.createElement("rect").attr({
                rx: r,
                ry: r,
                fill: NONE
            });
            return wrapper.attr(isObject(x) ? x : wrapper.crisp(strokeWidth, x, y, mathMax(width, 0), mathMax(height, 0)));
        },
        setSize: function(width, height, animate) {
            var renderer = this, alignedObjects = renderer.alignedObjects, i = alignedObjects.length;
            renderer.width = width;
            renderer.height = height;
            renderer.boxWrapper[pick(animate, true) ? "animate" : "attr"]({
                width: width,
                height: height
            });
            while (i--) {
                alignedObjects[i].align();
            }
        },
        g: function(name) {
            var elem = this.createElement("g");
            return defined(name) ? elem.attr({
                "class": PREFIX + name
            }) : elem;
        },
        image: function(src, x, y, width, height) {
            var attribs = {
                preserveAspectRatio: NONE
            }, elemWrapper;
            if (arguments.length > 1) {
                extend(attribs, {
                    x: x,
                    y: y,
                    width: width,
                    height: height
                });
            }
            elemWrapper = this.createElement("image").attr(attribs);
            if (elemWrapper.element.setAttributeNS) {
                elemWrapper.element.setAttributeNS("http://www.w3.org/1999/xlink", "href", src);
            } else {
                elemWrapper.element.setAttribute("hc-svg-href", src);
            }
            return elemWrapper;
        },
        symbol: function(symbol, x, y, width, height, options) {
            var obj, symbolFn = this.symbols[symbol], path = symbolFn && symbolFn(mathRound(x), mathRound(y), width, height, options), imageElement, imageRegex = /^url\((.*?)\)$/, imageSrc, imageSize, centerImage;
            if (path) {
                obj = this.path(path);
                extend(obj, {
                    symbolName: symbol,
                    x: x,
                    y: y,
                    width: width,
                    height: height
                });
                if (options) {
                    extend(obj, options);
                }
            } else if (imageRegex.test(symbol)) {
                centerImage = function(img, size) {
                    if (img.element) {
                        img.attr({
                            width: size[0],
                            height: size[1]
                        });
                        if (!img.alignByTranslate) {
                            img.translate(mathRound((width - size[0]) / 2), mathRound((height - size[1]) / 2));
                        }
                    }
                };
                imageSrc = symbol.match(imageRegex)[1];
                imageSize = symbolSizes[imageSrc];
                obj = this.image(imageSrc).attr({
                    x: x,
                    y: y
                });
                obj.isImg = true;
                if (imageSize) {
                    centerImage(obj, imageSize);
                } else {
                    obj.attr({
                        width: 0,
                        height: 0
                    });
                    imageElement = createElement("img", {
                        onload: function() {
                            centerImage(obj, symbolSizes[imageSrc] = [ this.width, this.height ]);
                        },
                        src: imageSrc
                    });
                }
            }
            return obj;
        },
        symbols: {
            circle: function(x, y, w, h) {
                var cpw = .166 * w;
                return [ M, x + w / 2, y, "C", x + w + cpw, y, x + w + cpw, y + h, x + w / 2, y + h, "C", x - cpw, y + h, x - cpw, y, x + w / 2, y, "Z" ];
            },
            square: function(x, y, w, h) {
                return [ M, x, y, L, x + w, y, x + w, y + h, x, y + h, "Z" ];
            },
            triangle: function(x, y, w, h) {
                return [ M, x + w / 2, y, L, x + w, y + h, x, y + h, "Z" ];
            },
            "triangle-down": function(x, y, w, h) {
                return [ M, x, y, L, x + w, y, x + w / 2, y + h, "Z" ];
            },
            diamond: function(x, y, w, h) {
                return [ M, x + w / 2, y, L, x + w, y + h / 2, x + w / 2, y + h, x, y + h / 2, "Z" ];
            },
            arc: function(x, y, w, h, options) {
                var start = options.start, radius = options.r || w || h, end = options.end - .001, innerRadius = options.innerR, open = options.open, cosStart = mathCos(start), sinStart = mathSin(start), cosEnd = mathCos(end), sinEnd = mathSin(end), longArc = options.end - start < mathPI ? 0 : 1;
                return [ M, x + radius * cosStart, y + radius * sinStart, "A", radius, radius, 0, longArc, 1, x + radius * cosEnd, y + radius * sinEnd, open ? M : L, x + innerRadius * cosEnd, y + innerRadius * sinEnd, "A", innerRadius, innerRadius, 0, longArc, 0, x + innerRadius * cosStart, y + innerRadius * sinStart, open ? "" : "Z" ];
            }
        },
        clipRect: function(x, y, width, height) {
            var wrapper, id = PREFIX + idCounter++, clipPath = this.createElement("clipPath").attr({
                id: id
            }).add(this.defs);
            wrapper = this.rect(x, y, width, height, 0).add(clipPath);
            wrapper.id = id;
            wrapper.clipPath = clipPath;
            return wrapper;
        },
        color: function(color, elem, prop) {
            var renderer = this, colorObject, regexRgba = /^rgba/, gradName, gradAttr, gradients, gradientObject, stops, stopColor, stopOpacity, radialReference, n, id, key = [];
            if (color && color.linearGradient) {
                gradName = "linearGradient";
            } else if (color && color.radialGradient) {
                gradName = "radialGradient";
            }
            if (gradName) {
                gradAttr = color[gradName];
                gradients = renderer.gradients;
                stops = color.stops;
                radialReference = elem.radialReference;
                if (isArray(gradAttr)) {
                    color[gradName] = gradAttr = {
                        x1: gradAttr[0],
                        y1: gradAttr[1],
                        x2: gradAttr[2],
                        y2: gradAttr[3],
                        gradientUnits: "userSpaceOnUse"
                    };
                }
                if (gradName === "radialGradient" && radialReference && !defined(gradAttr.gradientUnits)) {
                    gradAttr = merge(gradAttr, {
                        cx: radialReference[0] - radialReference[2] / 2 + gradAttr.cx * radialReference[2],
                        cy: radialReference[1] - radialReference[2] / 2 + gradAttr.cy * radialReference[2],
                        r: gradAttr.r * radialReference[2],
                        gradientUnits: "userSpaceOnUse"
                    });
                }
                for (n in gradAttr) {
                    if (n !== "id") {
                        key.push(n, gradAttr[n]);
                    }
                }
                for (n in stops) {
                    key.push(stops[n]);
                }
                key = key.join(",");
                if (gradients[key]) {
                    id = gradients[key].id;
                } else {
                    gradAttr.id = id = PREFIX + idCounter++;
                    gradients[key] = gradientObject = renderer.createElement(gradName).attr(gradAttr).add(renderer.defs);
                    gradientObject.stops = [];
                    each(stops, function(stop) {
                        var stopObject;
                        if (regexRgba.test(stop[1])) {
                            colorObject = Color(stop[1]);
                            stopColor = colorObject.get("rgb");
                            stopOpacity = colorObject.get("a");
                        } else {
                            stopColor = stop[1];
                            stopOpacity = 1;
                        }
                        stopObject = renderer.createElement("stop").attr({
                            offset: stop[0],
                            "stop-color": stopColor,
                            "stop-opacity": stopOpacity
                        }).add(gradientObject);
                        gradientObject.stops.push(stopObject);
                    });
                }
                return "url(" + renderer.url + "#" + id + ")";
            } else if (regexRgba.test(color)) {
                colorObject = Color(color);
                attr(elem, prop + "-opacity", colorObject.get("a"));
                return colorObject.get("rgb");
            } else {
                elem.removeAttribute(prop + "-opacity");
                return color;
            }
        },
        text: function(str, x, y, useHTML) {
            var renderer = this, defaultChartStyle = defaultOptions.chart.style, fakeSVG = useCanVG || !hasSVG && renderer.forExport, wrapper;
            if (useHTML && !renderer.forExport) {
                return renderer.html(str, x, y);
            }
            x = mathRound(pick(x, 0));
            y = mathRound(pick(y, 0));
            wrapper = renderer.createElement("text").attr({
                x: x,
                y: y,
                text: str
            }).css({
                fontFamily: defaultChartStyle.fontFamily,
                fontSize: defaultChartStyle.fontSize
            });
            if (fakeSVG) {
                wrapper.css({
                    position: ABSOLUTE
                });
            }
            wrapper.x = x;
            wrapper.y = y;
            return wrapper;
        },
        html: function(str, x, y) {
            var defaultChartStyle = defaultOptions.chart.style, wrapper = this.createElement("span"), attrSetters = wrapper.attrSetters, element = wrapper.element, renderer = wrapper.renderer;
            attrSetters.text = function(value) {
                if (value !== element.innerHTML) {
                    delete this.bBox;
                }
                element.innerHTML = value;
                return false;
            };
            attrSetters.x = attrSetters.y = attrSetters.align = function(value, key) {
                if (key === "align") {
                    key = "textAlign";
                }
                wrapper[key] = value;
                wrapper.htmlUpdateTransform();
                return false;
            };
            wrapper.attr({
                text: str,
                x: mathRound(x),
                y: mathRound(y)
            }).css({
                position: ABSOLUTE,
                whiteSpace: "nowrap",
                fontFamily: defaultChartStyle.fontFamily,
                fontSize: defaultChartStyle.fontSize
            });
            wrapper.css = wrapper.htmlCss;
            if (renderer.isSVG) {
                wrapper.add = function(svgGroupWrapper) {
                    var htmlGroup, container = renderer.box.parentNode, parentGroup, parents = [];
                    if (svgGroupWrapper) {
                        htmlGroup = svgGroupWrapper.div;
                        if (!htmlGroup) {
                            parentGroup = svgGroupWrapper;
                            while (parentGroup) {
                                parents.push(parentGroup);
                                parentGroup = parentGroup.parentGroup;
                            }
                            each(parents.reverse(), function(parentGroup) {
                                var htmlGroupStyle;
                                htmlGroup = parentGroup.div = parentGroup.div || createElement(DIV, {
                                    className: attr(parentGroup.element, "class")
                                }, {
                                    position: ABSOLUTE,
                                    left: (parentGroup.translateX || 0) + PX,
                                    top: (parentGroup.translateY || 0) + PX
                                }, htmlGroup || container);
                                htmlGroupStyle = htmlGroup.style;
                                extend(parentGroup.attrSetters, {
                                    translateX: function(value) {
                                        htmlGroupStyle.left = value + PX;
                                    },
                                    translateY: function(value) {
                                        htmlGroupStyle.top = value + PX;
                                    },
                                    visibility: function(value, key) {
                                        htmlGroupStyle[key] = value;
                                    }
                                });
                            });
                        }
                    } else {
                        htmlGroup = container;
                    }
                    htmlGroup.appendChild(element);
                    wrapper.added = true;
                    if (wrapper.alignOnAdd) {
                        wrapper.htmlUpdateTransform();
                    }
                    return wrapper;
                };
            }
            return wrapper;
        },
        fontMetrics: function(fontSize) {
            fontSize = pInt(fontSize || 11);
            var lineHeight = fontSize < 24 ? fontSize + 4 : mathRound(fontSize * 1.2), baseline = mathRound(lineHeight * .8);
            return {
                h: lineHeight,
                b: baseline
            };
        },
        label: function(str, x, y, shape, anchorX, anchorY, useHTML, baseline, className) {
            var renderer = this, wrapper = renderer.g(className), text = renderer.text("", 0, 0, useHTML).attr({
                zIndex: 1
            }), box, bBox, alignFactor = 0, padding = 3, paddingLeft = 0, width, height, wrapperX, wrapperY, crispAdjust = 0, deferredAttr = {}, baselineOffset, attrSetters = wrapper.attrSetters, needsBox;
            function updateBoxSize() {
                var boxX, boxY, style = text.element.style;
                bBox = (width === undefined || height === undefined || wrapper.styles.textAlign) && text.getBBox();
                wrapper.width = (width || bBox.width || 0) + 2 * padding + paddingLeft;
                wrapper.height = (height || bBox.height || 0) + 2 * padding;
                baselineOffset = padding + renderer.fontMetrics(style && style.fontSize).b;
                if (needsBox) {
                    if (!box) {
                        boxX = mathRound(-alignFactor * padding);
                        boxY = baseline ? -baselineOffset : 0;
                        wrapper.box = box = shape ? renderer.symbol(shape, boxX, boxY, wrapper.width, wrapper.height) : renderer.rect(boxX, boxY, wrapper.width, wrapper.height, 0, deferredAttr[STROKE_WIDTH]);
                        box.add(wrapper);
                    }
                    if (!box.isImg) {
                        box.attr(merge({
                            width: wrapper.width,
                            height: wrapper.height
                        }, deferredAttr));
                    }
                    deferredAttr = null;
                }
            }
            function updateTextPadding() {
                var styles = wrapper.styles, textAlign = styles && styles.textAlign, x = paddingLeft + padding * (1 - alignFactor), y;
                y = baseline ? 0 : baselineOffset;
                if (defined(width) && (textAlign === "center" || textAlign === "right")) {
                    x += {
                        center: .5,
                        right: 1
                    }[textAlign] * (width - bBox.width);
                }
                if (x !== text.x || y !== text.y) {
                    text.attr({
                        x: x,
                        y: y
                    });
                }
                text.x = x;
                text.y = y;
            }
            function boxAttr(key, value) {
                if (box) {
                    box.attr(key, value);
                } else {
                    deferredAttr[key] = value;
                }
            }
            function getSizeAfterAdd() {
                text.add(wrapper);
                wrapper.attr({
                    text: str,
                    x: x,
                    y: y
                });
                if (box && defined(anchorX)) {
                    wrapper.attr({
                        anchorX: anchorX,
                        anchorY: anchorY
                    });
                }
            }
            addEvent(wrapper, "add", getSizeAfterAdd);
            attrSetters.width = function(value) {
                width = value;
                return false;
            };
            attrSetters.height = function(value) {
                height = value;
                return false;
            };
            attrSetters.padding = function(value) {
                if (defined(value) && value !== padding) {
                    padding = value;
                    updateTextPadding();
                }
                return false;
            };
            attrSetters.paddingLeft = function(value) {
                if (defined(value) && value !== paddingLeft) {
                    paddingLeft = value;
                    updateTextPadding();
                }
                return false;
            };
            attrSetters.align = function(value) {
                alignFactor = {
                    left: 0,
                    center: .5,
                    right: 1
                }[value];
                return false;
            };
            attrSetters.text = function(value, key) {
                text.attr(key, value);
                updateBoxSize();
                updateTextPadding();
                return false;
            };
            attrSetters[STROKE_WIDTH] = function(value, key) {
                needsBox = true;
                crispAdjust = value % 2 / 2;
                boxAttr(key, value);
                return false;
            };
            attrSetters.stroke = attrSetters.fill = attrSetters.r = function(value, key) {
                if (key === "fill") {
                    needsBox = true;
                }
                boxAttr(key, value);
                return false;
            };
            attrSetters.anchorX = function(value, key) {
                anchorX = value;
                boxAttr(key, value + crispAdjust - wrapperX);
                return false;
            };
            attrSetters.anchorY = function(value, key) {
                anchorY = value;
                boxAttr(key, value - wrapperY);
                return false;
            };
            attrSetters.x = function(value) {
                wrapper.x = value;
                value -= alignFactor * ((width || bBox.width) + padding);
                wrapperX = mathRound(value);
                wrapper.attr("translateX", wrapperX);
                return false;
            };
            attrSetters.y = function(value) {
                wrapperY = wrapper.y = mathRound(value);
                wrapper.attr("translateY", wrapperY);
                return false;
            };
            var baseCss = wrapper.css;
            return extend(wrapper, {
                css: function(styles) {
                    if (styles) {
                        var textStyles = {};
                        styles = merge(styles);
                        each([ "fontSize", "fontWeight", "fontFamily", "color", "lineHeight", "width", "textDecoration", "textShadow" ], function(prop) {
                            if (styles[prop] !== UNDEFINED) {
                                textStyles[prop] = styles[prop];
                                delete styles[prop];
                            }
                        });
                        text.css(textStyles);
                    }
                    return baseCss.call(wrapper, styles);
                },
                getBBox: function() {
                    return {
                        width: bBox.width + 2 * padding,
                        height: bBox.height + 2 * padding,
                        x: bBox.x - padding,
                        y: bBox.y - padding
                    };
                },
                shadow: function(b) {
                    if (box) {
                        box.shadow(b);
                    }
                    return wrapper;
                },
                destroy: function() {
                    removeEvent(wrapper, "add", getSizeAfterAdd);
                    removeEvent(wrapper.element, "mouseenter");
                    removeEvent(wrapper.element, "mouseleave");
                    if (text) {
                        text = text.destroy();
                    }
                    if (box) {
                        box = box.destroy();
                    }
                    SVGElement.prototype.destroy.call(wrapper);
                    wrapper = renderer = updateBoxSize = updateTextPadding = boxAttr = getSizeAfterAdd = null;
                }
            });
        }
    };
    Renderer = SVGRenderer;
    var VMLRenderer, VMLElement;
    if (!hasSVG && !useCanVG) {
        Highcharts.VMLElement = VMLElement = {
            init: function(renderer, nodeName) {
                var wrapper = this, markup = [ "<", nodeName, ' filled="f" stroked="f"' ], style = [ "position: ", ABSOLUTE, ";" ], isDiv = nodeName === DIV;
                if (nodeName === "shape" || isDiv) {
                    style.push("left:0;top:0;width:1px;height:1px;");
                }
                style.push("visibility: ", isDiv ? HIDDEN : VISIBLE);
                markup.push(' style="', style.join(""), '"/>');
                if (nodeName) {
                    markup = isDiv || nodeName === "span" || nodeName === "img" ? markup.join("") : renderer.prepVML(markup);
                    wrapper.element = createElement(markup);
                }
                wrapper.renderer = renderer;
                wrapper.attrSetters = {};
            },
            add: function(parent) {
                var wrapper = this, renderer = wrapper.renderer, element = wrapper.element, box = renderer.box, inverted = parent && parent.inverted, parentNode = parent ? parent.element || parent : box;
                if (inverted) {
                    renderer.invertChild(element, parentNode);
                }
                parentNode.appendChild(element);
                wrapper.added = true;
                if (wrapper.alignOnAdd && !wrapper.deferUpdateTransform) {
                    wrapper.updateTransform();
                }
                fireEvent(wrapper, "add");
                return wrapper;
            },
            updateTransform: SVGElement.prototype.htmlUpdateTransform,
            setSpanRotation: function(rotation, sintheta, costheta) {
                css(this.element, {
                    filter: rotation ? [ "progid:DXImageTransform.Microsoft.Matrix(M11=", costheta, ", M12=", -sintheta, ", M21=", sintheta, ", M22=", costheta, ", sizingMethod='auto expand')" ].join("") : NONE
                });
            },
            pathToVML: function(value) {
                var i = value.length, path = [], clockwise;
                while (i--) {
                    if (isNumber(value[i])) {
                        path[i] = mathRound(value[i] * 10) - 5;
                    } else if (value[i] === "Z") {
                        path[i] = "x";
                    } else {
                        path[i] = value[i];
                        if (value.isArc && (value[i] === "wa" || value[i] === "at")) {
                            clockwise = value[i] === "wa" ? 1 : -1;
                            if (path[i + 5] === path[i + 7]) {
                                path[i + 7] -= clockwise;
                            }
                            if (path[i + 6] === path[i + 8]) {
                                path[i + 8] -= clockwise;
                            }
                        }
                    }
                }
                return path.join(" ") || "x";
            },
            attr: function(hash, val) {
                var wrapper = this, key, value, i, result, element = wrapper.element || {}, elemStyle = element.style, nodeName = element.nodeName, renderer = wrapper.renderer, symbolName = wrapper.symbolName, hasSetSymbolSize, shadows = wrapper.shadows, skipAttr, attrSetters = wrapper.attrSetters, ret = wrapper;
                if (isString(hash) && defined(val)) {
                    key = hash;
                    hash = {};
                    hash[key] = val;
                }
                if (isString(hash)) {
                    key = hash;
                    if (key === "strokeWidth" || key === "stroke-width") {
                        ret = wrapper.strokeweight;
                    } else {
                        ret = wrapper[key];
                    }
                } else {
                    for (key in hash) {
                        value = hash[key];
                        skipAttr = false;
                        result = attrSetters[key] && attrSetters[key].call(wrapper, value, key);
                        if (result !== false && value !== null) {
                            if (result !== UNDEFINED) {
                                value = result;
                            }
                            if (symbolName && /^(x|y|r|start|end|width|height|innerR|anchorX|anchorY)/.test(key)) {
                                if (!hasSetSymbolSize) {
                                    wrapper.symbolAttr(hash);
                                    hasSetSymbolSize = true;
                                }
                                skipAttr = true;
                            } else if (key === "d") {
                                value = value || [];
                                wrapper.d = value.join(" ");
                                element.path = value = wrapper.pathToVML(value);
                                if (shadows) {
                                    i = shadows.length;
                                    while (i--) {
                                        shadows[i].path = shadows[i].cutOff ? this.cutOffPath(value, shadows[i].cutOff) : value;
                                    }
                                }
                                skipAttr = true;
                            } else if (key === "visibility") {
                                if (shadows) {
                                    i = shadows.length;
                                    while (i--) {
                                        shadows[i].style[key] = value;
                                    }
                                }
                                if (nodeName === "DIV") {
                                    value = value === HIDDEN ? "-999em" : 0;
                                    if (!docMode8) {
                                        elemStyle[key] = value ? VISIBLE : HIDDEN;
                                    }
                                    key = "top";
                                }
                                elemStyle[key] = value;
                                skipAttr = true;
                            } else if (key === "zIndex") {
                                if (value) {
                                    elemStyle[key] = value;
                                }
                                skipAttr = true;
                            } else if (inArray(key, [ "x", "y", "width", "height" ]) !== -1) {
                                wrapper[key] = value;
                                if (key === "x" || key === "y") {
                                    key = {
                                        x: "left",
                                        y: "top"
                                    }[key];
                                } else {
                                    value = mathMax(0, value);
                                }
                                if (wrapper.updateClipping) {
                                    wrapper[key] = value;
                                    wrapper.updateClipping();
                                } else {
                                    elemStyle[key] = value;
                                }
                                skipAttr = true;
                            } else if (key === "class" && nodeName === "DIV") {
                                element.className = value;
                            } else if (key === "stroke") {
                                value = renderer.color(value, element, key);
                                key = "strokecolor";
                            } else if (key === "stroke-width" || key === "strokeWidth") {
                                element.stroked = value ? true : false;
                                key = "strokeweight";
                                wrapper[key] = value;
                                if (isNumber(value)) {
                                    value += PX;
                                }
                            } else if (key === "dashstyle") {
                                var strokeElem = element.getElementsByTagName("stroke")[0] || createElement(renderer.prepVML([ "<stroke/>" ]), null, null, element);
                                strokeElem[key] = value || "solid";
                                wrapper.dashstyle = value;
                                skipAttr = true;
                            } else if (key === "fill") {
                                if (nodeName === "SPAN") {
                                    elemStyle.color = value;
                                } else if (nodeName !== "IMG") {
                                    element.filled = value !== NONE ? true : false;
                                    value = renderer.color(value, element, key, wrapper);
                                    key = "fillcolor";
                                }
                            } else if (key === "opacity") {
                                skipAttr = true;
                            } else if (nodeName === "shape" && key === "rotation") {
                                wrapper[key] = element.style[key] = value;
                                element.style.left = -mathRound(mathSin(value * deg2rad) + 1) + PX;
                                element.style.top = mathRound(mathCos(value * deg2rad)) + PX;
                            } else if (key === "translateX" || key === "translateY" || key === "rotation") {
                                wrapper[key] = value;
                                wrapper.updateTransform();
                                skipAttr = true;
                            } else if (key === "text") {
                                this.bBox = null;
                                element.innerHTML = value;
                                skipAttr = true;
                            }
                            if (!skipAttr) {
                                if (docMode8) {
                                    element[key] = value;
                                } else {
                                    attr(element, key, value);
                                }
                            }
                        }
                    }
                }
                return ret;
            },
            clip: function(clipRect) {
                var wrapper = this, clipMembers, cssRet;
                if (clipRect) {
                    clipMembers = clipRect.members;
                    erase(clipMembers, wrapper);
                    clipMembers.push(wrapper);
                    wrapper.destroyClip = function() {
                        erase(clipMembers, wrapper);
                    };
                    cssRet = clipRect.getCSS(wrapper);
                } else {
                    if (wrapper.destroyClip) {
                        wrapper.destroyClip();
                    }
                    cssRet = {
                        clip: docMode8 ? "inherit" : "rect(auto)"
                    };
                }
                return wrapper.css(cssRet);
            },
            css: SVGElement.prototype.htmlCss,
            safeRemoveChild: function(element) {
                if (element.parentNode) {
                    discardElement(element);
                }
            },
            destroy: function() {
                if (this.destroyClip) {
                    this.destroyClip();
                }
                return SVGElement.prototype.destroy.apply(this);
            },
            on: function(eventType, handler) {
                this.element["on" + eventType] = function() {
                    var evt = win.event;
                    evt.target = evt.srcElement;
                    handler(evt);
                };
                return this;
            },
            cutOffPath: function(path, length) {
                var len;
                path = path.split(/[ ,]/);
                len = path.length;
                if (len === 9 || len === 11) {
                    path[len - 4] = path[len - 2] = pInt(path[len - 2]) - 10 * length;
                }
                return path.join(" ");
            },
            shadow: function(shadowOptions, group, cutOff) {
                var shadows = [], i, element = this.element, renderer = this.renderer, shadow, elemStyle = element.style, markup, path = element.path, strokeWidth, modifiedPath, shadowWidth, shadowElementOpacity;
                if (path && typeof path.value !== "string") {
                    path = "x";
                }
                modifiedPath = path;
                if (shadowOptions) {
                    shadowWidth = pick(shadowOptions.width, 3);
                    shadowElementOpacity = (shadowOptions.opacity || .15) / shadowWidth;
                    for (i = 1; i <= 3; i++) {
                        strokeWidth = shadowWidth * 2 + 1 - 2 * i;
                        if (cutOff) {
                            modifiedPath = this.cutOffPath(path.value, strokeWidth + .5);
                        }
                        markup = [ '<shape isShadow="true" strokeweight="', strokeWidth, '" filled="false" path="', modifiedPath, '" coordsize="10 10" style="', element.style.cssText, '" />' ];
                        shadow = createElement(renderer.prepVML(markup), null, {
                            left: pInt(elemStyle.left) + pick(shadowOptions.offsetX, 1),
                            top: pInt(elemStyle.top) + pick(shadowOptions.offsetY, 1)
                        });
                        if (cutOff) {
                            shadow.cutOff = strokeWidth + 1;
                        }
                        markup = [ '<stroke color="', shadowOptions.color || "black", '" opacity="', shadowElementOpacity * i, '"/>' ];
                        createElement(renderer.prepVML(markup), null, null, shadow);
                        if (group) {
                            group.element.appendChild(shadow);
                        } else {
                            element.parentNode.insertBefore(shadow, element);
                        }
                        shadows.push(shadow);
                    }
                    this.shadows = shadows;
                }
                return this;
            }
        };
        VMLElement = extendClass(SVGElement, VMLElement);
        var VMLRendererExtension = {
            Element: VMLElement,
            isIE8: userAgent.indexOf("MSIE 8.0") > -1,
            init: function(container, width, height) {
                var renderer = this, boxWrapper, box;
                renderer.alignedObjects = [];
                boxWrapper = renderer.createElement(DIV);
                box = boxWrapper.element;
                box.style.position = RELATIVE;
                container.appendChild(boxWrapper.element);
                renderer.isVML = true;
                renderer.box = box;
                renderer.boxWrapper = boxWrapper;
                renderer.setSize(width, height, false);
                if (!doc.namespaces.hcv) {
                    doc.namespaces.add("hcv", "urn:schemas-microsoft-com:vml");
                    doc.createStyleSheet().cssText = "hcv\\:fill, hcv\\:path, hcv\\:shape, hcv\\:stroke" + "{ behavior:url(#default#VML); display: inline-block; } ";
                }
            },
            isHidden: function() {
                return !this.box.offsetWidth;
            },
            clipRect: function(x, y, width, height) {
                var clipRect = this.createElement(), isObj = isObject(x);
                return extend(clipRect, {
                    members: [],
                    left: (isObj ? x.x : x) + 1,
                    top: (isObj ? x.y : y) + 1,
                    width: (isObj ? x.width : width) - 1,
                    height: (isObj ? x.height : height) - 1,
                    getCSS: function(wrapper) {
                        var element = wrapper.element, nodeName = element.nodeName, isShape = nodeName === "shape", inverted = wrapper.inverted, rect = this, top = rect.top - (isShape ? element.offsetTop : 0), left = rect.left, right = left + rect.width, bottom = top + rect.height, ret = {
                            clip: "rect(" + mathRound(inverted ? left : top) + "px," + mathRound(inverted ? bottom : right) + "px," + mathRound(inverted ? right : bottom) + "px," + mathRound(inverted ? top : left) + "px)"
                        };
                        if (!inverted && docMode8 && nodeName === "DIV") {
                            extend(ret, {
                                width: right + PX,
                                height: bottom + PX
                            });
                        }
                        return ret;
                    },
                    updateClipping: function() {
                        each(clipRect.members, function(member) {
                            member.css(clipRect.getCSS(member));
                        });
                    }
                });
            },
            color: function(color, elem, prop, wrapper) {
                var renderer = this, colorObject, regexRgba = /^rgba/, markup, fillType, ret = NONE;
                if (color && color.linearGradient) {
                    fillType = "gradient";
                } else if (color && color.radialGradient) {
                    fillType = "pattern";
                }
                if (fillType) {
                    var stopColor, stopOpacity, gradient = color.linearGradient || color.radialGradient, x1, y1, x2, y2, opacity1, opacity2, color1, color2, fillAttr = "", stops = color.stops, firstStop, lastStop, colors = [], addFillNode = function() {
                        markup = [ '<fill colors="' + colors.join(",") + '" opacity="', opacity2, '" o:opacity2="', opacity1, '" type="', fillType, '" ', fillAttr, 'focus="100%" method="any" />' ];
                        createElement(renderer.prepVML(markup), null, null, elem);
                    };
                    firstStop = stops[0];
                    lastStop = stops[stops.length - 1];
                    if (firstStop[0] > 0) {
                        stops.unshift([ 0, firstStop[1] ]);
                    }
                    if (lastStop[0] < 1) {
                        stops.push([ 1, lastStop[1] ]);
                    }
                    each(stops, function(stop, i) {
                        if (regexRgba.test(stop[1])) {
                            colorObject = Color(stop[1]);
                            stopColor = colorObject.get("rgb");
                            stopOpacity = colorObject.get("a");
                        } else {
                            stopColor = stop[1];
                            stopOpacity = 1;
                        }
                        colors.push(stop[0] * 100 + "% " + stopColor);
                        if (!i) {
                            opacity1 = stopOpacity;
                            color2 = stopColor;
                        } else {
                            opacity2 = stopOpacity;
                            color1 = stopColor;
                        }
                    });
                    if (prop === "fill") {
                        if (fillType === "gradient") {
                            x1 = gradient.x1 || gradient[0] || 0;
                            y1 = gradient.y1 || gradient[1] || 0;
                            x2 = gradient.x2 || gradient[2] || 0;
                            y2 = gradient.y2 || gradient[3] || 0;
                            fillAttr = 'angle="' + (90 - math.atan((y2 - y1) / (x2 - x1)) * 180 / mathPI) + '"';
                            addFillNode();
                        } else {
                            var r = gradient.r, sizex = r * 2, sizey = r * 2, cx = gradient.cx, cy = gradient.cy, radialReference = elem.radialReference, bBox, applyRadialGradient = function() {
                                if (radialReference) {
                                    bBox = wrapper.getBBox();
                                    cx += (radialReference[0] - bBox.x) / bBox.width - .5;
                                    cy += (radialReference[1] - bBox.y) / bBox.height - .5;
                                    sizex *= radialReference[2] / bBox.width;
                                    sizey *= radialReference[2] / bBox.height;
                                }
                                fillAttr = 'src="' + defaultOptions.global.VMLRadialGradientURL + '" ' + 'size="' + sizex + "," + sizey + '" ' + 'origin="0.5,0.5" ' + 'position="' + cx + "," + cy + '" ' + 'color2="' + color2 + '" ';
                                addFillNode();
                            };
                            if (wrapper.added) {
                                applyRadialGradient();
                            } else {
                                addEvent(wrapper, "add", applyRadialGradient);
                            }
                            ret = color1;
                        }
                    } else {
                        ret = stopColor;
                    }
                } else if (regexRgba.test(color) && elem.tagName !== "IMG") {
                    colorObject = Color(color);
                    markup = [ "<", prop, ' opacity="', colorObject.get("a"), '"/>' ];
                    createElement(this.prepVML(markup), null, null, elem);
                    ret = colorObject.get("rgb");
                } else {
                    var propNodes = elem.getElementsByTagName(prop);
                    if (propNodes.length) {
                        propNodes[0].opacity = 1;
                        propNodes[0].type = "solid";
                    }
                    ret = color;
                }
                return ret;
            },
            prepVML: function(markup) {
                var vmlStyle = "display:inline-block;behavior:url(#default#VML);", isIE8 = this.isIE8;
                markup = markup.join("");
                if (isIE8) {
                    markup = markup.replace("/>", ' xmlns="urn:schemas-microsoft-com:vml" />');
                    if (markup.indexOf('style="') === -1) {
                        markup = markup.replace("/>", ' style="' + vmlStyle + '" />');
                    } else {
                        markup = markup.replace('style="', 'style="' + vmlStyle);
                    }
                } else {
                    markup = markup.replace("<", "<hcv:");
                }
                return markup;
            },
            text: SVGRenderer.prototype.html,
            path: function(path) {
                var attr = {
                    coordsize: "10 10"
                };
                if (isArray(path)) {
                    attr.d = path;
                } else if (isObject(path)) {
                    extend(attr, path);
                }
                return this.createElement("shape").attr(attr);
            },
            circle: function(x, y, r) {
                var circle = this.symbol("circle");
                if (isObject(x)) {
                    r = x.r;
                    y = x.y;
                    x = x.x;
                }
                circle.isCircle = true;
                return circle.attr({
                    x: x,
                    y: y,
                    width: 2 * r,
                    height: 2 * r
                });
            },
            g: function(name) {
                var wrapper, attribs;
                if (name) {
                    attribs = {
                        className: PREFIX + name,
                        "class": PREFIX + name
                    };
                }
                wrapper = this.createElement(DIV).attr(attribs);
                return wrapper;
            },
            image: function(src, x, y, width, height) {
                var obj = this.createElement("img").attr({
                    src: src
                });
                if (arguments.length > 1) {
                    obj.attr({
                        x: x,
                        y: y,
                        width: width,
                        height: height
                    });
                }
                return obj;
            },
            rect: function(x, y, width, height, r, strokeWidth) {
                var wrapper = this.symbol("rect");
                wrapper.r = isObject(x) ? x.r : r;
                return wrapper.attr(isObject(x) ? x : wrapper.crisp(strokeWidth, x, y, mathMax(width, 0), mathMax(height, 0)));
            },
            invertChild: function(element, parentNode) {
                var parentStyle = parentNode.style;
                css(element, {
                    flip: "x",
                    left: pInt(parentStyle.width) - 1,
                    top: pInt(parentStyle.height) - 1,
                    rotation: -90
                });
            },
            symbols: {
                arc: function(x, y, w, h, options) {
                    var start = options.start, end = options.end, radius = options.r || w || h, innerRadius = options.innerR, cosStart = mathCos(start), sinStart = mathSin(start), cosEnd = mathCos(end), sinEnd = mathSin(end), ret;
                    if (end - start === 0) {
                        return [ "x" ];
                    }
                    ret = [ "wa", x - radius, y - radius, x + radius, y + radius, x + radius * cosStart, y + radius * sinStart, x + radius * cosEnd, y + radius * sinEnd ];
                    if (options.open && !innerRadius) {
                        ret.push("e", M, x, y);
                    }
                    ret.push("at", x - innerRadius, y - innerRadius, x + innerRadius, y + innerRadius, x + innerRadius * cosEnd, y + innerRadius * sinEnd, x + innerRadius * cosStart, y + innerRadius * sinStart, "x", "e");
                    ret.isArc = true;
                    return ret;
                },
                circle: function(x, y, w, h, wrapper) {
                    if (wrapper && wrapper.isCircle) {
                        x -= w / 2;
                        y -= h / 2;
                    }
                    return [ "wa", x, y, x + w, y + h, x + w, y + h / 2, x + w, y + h / 2, "e" ];
                },
                rect: function(left, top, width, height, options) {
                    var right = left + width, bottom = top + height, ret, r;
                    if (!defined(options) || !options.r) {
                        ret = SVGRenderer.prototype.symbols.square.apply(0, arguments);
                    } else {
                        r = mathMin(options.r, width, height);
                        ret = [ M, left + r, top, L, right - r, top, "wa", right - 2 * r, top, right, top + 2 * r, right - r, top, right, top + r, L, right, bottom - r, "wa", right - 2 * r, bottom - 2 * r, right, bottom, right, bottom - r, right - r, bottom, L, left + r, bottom, "wa", left, bottom - 2 * r, left + 2 * r, bottom, left + r, bottom, left, bottom - r, L, left, top + r, "wa", left, top, left + 2 * r, top + 2 * r, left, top + r, left + r, top, "x", "e" ];
                    }
                    return ret;
                }
            }
        };
        Highcharts.VMLRenderer = VMLRenderer = function() {
            this.init.apply(this, arguments);
        };
        VMLRenderer.prototype = merge(SVGRenderer.prototype, VMLRendererExtension);
        Renderer = VMLRenderer;
    }
    var CanVGRenderer, CanVGController;
    if (useCanVG) {
        Highcharts.CanVGRenderer = CanVGRenderer = function() {
            SVG_NS = "http://www.w3.org/1999/xhtml";
        };
        CanVGRenderer.prototype.symbols = {};
        CanVGController = function() {
            var deferredRenderCalls = [];
            function drawDeferred() {
                var callLength = deferredRenderCalls.length, callIndex;
                for (callIndex = 0; callIndex < callLength; callIndex++) {
                    deferredRenderCalls[callIndex]();
                }
                deferredRenderCalls = [];
            }
            return {
                push: function(func, scriptLocation) {
                    if (deferredRenderCalls.length === 0) {
                        getScript(scriptLocation, drawDeferred);
                    }
                    deferredRenderCalls.push(func);
                }
            };
        }();
        Renderer = CanVGRenderer;
    }
    function Tick(axis, pos, type, noLabel) {
        this.axis = axis;
        this.pos = pos;
        this.type = type || "";
        this.isNew = true;
        if (!type && !noLabel) {
            this.addLabel();
        }
    }
    Tick.prototype = {
        addLabel: function() {
            var tick = this, axis = tick.axis, options = axis.options, chart = axis.chart, horiz = axis.horiz, categories = axis.categories, names = axis.series[0] && axis.series[0].names, pos = tick.pos, labelOptions = options.labels, str, tickPositions = axis.tickPositions, width = horiz && categories && !labelOptions.step && !labelOptions.staggerLines && !labelOptions.rotation && chart.plotWidth / tickPositions.length || !horiz && (chart.optionsMarginLeft || chart.chartWidth * .33), isFirst = pos === tickPositions[0], isLast = pos === tickPositions[tickPositions.length - 1], css, attr, value = categories ? pick(categories[pos], names && names[pos], pos) : pos, label = tick.label, tickPositionInfo = tickPositions.info, dateTimeLabelFormat;
            if (axis.isDatetimeAxis && tickPositionInfo) {
                dateTimeLabelFormat = options.dateTimeLabelFormats[tickPositionInfo.higherRanks[pos] || tickPositionInfo.unitName];
            }
            tick.isFirst = isFirst;
            tick.isLast = isLast;
            str = axis.labelFormatter.call({
                axis: axis,
                chart: chart,
                isFirst: isFirst,
                isLast: isLast,
                dateTimeLabelFormat: dateTimeLabelFormat,
                value: axis.isLog ? correctFloat(lin2log(value)) : value
            });
            css = width && {
                width: mathMax(1, mathRound(width - 2 * (labelOptions.padding || 10))) + PX
            };
            css = extend(css, labelOptions.style);
            if (!defined(label)) {
                attr = {
                    align: axis.labelAlign
                };
                if (isNumber(labelOptions.rotation)) {
                    attr.rotation = labelOptions.rotation;
                }
                tick.label = defined(str) && labelOptions.enabled ? chart.renderer.text(str, 0, 0, labelOptions.useHTML).attr(attr).css(css).add(axis.labelGroup) : null;
            } else if (label) {
                label.attr({
                    text: str
                }).css(css);
            }
        },
        getLabelSize: function() {
            var label = this.label, axis = this.axis;
            return label ? (this.labelBBox = label.getBBox())[axis.horiz ? "height" : "width"] : 0;
        },
        getLabelSides: function() {
            var bBox = this.labelBBox, axis = this.axis, options = axis.options, labelOptions = options.labels, width = bBox.width, leftSide = width * {
                left: 0,
                center: .5,
                right: 1
            }[axis.labelAlign] - labelOptions.x;
            return [ -leftSide, width - leftSide ];
        },
        handleOverflow: function(index, xy) {
            var show = true, axis = this.axis, chart = axis.chart, isFirst = this.isFirst, isLast = this.isLast, x = xy.x, reversed = axis.reversed, tickPositions = axis.tickPositions;
            if (isFirst || isLast) {
                var sides = this.getLabelSides(), leftSide = sides[0], rightSide = sides[1], plotLeft = chart.plotLeft, plotRight = plotLeft + axis.len, neighbour = axis.ticks[tickPositions[index + (isFirst ? 1 : -1)]], neighbourEdge = neighbour && neighbour.label.xy && neighbour.label.xy.x + neighbour.getLabelSides()[isFirst ? 0 : 1];
                if (isFirst && !reversed || isLast && reversed) {
                    if (x + leftSide < plotLeft) {
                        x = plotLeft - leftSide;
                        if (neighbour && x + rightSide > neighbourEdge) {
                            show = false;
                        }
                    }
                } else {
                    if (x + rightSide > plotRight) {
                        x = plotRight - rightSide;
                        if (neighbour && x + leftSide < neighbourEdge) {
                            show = false;
                        }
                    }
                }
                xy.x = x;
            }
            return show;
        },
        getPosition: function(horiz, pos, tickmarkOffset, old) {
            var axis = this.axis, chart = axis.chart, cHeight = old && chart.oldChartHeight || chart.chartHeight;
            return {
                x: horiz ? axis.translate(pos + tickmarkOffset, null, null, old) + axis.transB : axis.left + axis.offset + (axis.opposite ? (old && chart.oldChartWidth || chart.chartWidth) - axis.right - axis.left : 0),
                y: horiz ? cHeight - axis.bottom + axis.offset - (axis.opposite ? axis.height : 0) : cHeight - axis.translate(pos + tickmarkOffset, null, null, old) - axis.transB
            };
        },
        getLabelPosition: function(x, y, label, horiz, labelOptions, tickmarkOffset, index, step) {
            var axis = this.axis, transA = axis.transA, reversed = axis.reversed, staggerLines = axis.staggerLines, baseline = axis.chart.renderer.fontMetrics(labelOptions.style.fontSize).b, rotation = labelOptions.rotation;
            x = x + labelOptions.x - (tickmarkOffset && horiz ? tickmarkOffset * transA * (reversed ? -1 : 1) : 0);
            y = y + labelOptions.y - (tickmarkOffset && !horiz ? tickmarkOffset * transA * (reversed ? 1 : -1) : 0);
            if (rotation && axis.side === 2) {
                y -= baseline - baseline * mathCos(rotation * deg2rad);
            }
            if (!defined(labelOptions.y) && !rotation) {
                y += baseline - label.getBBox().height / 2;
            }
            if (staggerLines) {
                y += index / (step || 1) % staggerLines * (axis.labelOffset / staggerLines);
            }
            return {
                x: x,
                y: y
            };
        },
        getMarkPath: function(x, y, tickLength, tickWidth, horiz, renderer) {
            return renderer.crispLine([ M, x, y, L, x + (horiz ? 0 : -tickLength), y + (horiz ? tickLength : 0) ], tickWidth);
        },
        render: function(index, old, opacity) {
            var tick = this, axis = tick.axis, options = axis.options, chart = axis.chart, renderer = chart.renderer, horiz = axis.horiz, type = tick.type, label = tick.label, pos = tick.pos, labelOptions = options.labels, gridLine = tick.gridLine, gridPrefix = type ? type + "Grid" : "grid", tickPrefix = type ? type + "Tick" : "tick", gridLineWidth = options[gridPrefix + "LineWidth"], gridLineColor = options[gridPrefix + "LineColor"], dashStyle = options[gridPrefix + "LineDashStyle"], tickLength = options[tickPrefix + "Length"], tickWidth = options[tickPrefix + "Width"] || 0, tickColor = options[tickPrefix + "Color"], tickPosition = options[tickPrefix + "Position"], gridLinePath, mark = tick.mark, markPath, step = labelOptions.step, attribs, show = true, tickmarkOffset = axis.tickmarkOffset, xy = tick.getPosition(horiz, pos, tickmarkOffset, old), x = xy.x, y = xy.y, reverseCrisp = horiz && x === axis.pos + axis.len || !horiz && y === axis.pos ? -1 : 1, staggerLines = axis.staggerLines;
            this.isActive = true;
            if (gridLineWidth) {
                gridLinePath = axis.getPlotLinePath(pos + tickmarkOffset, gridLineWidth * reverseCrisp, old, true);
                if (gridLine === UNDEFINED) {
                    attribs = {
                        stroke: gridLineColor,
                        "stroke-width": gridLineWidth
                    };
                    if (dashStyle) {
                        attribs.dashstyle = dashStyle;
                    }
                    if (!type) {
                        attribs.zIndex = 1;
                    }
                    if (old) {
                        attribs.opacity = 0;
                    }
                    tick.gridLine = gridLine = gridLineWidth ? renderer.path(gridLinePath).attr(attribs).add(axis.gridGroup) : null;
                }
                if (!old && gridLine && gridLinePath) {
                    gridLine[tick.isNew ? "attr" : "animate"]({
                        d: gridLinePath,
                        opacity: opacity
                    });
                }
            }
            if (tickWidth && tickLength) {
                if (tickPosition === "inside") {
                    tickLength = -tickLength;
                }
                if (axis.opposite) {
                    tickLength = -tickLength;
                }
                markPath = tick.getMarkPath(x, y, tickLength, tickWidth * reverseCrisp, horiz, renderer);
                if (mark) {
                    mark.animate({
                        d: markPath,
                        opacity: opacity
                    });
                } else {
                    tick.mark = renderer.path(markPath).attr({
                        stroke: tickColor,
                        "stroke-width": tickWidth,
                        opacity: opacity
                    }).add(axis.axisGroup);
                }
            }
            if (label && !isNaN(x)) {
                label.xy = xy = tick.getLabelPosition(x, y, label, horiz, labelOptions, tickmarkOffset, index, step);
                if (tick.isFirst && !tick.isLast && !pick(options.showFirstLabel, 1) || tick.isLast && !tick.isFirst && !pick(options.showLastLabel, 1)) {
                    show = false;
                } else if (!staggerLines && horiz && labelOptions.overflow === "justify" && !tick.handleOverflow(index, xy)) {
                    show = false;
                }
                if (step && index % step) {
                    show = false;
                }
                if (show && !isNaN(xy.y)) {
                    xy.opacity = opacity;
                    label[tick.isNew ? "attr" : "animate"](xy);
                    tick.isNew = false;
                } else {
                    label.attr("y", -9999);
                }
            }
        },
        destroy: function() {
            destroyObjectProperties(this, this.axis);
        }
    };
    function PlotLineOrBand(axis, options) {
        this.axis = axis;
        if (options) {
            this.options = options;
            this.id = options.id;
        }
    }
    PlotLineOrBand.prototype = {
        render: function() {
            var plotLine = this, axis = plotLine.axis, horiz = axis.horiz, halfPointRange = (axis.pointRange || 0) / 2, options = plotLine.options, optionsLabel = options.label, label = plotLine.label, width = options.width, to = options.to, from = options.from, isBand = defined(from) && defined(to), value = options.value, dashStyle = options.dashStyle, svgElem = plotLine.svgElem, path = [], addEvent, eventType, xs, ys, x, y, color = options.color, zIndex = options.zIndex, events = options.events, attribs, renderer = axis.chart.renderer;
            if (axis.isLog) {
                from = log2lin(from);
                to = log2lin(to);
                value = log2lin(value);
            }
            if (width) {
                path = axis.getPlotLinePath(value, width);
                attribs = {
                    stroke: color,
                    "stroke-width": width
                };
                if (dashStyle) {
                    attribs.dashstyle = dashStyle;
                }
            } else if (isBand) {
                from = mathMax(from, axis.min - halfPointRange);
                to = mathMin(to, axis.max + halfPointRange);
                path = axis.getPlotBandPath(from, to, options);
                attribs = {
                    fill: color
                };
                if (options.borderWidth) {
                    attribs.stroke = options.borderColor;
                    attribs["stroke-width"] = options.borderWidth;
                }
            } else {
                return;
            }
            if (defined(zIndex)) {
                attribs.zIndex = zIndex;
            }
            if (svgElem) {
                if (path) {
                    svgElem.animate({
                        d: path
                    }, null, svgElem.onGetPath);
                } else {
                    svgElem.hide();
                    svgElem.onGetPath = function() {
                        svgElem.show();
                    };
                }
            } else if (path && path.length) {
                plotLine.svgElem = svgElem = renderer.path(path).attr(attribs).add();
                if (events) {
                    addEvent = function(eventType) {
                        svgElem.on(eventType, function(e) {
                            events[eventType].apply(plotLine, [ e ]);
                        });
                    };
                    for (eventType in events) {
                        addEvent(eventType);
                    }
                }
            }
            if (optionsLabel && defined(optionsLabel.text) && path && path.length && axis.width > 0 && axis.height > 0) {
                optionsLabel = merge({
                    align: horiz && isBand && "center",
                    x: horiz ? !isBand && 4 : 10,
                    verticalAlign: !horiz && isBand && "middle",
                    y: horiz ? isBand ? 16 : 10 : isBand ? 6 : -4,
                    rotation: horiz && !isBand && 90
                }, optionsLabel);
                if (!label) {
                    plotLine.label = label = renderer.text(optionsLabel.text, 0, 0, optionsLabel.useHTML).attr({
                        align: optionsLabel.textAlign || optionsLabel.align,
                        rotation: optionsLabel.rotation,
                        zIndex: zIndex
                    }).css(optionsLabel.style).add();
                }
                xs = [ path[1], path[4], pick(path[6], path[1]) ];
                ys = [ path[2], path[5], pick(path[7], path[2]) ];
                x = arrayMin(xs);
                y = arrayMin(ys);
                label.align(optionsLabel, false, {
                    x: x,
                    y: y,
                    width: arrayMax(xs) - x,
                    height: arrayMax(ys) - y
                });
                label.show();
            } else if (label) {
                label.hide();
            }
            return plotLine;
        },
        destroy: function() {
            erase(this.axis.plotLinesAndBands, this);
            delete this.axis;
            destroyObjectProperties(this);
        }
    };
    function StackItem(axis, options, isNegative, x, stackOption, stacking) {
        var inverted = axis.chart.inverted;
        this.axis = axis;
        this.isNegative = isNegative;
        this.options = options;
        this.x = x;
        this.total = null;
        this.points = {};
        this.stack = stackOption;
        this.percent = stacking === "percent";
        this.alignOptions = {
            align: options.align || (inverted ? isNegative ? "left" : "right" : "center"),
            verticalAlign: options.verticalAlign || (inverted ? "middle" : isNegative ? "bottom" : "top"),
            y: pick(options.y, inverted ? 4 : isNegative ? 14 : -6),
            x: pick(options.x, inverted ? isNegative ? -6 : 6 : 0)
        };
        this.textAlign = options.textAlign || (inverted ? isNegative ? "right" : "left" : "center");
    }
    StackItem.prototype = {
        destroy: function() {
            destroyObjectProperties(this, this.axis);
        },
        setTotal: function(total) {
            this.total = total;
            this.cum = total;
        },
        addValue: function(y) {
            this.setTotal(correctFloat(this.total + y));
        },
        render: function(group) {
            var options = this.options, formatOption = options.format, str = formatOption ? format(formatOption, this) : options.formatter.call(this);
            if (this.label) {
                this.label.attr({
                    text: str,
                    visibility: HIDDEN
                });
            } else {
                this.label = this.axis.chart.renderer.text(str, 0, 0, options.useHTML).css(options.style).attr({
                    align: this.textAlign,
                    rotation: options.rotation,
                    visibility: HIDDEN
                }).add(group);
            }
        },
        cacheExtremes: function(series, extremes) {
            this.points[series.index] = extremes;
        },
        setOffset: function(xOffset, xWidth) {
            var stackItem = this, axis = stackItem.axis, chart = axis.chart, inverted = chart.inverted, neg = this.isNegative, y = axis.translate(this.percent ? 100 : this.total, 0, 0, 0, 1), yZero = axis.translate(0), h = mathAbs(y - yZero), x = chart.xAxis[0].translate(this.x) + xOffset, plotHeight = chart.plotHeight, stackBox = {
                x: inverted ? neg ? y : y - h : x,
                y: inverted ? plotHeight - x - xWidth : neg ? plotHeight - y - h : plotHeight - y,
                width: inverted ? h : xWidth,
                height: inverted ? xWidth : h
            }, label = this.label, alignAttr;
            if (label) {
                label.align(this.alignOptions, null, stackBox);
                alignAttr = label.alignAttr;
                label.attr({
                    visibility: this.options.crop === false || chart.isInsidePlot(alignAttr.x, alignAttr.y) ? hasSVG ? "inherit" : VISIBLE : HIDDEN
                });
            }
        }
    };
    function Axis() {
        this.init.apply(this, arguments);
    }
    Axis.prototype = {
        defaultOptions: {
            dateTimeLabelFormats: {
                millisecond: "%H:%M:%S.%L",
                second: "%H:%M:%S",
                minute: "%H:%M",
                hour: "%H:%M",
                day: "%e. %b",
                week: "%e. %b",
                month: "%b '%y",
                year: "%Y"
            },
            endOnTick: false,
            gridLineColor: "#C0C0C0",
            labels: defaultLabelOptions,
            lineColor: "#C0D0E0",
            lineWidth: 1,
            minPadding: .01,
            maxPadding: .01,
            minorGridLineColor: "#E0E0E0",
            minorGridLineWidth: 1,
            minorTickColor: "#A0A0A0",
            minorTickLength: 2,
            minorTickPosition: "outside",
            startOfWeek: 1,
            startOnTick: false,
            tickColor: "#C0D0E0",
            tickLength: 5,
            tickmarkPlacement: "between",
            tickPixelInterval: 100,
            tickPosition: "outside",
            tickWidth: 1,
            title: {
                align: "middle",
                style: {
                    color: "#4d759e",
                    fontWeight: "bold"
                }
            },
            type: "linear"
        },
        defaultYAxisOptions: {
            endOnTick: true,
            gridLineWidth: 1,
            tickPixelInterval: 72,
            showLastLabel: true,
            labels: {
                x: -8,
                y: 3
            },
            lineWidth: 0,
            maxPadding: .05,
            minPadding: .05,
            startOnTick: true,
            tickWidth: 0,
            title: {
                rotation: 270,
                text: "Values"
            },
            stackLabels: {
                enabled: false,
                formatter: function() {
                    return numberFormat(this.total, -1);
                },
                style: defaultLabelOptions.style
            }
        },
        defaultLeftAxisOptions: {
            labels: {
                x: -8,
                y: null
            },
            title: {
                rotation: 270
            }
        },
        defaultRightAxisOptions: {
            labels: {
                x: 8,
                y: null
            },
            title: {
                rotation: 90
            }
        },
        defaultBottomAxisOptions: {
            labels: {
                x: 0,
                y: 14
            },
            title: {
                rotation: 0
            }
        },
        defaultTopAxisOptions: {
            labels: {
                x: 0,
                y: -5
            },
            title: {
                rotation: 0
            }
        },
        init: function(chart, userOptions) {
            var isXAxis = userOptions.isX, axis = this;
            axis.horiz = chart.inverted ? !isXAxis : isXAxis;
            axis.isXAxis = isXAxis;
            axis.xOrY = isXAxis ? "x" : "y";
            axis.opposite = userOptions.opposite;
            axis.side = axis.horiz ? axis.opposite ? 0 : 2 : axis.opposite ? 1 : 3;
            axis.setOptions(userOptions);
            var options = this.options, type = options.type, isDatetimeAxis = type === "datetime";
            axis.labelFormatter = options.labels.formatter || axis.defaultLabelFormatter;
            axis.userOptions = userOptions;
            axis.minPixelPadding = 0;
            axis.chart = chart;
            axis.reversed = options.reversed;
            axis.zoomEnabled = options.zoomEnabled !== false;
            axis.categories = options.categories || type === "category";
            axis.isLog = type === "logarithmic";
            axis.isDatetimeAxis = isDatetimeAxis;
            axis.isLinked = defined(options.linkedTo);
            axis.tickmarkOffset = axis.categories && options.tickmarkPlacement === "between" ? .5 : 0;
            axis.ticks = {};
            axis.minorTicks = {};
            axis.plotLinesAndBands = [];
            axis.alternateBands = {};
            axis.len = 0;
            axis.minRange = axis.userMinRange = options.minRange || options.maxZoom;
            axis.range = options.range;
            axis.offset = options.offset || 0;
            axis.stacks = {};
            axis.oldStacks = {};
            axis.stackExtremes = {};
            axis.max = null;
            axis.min = null;
            var eventType, events = axis.options.events;
            if (inArray(axis, chart.axes) === -1) {
                chart.axes.push(axis);
                chart[isXAxis ? "xAxis" : "yAxis"].push(axis);
            }
            axis.series = axis.series || [];
            if (chart.inverted && isXAxis && axis.reversed === UNDEFINED) {
                axis.reversed = true;
            }
            axis.removePlotBand = axis.removePlotBandOrLine;
            axis.removePlotLine = axis.removePlotBandOrLine;
            for (eventType in events) {
                addEvent(axis, eventType, events[eventType]);
            }
            if (axis.isLog) {
                axis.val2lin = log2lin;
                axis.lin2val = lin2log;
            }
        },
        setOptions: function(userOptions) {
            this.options = merge(this.defaultOptions, this.isXAxis ? {} : this.defaultYAxisOptions, [ this.defaultTopAxisOptions, this.defaultRightAxisOptions, this.defaultBottomAxisOptions, this.defaultLeftAxisOptions ][this.side], merge(defaultOptions[this.isXAxis ? "xAxis" : "yAxis"], userOptions));
        },
        update: function(newOptions, redraw) {
            var chart = this.chart;
            newOptions = chart.options[this.xOrY + "Axis"][this.options.index] = merge(this.userOptions, newOptions);
            this.destroy(true);
            this._addedPlotLB = false;
            this.init(chart, extend(newOptions, {
                events: UNDEFINED
            }));
            chart.isDirtyBox = true;
            if (pick(redraw, true)) {
                chart.redraw();
            }
        },
        remove: function(redraw) {
            var chart = this.chart, key = this.xOrY + "Axis";
            each(this.series, function(series) {
                series.remove(false);
            });
            erase(chart.axes, this);
            erase(chart[key], this);
            chart.options[key].splice(this.options.index, 1);
            each(chart[key], function(axis, i) {
                axis.options.index = i;
            });
            this.destroy();
            chart.isDirtyBox = true;
            if (pick(redraw, true)) {
                chart.redraw();
            }
        },
        defaultLabelFormatter: function() {
            var axis = this.axis, value = this.value, categories = axis.categories, dateTimeLabelFormat = this.dateTimeLabelFormat, numericSymbols = defaultOptions.lang.numericSymbols, i = numericSymbols && numericSymbols.length, multi, ret, formatOption = axis.options.labels.format, numericSymbolDetector = axis.isLog ? value : axis.tickInterval;
            if (formatOption) {
                ret = format(formatOption, this);
            } else if (categories) {
                ret = value;
            } else if (dateTimeLabelFormat) {
                ret = dateFormat(dateTimeLabelFormat, value);
            } else if (i && numericSymbolDetector >= 1e3) {
                while (i-- && ret === UNDEFINED) {
                    multi = Math.pow(1e3, i + 1);
                    if (numericSymbolDetector >= multi && numericSymbols[i] !== null) {
                        ret = numberFormat(value / multi, -1) + numericSymbols[i];
                    }
                }
            }
            if (ret === UNDEFINED) {
                if (value >= 1e3) {
                    ret = numberFormat(value, 0);
                } else {
                    ret = numberFormat(value, -1);
                }
            }
            return ret;
        },
        getSeriesExtremes: function() {
            var axis = this, chart = axis.chart;
            axis.hasVisibleSeries = false;
            axis.dataMin = axis.dataMax = null;
            axis.stackExtremes = {};
            axis.buildStacks();
            each(axis.series, function(series) {
                if (series.visible || !chart.options.chart.ignoreHiddenSeries) {
                    var seriesOptions = series.options, stacking, xData, threshold = seriesOptions.threshold, seriesDataMin, seriesDataMax;
                    axis.hasVisibleSeries = true;
                    if (axis.isLog && threshold <= 0) {
                        threshold = null;
                    }
                    if (axis.isXAxis) {
                        xData = series.xData;
                        if (xData.length) {
                            axis.dataMin = mathMin(pick(axis.dataMin, xData[0]), arrayMin(xData));
                            axis.dataMax = mathMax(pick(axis.dataMax, xData[0]), arrayMax(xData));
                        }
                    } else {
                        stacking = seriesOptions.stacking;
                        axis.usePercentage = stacking === "percent";
                        if (axis.usePercentage) {
                            axis.dataMin = 0;
                            axis.dataMax = 99;
                        }
                        series.getExtremes();
                        seriesDataMax = series.dataMax;
                        seriesDataMin = series.dataMin;
                        if (!axis.usePercentage && defined(seriesDataMin) && defined(seriesDataMax)) {
                            axis.dataMin = mathMin(pick(axis.dataMin, seriesDataMin), seriesDataMin);
                            axis.dataMax = mathMax(pick(axis.dataMax, seriesDataMax), seriesDataMax);
                        }
                        if (defined(threshold)) {
                            if (axis.dataMin >= threshold) {
                                axis.dataMin = threshold;
                                axis.ignoreMinPadding = true;
                            } else if (axis.dataMax < threshold) {
                                axis.dataMax = threshold;
                                axis.ignoreMaxPadding = true;
                            }
                        }
                    }
                }
            });
        },
        translate: function(val, backwards, cvsCoord, old, handleLog, pointPlacement) {
            var axis = this, axisLength = axis.len, sign = 1, cvsOffset = 0, localA = old ? axis.oldTransA : axis.transA, localMin = old ? axis.oldMin : axis.min, returnValue, minPixelPadding = axis.minPixelPadding, postTranslate = (axis.options.ordinal || axis.isLog && handleLog) && axis.lin2val;
            if (!localA) {
                localA = axis.transA;
            }
            if (cvsCoord) {
                sign *= -1;
                cvsOffset = axisLength;
            }
            if (axis.reversed) {
                sign *= -1;
                cvsOffset -= sign * axisLength;
            }
            if (backwards) {
                val = val * sign + cvsOffset;
                val -= minPixelPadding;
                returnValue = val / localA + localMin;
                if (postTranslate) {
                    returnValue = axis.lin2val(returnValue);
                }
            } else {
                if (postTranslate) {
                    val = axis.val2lin(val);
                }
                if (pointPlacement === "between") {
                    pointPlacement = .5;
                }
                returnValue = sign * (val - localMin) * localA + cvsOffset + sign * minPixelPadding + (isNumber(pointPlacement) ? localA * pointPlacement * axis.pointRange : 0);
            }
            return returnValue;
        },
        toPixels: function(value, paneCoordinates) {
            return this.translate(value, false, !this.horiz, null, true) + (paneCoordinates ? 0 : this.pos);
        },
        toValue: function(pixel, paneCoordinates) {
            return this.translate(pixel - (paneCoordinates ? 0 : this.pos), true, !this.horiz, null, true);
        },
        getPlotLinePath: function(value, lineWidth, old, force) {
            var axis = this, chart = axis.chart, axisLeft = axis.left, axisTop = axis.top, x1, y1, x2, y2, translatedValue = axis.translate(value, null, null, old), cHeight = old && chart.oldChartHeight || chart.chartHeight, cWidth = old && chart.oldChartWidth || chart.chartWidth, skip, transB = axis.transB;
            x1 = x2 = mathRound(translatedValue + transB);
            y1 = y2 = mathRound(cHeight - translatedValue - transB);
            if (isNaN(translatedValue)) {
                skip = true;
            } else if (axis.horiz) {
                y1 = axisTop;
                y2 = cHeight - axis.bottom;
                if (x1 < axisLeft || x1 > axisLeft + axis.width) {
                    skip = true;
                }
            } else {
                x1 = axisLeft;
                x2 = cWidth - axis.right;
                if (y1 < axisTop || y1 > axisTop + axis.height) {
                    skip = true;
                }
            }
            return skip && !force ? null : chart.renderer.crispLine([ M, x1, y1, L, x2, y2 ], lineWidth || 0);
        },
        getPlotBandPath: function(from, to) {
            var toPath = this.getPlotLinePath(to), path = this.getPlotLinePath(from);
            if (path && toPath) {
                path.push(toPath[4], toPath[5], toPath[1], toPath[2]);
            } else {
                path = null;
            }
            return path;
        },
        getLinearTickPositions: function(tickInterval, min, max) {
            var pos, lastPos, roundedMin = correctFloat(mathFloor(min / tickInterval) * tickInterval), roundedMax = correctFloat(mathCeil(max / tickInterval) * tickInterval), tickPositions = [];
            pos = roundedMin;
            while (pos <= roundedMax) {
                tickPositions.push(pos);
                pos = correctFloat(pos + tickInterval);
                if (pos === lastPos) {
                    break;
                }
                lastPos = pos;
            }
            return tickPositions;
        },
        getLogTickPositions: function(interval, min, max, minor) {
            var axis = this, options = axis.options, axisLength = axis.len, positions = [];
            if (!minor) {
                axis._minorAutoInterval = null;
            }
            if (interval >= .5) {
                interval = mathRound(interval);
                positions = axis.getLinearTickPositions(interval, min, max);
            } else if (interval >= .08) {
                var roundedMin = mathFloor(min), intermediate, i, j, len, pos, lastPos, break2;
                if (interval > .3) {
                    intermediate = [ 1, 2, 4 ];
                } else if (interval > .15) {
                    intermediate = [ 1, 2, 4, 6, 8 ];
                } else {
                    intermediate = [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ];
                }
                for (i = roundedMin; i < max + 1 && !break2; i++) {
                    len = intermediate.length;
                    for (j = 0; j < len && !break2; j++) {
                        pos = log2lin(lin2log(i) * intermediate[j]);
                        if (pos > min && (!minor || lastPos <= max)) {
                            positions.push(lastPos);
                        }
                        if (lastPos > max) {
                            break2 = true;
                        }
                        lastPos = pos;
                    }
                }
            } else {
                var realMin = lin2log(min), realMax = lin2log(max), tickIntervalOption = options[minor ? "minorTickInterval" : "tickInterval"], filteredTickIntervalOption = tickIntervalOption === "auto" ? null : tickIntervalOption, tickPixelIntervalOption = options.tickPixelInterval / (minor ? 5 : 1), totalPixelLength = minor ? axisLength / axis.tickPositions.length : axisLength;
                interval = pick(filteredTickIntervalOption, axis._minorAutoInterval, (realMax - realMin) * tickPixelIntervalOption / (totalPixelLength || 1));
                interval = normalizeTickInterval(interval, null, getMagnitude(interval));
                positions = map(axis.getLinearTickPositions(interval, realMin, realMax), log2lin);
                if (!minor) {
                    axis._minorAutoInterval = interval / 5;
                }
            }
            if (!minor) {
                axis.tickInterval = interval;
            }
            return positions;
        },
        getMinorTickPositions: function() {
            var axis = this, options = axis.options, tickPositions = axis.tickPositions, minorTickInterval = axis.minorTickInterval, minorTickPositions = [], pos, i, len;
            if (axis.isLog) {
                len = tickPositions.length;
                for (i = 1; i < len; i++) {
                    minorTickPositions = minorTickPositions.concat(axis.getLogTickPositions(minorTickInterval, tickPositions[i - 1], tickPositions[i], true));
                }
            } else if (axis.isDatetimeAxis && options.minorTickInterval === "auto") {
                minorTickPositions = minorTickPositions.concat(getTimeTicks(normalizeTimeTickInterval(minorTickInterval), axis.min, axis.max, options.startOfWeek));
                if (minorTickPositions[0] < axis.min) {
                    minorTickPositions.shift();
                }
            } else {
                for (pos = axis.min + (tickPositions[0] - axis.min) % minorTickInterval; pos <= axis.max; pos += minorTickInterval) {
                    minorTickPositions.push(pos);
                }
            }
            return minorTickPositions;
        },
        adjustForMinRange: function() {
            var axis = this, options = axis.options, min = axis.min, max = axis.max, zoomOffset, spaceAvailable = axis.dataMax - axis.dataMin >= axis.minRange, closestDataRange, i, distance, xData, loopLength, minArgs, maxArgs;
            if (axis.isXAxis && axis.minRange === UNDEFINED && !axis.isLog) {
                if (defined(options.min) || defined(options.max)) {
                    axis.minRange = null;
                } else {
                    each(axis.series, function(series) {
                        xData = series.xData;
                        loopLength = series.xIncrement ? 1 : xData.length - 1;
                        for (i = loopLength; i > 0; i--) {
                            distance = xData[i] - xData[i - 1];
                            if (closestDataRange === UNDEFINED || distance < closestDataRange) {
                                closestDataRange = distance;
                            }
                        }
                    });
                    axis.minRange = mathMin(closestDataRange * 5, axis.dataMax - axis.dataMin);
                }
            }
            if (max - min < axis.minRange) {
                var minRange = axis.minRange;
                zoomOffset = (minRange - max + min) / 2;
                minArgs = [ min - zoomOffset, pick(options.min, min - zoomOffset) ];
                if (spaceAvailable) {
                    minArgs[2] = axis.dataMin;
                }
                min = arrayMax(minArgs);
                maxArgs = [ min + minRange, pick(options.max, min + minRange) ];
                if (spaceAvailable) {
                    maxArgs[2] = axis.dataMax;
                }
                max = arrayMin(maxArgs);
                if (max - min < minRange) {
                    minArgs[0] = max - minRange;
                    minArgs[1] = pick(options.min, max - minRange);
                    min = arrayMax(minArgs);
                }
            }
            axis.min = min;
            axis.max = max;
        },
        setAxisTranslation: function(saveOld) {
            var axis = this, range = axis.max - axis.min, pointRange = 0, closestPointRange, minPointOffset = 0, pointRangePadding = 0, linkedParent = axis.linkedParent, ordinalCorrection, transA = axis.transA;
            if (axis.isXAxis) {
                if (linkedParent) {
                    minPointOffset = linkedParent.minPointOffset;
                    pointRangePadding = linkedParent.pointRangePadding;
                } else {
                    each(axis.series, function(series) {
                        var seriesPointRange = series.pointRange, pointPlacement = series.options.pointPlacement, seriesClosestPointRange = series.closestPointRange;
                        if (seriesPointRange > range) {
                            seriesPointRange = 0;
                        }
                        pointRange = mathMax(pointRange, seriesPointRange);
                        minPointOffset = mathMax(minPointOffset, isString(pointPlacement) ? 0 : seriesPointRange / 2);
                        pointRangePadding = mathMax(pointRangePadding, pointPlacement === "on" ? 0 : seriesPointRange);
                        if (!series.noSharedTooltip && defined(seriesClosestPointRange)) {
                            closestPointRange = defined(closestPointRange) ? mathMin(closestPointRange, seriesClosestPointRange) : seriesClosestPointRange;
                        }
                    });
                }
                ordinalCorrection = axis.ordinalSlope && closestPointRange ? axis.ordinalSlope / closestPointRange : 1;
                axis.minPointOffset = minPointOffset = minPointOffset * ordinalCorrection;
                axis.pointRangePadding = pointRangePadding = pointRangePadding * ordinalCorrection;
                axis.pointRange = mathMin(pointRange, range);
                axis.closestPointRange = closestPointRange;
            }
            if (saveOld) {
                axis.oldTransA = transA;
            }
            axis.translationSlope = axis.transA = transA = axis.len / (range + pointRangePadding || 1);
            axis.transB = axis.horiz ? axis.left : axis.bottom;
            axis.minPixelPadding = transA * minPointOffset;
        },
        setTickPositions: function(secondPass) {
            var axis = this, chart = axis.chart, options = axis.options, isLog = axis.isLog, isDatetimeAxis = axis.isDatetimeAxis, isXAxis = axis.isXAxis, isLinked = axis.isLinked, tickPositioner = axis.options.tickPositioner, maxPadding = options.maxPadding, minPadding = options.minPadding, length, linkedParentExtremes, tickIntervalOption = options.tickInterval, minTickIntervalOption = options.minTickInterval, tickPixelIntervalOption = options.tickPixelInterval, tickPositions, categories = axis.categories;
            if (isLinked) {
                axis.linkedParent = chart[isXAxis ? "xAxis" : "yAxis"][options.linkedTo];
                linkedParentExtremes = axis.linkedParent.getExtremes();
                axis.min = pick(linkedParentExtremes.min, linkedParentExtremes.dataMin);
                axis.max = pick(linkedParentExtremes.max, linkedParentExtremes.dataMax);
                if (options.type !== axis.linkedParent.options.type) {
                    error(11, 1);
                }
            } else {
                axis.min = pick(axis.userMin, options.min, axis.dataMin);
                axis.max = pick(axis.userMax, options.max, axis.dataMax);
            }
            if (isLog) {
                if (!secondPass && mathMin(axis.min, pick(axis.dataMin, axis.min)) <= 0) {
                    error(10, 1);
                }
                axis.min = correctFloat(log2lin(axis.min));
                axis.max = correctFloat(log2lin(axis.max));
            }
            if (axis.range) {
                axis.userMin = axis.min = mathMax(axis.min, axis.max - axis.range);
                axis.userMax = axis.max;
                if (secondPass) {
                    axis.range = null;
                }
            }
            if (axis.beforePadding) {
                axis.beforePadding();
            }
            axis.adjustForMinRange();
            if (!categories && !axis.usePercentage && !isLinked && defined(axis.min) && defined(axis.max)) {
                length = axis.max - axis.min;
                if (length) {
                    if (!defined(options.min) && !defined(axis.userMin) && minPadding && (axis.dataMin < 0 || !axis.ignoreMinPadding)) {
                        axis.min -= length * minPadding;
                    }
                    if (!defined(options.max) && !defined(axis.userMax) && maxPadding && (axis.dataMax > 0 || !axis.ignoreMaxPadding)) {
                        axis.max += length * maxPadding;
                    }
                }
            }
            if (axis.min === axis.max || axis.min === undefined || axis.max === undefined) {
                axis.tickInterval = 1;
            } else if (isLinked && !tickIntervalOption && tickPixelIntervalOption === axis.linkedParent.options.tickPixelInterval) {
                axis.tickInterval = axis.linkedParent.tickInterval;
            } else {
                axis.tickInterval = pick(tickIntervalOption, categories ? 1 : (axis.max - axis.min) * tickPixelIntervalOption / (axis.len || 1));
            }
            if (isXAxis && !secondPass) {
                each(axis.series, function(series) {
                    series.processData(axis.min !== axis.oldMin || axis.max !== axis.oldMax);
                });
            }
            axis.setAxisTranslation(true);
            if (axis.beforeSetTickPositions) {
                axis.beforeSetTickPositions();
            }
            if (axis.postProcessTickInterval) {
                axis.tickInterval = axis.postProcessTickInterval(axis.tickInterval);
            }
            if (axis.pointRange) {
                axis.tickInterval = mathMax(axis.pointRange, axis.tickInterval);
            }
            if (!tickIntervalOption && axis.tickInterval < minTickIntervalOption) {
                axis.tickInterval = minTickIntervalOption;
            }
            if (!isDatetimeAxis && !isLog) {
                if (!tickIntervalOption) {
                    axis.tickInterval = normalizeTickInterval(axis.tickInterval, null, getMagnitude(axis.tickInterval), options);
                }
            }
            axis.minorTickInterval = options.minorTickInterval === "auto" && axis.tickInterval ? axis.tickInterval / 5 : options.minorTickInterval;
            axis.tickPositions = tickPositions = options.tickPositions ? [].concat(options.tickPositions) : tickPositioner && tickPositioner.apply(axis, [ axis.min, axis.max ]);
            if (!tickPositions) {
                if ((axis.max - axis.min) / axis.tickInterval > 2 * axis.len) {
                    error(19, true);
                }
                if (isDatetimeAxis) {
                    tickPositions = (axis.getNonLinearTimeTicks || getTimeTicks)(normalizeTimeTickInterval(axis.tickInterval, options.units), axis.min, axis.max, options.startOfWeek, axis.ordinalPositions, axis.closestPointRange, true);
                } else if (isLog) {
                    tickPositions = axis.getLogTickPositions(axis.tickInterval, axis.min, axis.max);
                } else {
                    tickPositions = axis.getLinearTickPositions(axis.tickInterval, axis.min, axis.max);
                }
                axis.tickPositions = tickPositions;
            }
            if (!isLinked) {
                var roundedMin = tickPositions[0], roundedMax = tickPositions[tickPositions.length - 1], minPointOffset = axis.minPointOffset || 0, singlePad;
                if (options.startOnTick) {
                    axis.min = roundedMin;
                } else if (axis.min - minPointOffset > roundedMin) {
                    tickPositions.shift();
                }
                if (options.endOnTick) {
                    axis.max = roundedMax;
                } else if (axis.max + minPointOffset < roundedMax) {
                    tickPositions.pop();
                }
                if (tickPositions.length === 1) {
                    singlePad = .001;
                    axis.min -= singlePad;
                    axis.max += singlePad;
                }
            }
        },
        setMaxTicks: function() {
            var chart = this.chart, maxTicks = chart.maxTicks || {}, tickPositions = this.tickPositions, key = this._maxTicksKey = [ this.xOrY, this.pos, this.len ].join("-");
            if (!this.isLinked && !this.isDatetimeAxis && tickPositions && tickPositions.length > (maxTicks[key] || 0) && this.options.alignTicks !== false) {
                maxTicks[key] = tickPositions.length;
            }
            chart.maxTicks = maxTicks;
        },
        adjustTickAmount: function() {
            var axis = this, chart = axis.chart, key = axis._maxTicksKey, tickPositions = axis.tickPositions, maxTicks = chart.maxTicks;
            if (maxTicks && maxTicks[key] && !axis.isDatetimeAxis && !axis.categories && !axis.isLinked && axis.options.alignTicks !== false) {
                var oldTickAmount = axis.tickAmount, calculatedTickAmount = tickPositions.length, tickAmount;
                axis.tickAmount = tickAmount = maxTicks[key];
                if (calculatedTickAmount < tickAmount) {
                    while (tickPositions.length < tickAmount) {
                        tickPositions.push(correctFloat(tickPositions[tickPositions.length - 1] + axis.tickInterval));
                    }
                    axis.transA *= (calculatedTickAmount - 1) / (tickAmount - 1);
                    axis.max = tickPositions[tickPositions.length - 1];
                }
                if (defined(oldTickAmount) && tickAmount !== oldTickAmount) {
                    axis.isDirty = true;
                }
            }
        },
        setScale: function() {
            var axis = this, stacks = axis.stacks, type, i, isDirtyData, isDirtyAxisLength;
            axis.oldMin = axis.min;
            axis.oldMax = axis.max;
            axis.oldAxisLength = axis.len;
            axis.setAxisSize();
            isDirtyAxisLength = axis.len !== axis.oldAxisLength;
            each(axis.series, function(series) {
                if (series.isDirtyData || series.isDirty || series.xAxis.isDirty) {
                    isDirtyData = true;
                }
            });
            if (isDirtyAxisLength || isDirtyData || axis.isLinked || axis.forceRedraw || axis.userMin !== axis.oldUserMin || axis.userMax !== axis.oldUserMax) {
                if (!axis.isXAxis) {
                    for (type in stacks) {
                        for (i in stacks[type]) {
                            stacks[type][i].total = null;
                        }
                    }
                }
                axis.forceRedraw = false;
                axis.getSeriesExtremes();
                axis.setTickPositions();
                axis.oldUserMin = axis.userMin;
                axis.oldUserMax = axis.userMax;
                if (!axis.isDirty) {
                    axis.isDirty = isDirtyAxisLength || axis.min !== axis.oldMin || axis.max !== axis.oldMax;
                }
            } else if (!axis.isXAxis) {
                if (axis.oldStacks) {
                    stacks = axis.stacks = axis.oldStacks;
                }
                for (type in stacks) {
                    for (i in stacks[type]) {
                        stacks[type][i].cum = stacks[type][i].total;
                    }
                }
            }
            axis.setMaxTicks();
        },
        setExtremes: function(newMin, newMax, redraw, animation, eventArguments) {
            var axis = this, chart = axis.chart;
            redraw = pick(redraw, true);
            eventArguments = extend(eventArguments, {
                min: newMin,
                max: newMax
            });
            fireEvent(axis, "setExtremes", eventArguments, function() {
                axis.userMin = newMin;
                axis.userMax = newMax;
                axis.isDirtyExtremes = true;
                if (redraw) {
                    chart.redraw(animation);
                }
            });
        },
        zoom: function(newMin, newMax) {
            if (!this.allowZoomOutside) {
                if (defined(this.dataMin) && newMin <= this.dataMin) {
                    newMin = UNDEFINED;
                }
                if (defined(this.dataMax) && newMax >= this.dataMax) {
                    newMax = UNDEFINED;
                }
            }
            this.displayBtn = newMin !== UNDEFINED || newMax !== UNDEFINED;
            this.setExtremes(newMin, newMax, false, UNDEFINED, {
                trigger: "zoom"
            });
            return true;
        },
        setAxisSize: function() {
            var chart = this.chart, options = this.options, offsetLeft = options.offsetLeft || 0, offsetRight = options.offsetRight || 0, horiz = this.horiz, width, height, top, left;
            this.left = left = pick(options.left, chart.plotLeft + offsetLeft);
            this.top = top = pick(options.top, chart.plotTop);
            this.width = width = pick(options.width, chart.plotWidth - offsetLeft + offsetRight);
            this.height = height = pick(options.height, chart.plotHeight);
            this.bottom = chart.chartHeight - height - top;
            this.right = chart.chartWidth - width - left;
            this.len = mathMax(horiz ? width : height, 0);
            this.pos = horiz ? left : top;
        },
        getExtremes: function() {
            var axis = this, isLog = axis.isLog;
            return {
                min: isLog ? correctFloat(lin2log(axis.min)) : axis.min,
                max: isLog ? correctFloat(lin2log(axis.max)) : axis.max,
                dataMin: axis.dataMin,
                dataMax: axis.dataMax,
                userMin: axis.userMin,
                userMax: axis.userMax
            };
        },
        getThreshold: function(threshold) {
            var axis = this, isLog = axis.isLog;
            var realMin = isLog ? lin2log(axis.min) : axis.min, realMax = isLog ? lin2log(axis.max) : axis.max;
            if (realMin > threshold || threshold === null) {
                threshold = realMin;
            } else if (realMax < threshold) {
                threshold = realMax;
            }
            return axis.translate(threshold, 0, 1, 0, 1);
        },
        addPlotBand: function(options) {
            this.addPlotBandOrLine(options, "plotBands");
        },
        addPlotLine: function(options) {
            this.addPlotBandOrLine(options, "plotLines");
        },
        addPlotBandOrLine: function(options, coll) {
            var obj = new PlotLineOrBand(this, options).render(), userOptions = this.userOptions;
            if (coll) {
                userOptions[coll] = userOptions[coll] || [];
                userOptions[coll].push(options);
            }
            this.plotLinesAndBands.push(obj);
            return obj;
        },
        autoLabelAlign: function(rotation) {
            var ret, angle = (pick(rotation, 0) - this.side * 90 + 720) % 360;
            if (angle > 15 && angle < 165) {
                ret = "right";
            } else if (angle > 195 && angle < 345) {
                ret = "left";
            } else {
                ret = "center";
            }
            return ret;
        },
        getOffset: function() {
            var axis = this, chart = axis.chart, renderer = chart.renderer, options = axis.options, tickPositions = axis.tickPositions, ticks = axis.ticks, horiz = axis.horiz, side = axis.side, invertedSide = chart.inverted ? [ 1, 0, 3, 2 ][side] : side, hasData, showAxis, titleOffset = 0, titleOffsetOption, titleMargin = 0, axisTitleOptions = options.title, labelOptions = options.labels, labelOffset = 0, axisOffset = chart.axisOffset, clipOffset = chart.clipOffset, directionFactor = [ -1, 1, 1, -1 ][side], n, i, autoStaggerLines = 1, maxStaggerLines = pick(labelOptions.maxStaggerLines, 5), sortedPositions, lastRight, overlap, pos, bBox, x, w, lineNo;
            axis.hasData = hasData = axis.hasVisibleSeries || defined(axis.min) && defined(axis.max) && !!tickPositions;
            axis.showAxis = showAxis = hasData || pick(options.showEmpty, true);
            axis.staggerLines = axis.horiz && labelOptions.staggerLines;
            if (!axis.axisGroup) {
                axis.gridGroup = renderer.g("grid").attr({
                    zIndex: options.gridZIndex || 1
                }).add();
                axis.axisGroup = renderer.g("axis").attr({
                    zIndex: options.zIndex || 2
                }).add();
                axis.labelGroup = renderer.g("axis-labels").attr({
                    zIndex: labelOptions.zIndex || 7
                }).add();
            }
            if (hasData || axis.isLinked) {
                axis.labelAlign = pick(labelOptions.align || axis.autoLabelAlign(labelOptions.rotation));
                each(tickPositions, function(pos) {
                    if (!ticks[pos]) {
                        ticks[pos] = new Tick(axis, pos);
                    } else {
                        ticks[pos].addLabel();
                    }
                });
                if (axis.horiz && !axis.staggerLines && maxStaggerLines && !labelOptions.rotation) {
                    sortedPositions = axis.reversed ? [].concat(tickPositions).reverse() : tickPositions;
                    while (autoStaggerLines < maxStaggerLines) {
                        lastRight = [];
                        overlap = false;
                        for (i = 0; i < sortedPositions.length; i++) {
                            pos = sortedPositions[i];
                            bBox = ticks[pos].label && ticks[pos].label.bBox;
                            w = bBox ? bBox.width : 0;
                            lineNo = i % autoStaggerLines;
                            if (w) {
                                x = axis.translate(pos);
                                if (lastRight[lineNo] !== UNDEFINED && x < lastRight[lineNo]) {
                                    overlap = true;
                                }
                                lastRight[lineNo] = x + w;
                            }
                        }
                        if (overlap) {
                            autoStaggerLines++;
                        } else {
                            break;
                        }
                    }
                    if (autoStaggerLines > 1) {
                        axis.staggerLines = autoStaggerLines;
                    }
                }
                each(tickPositions, function(pos) {
                    if (side === 0 || side === 2 || {
                        1: "left",
                        3: "right"
                    }[side] === axis.labelAlign) {
                        labelOffset = mathMax(ticks[pos].getLabelSize(), labelOffset);
                    }
                });
                if (axis.staggerLines) {
                    labelOffset *= axis.staggerLines;
                    axis.labelOffset = labelOffset;
                }
            } else {
                for (n in ticks) {
                    ticks[n].destroy();
                    delete ticks[n];
                }
            }
            if (axisTitleOptions && axisTitleOptions.text && axisTitleOptions.enabled !== false) {
                if (!axis.axisTitle) {
                    axis.axisTitle = renderer.text(axisTitleOptions.text, 0, 0, axisTitleOptions.useHTML).attr({
                        zIndex: 7,
                        rotation: axisTitleOptions.rotation || 0,
                        align: axisTitleOptions.textAlign || {
                            low: "left",
                            middle: "center",
                            high: "right"
                        }[axisTitleOptions.align]
                    }).css(axisTitleOptions.style).add(axis.axisGroup);
                    axis.axisTitle.isNew = true;
                }
                if (showAxis) {
                    titleOffset = axis.axisTitle.getBBox()[horiz ? "height" : "width"];
                    titleMargin = pick(axisTitleOptions.margin, horiz ? 5 : 10);
                    titleOffsetOption = axisTitleOptions.offset;
                }
                axis.axisTitle[showAxis ? "show" : "hide"]();
            }
            axis.offset = directionFactor * pick(options.offset, axisOffset[side]);
            axis.axisTitleMargin = pick(titleOffsetOption, labelOffset + titleMargin + (side !== 2 && labelOffset && directionFactor * options.labels[horiz ? "y" : "x"]));
            axisOffset[side] = mathMax(axisOffset[side], axis.axisTitleMargin + titleOffset + directionFactor * axis.offset);
            clipOffset[invertedSide] = mathMax(clipOffset[invertedSide], mathFloor(options.lineWidth / 2) * 2);
        },
        getLinePath: function(lineWidth) {
            var chart = this.chart, opposite = this.opposite, offset = this.offset, horiz = this.horiz, lineLeft = this.left + (opposite ? this.width : 0) + offset, lineTop = chart.chartHeight - this.bottom - (opposite ? this.height : 0) + offset;
            this.lineTop = lineTop;
            if (opposite) {
                lineWidth *= -1;
            }
            return chart.renderer.crispLine([ M, horiz ? this.left : lineLeft, horiz ? lineTop : this.top, L, horiz ? chart.chartWidth - this.right : lineLeft, horiz ? lineTop : chart.chartHeight - this.bottom ], lineWidth);
        },
        getTitlePosition: function() {
            var horiz = this.horiz, axisLeft = this.left, axisTop = this.top, axisLength = this.len, axisTitleOptions = this.options.title, margin = horiz ? axisLeft : axisTop, opposite = this.opposite, offset = this.offset, fontSize = pInt(axisTitleOptions.style.fontSize || 12), alongAxis = {
                low: margin + (horiz ? 0 : axisLength),
                middle: margin + axisLength / 2,
                high: margin + (horiz ? axisLength : 0)
            }[axisTitleOptions.align], offAxis = (horiz ? axisTop + this.height : axisLeft) + (horiz ? 1 : -1) * (opposite ? -1 : 1) * this.axisTitleMargin + (this.side === 2 ? fontSize : 0);
            return {
                x: horiz ? alongAxis : offAxis + (opposite ? this.width : 0) + offset + (axisTitleOptions.x || 0),
                y: horiz ? offAxis - (opposite ? this.height : 0) + offset : alongAxis + (axisTitleOptions.y || 0)
            };
        },
        render: function() {
            var axis = this, chart = axis.chart, renderer = chart.renderer, options = axis.options, isLog = axis.isLog, isLinked = axis.isLinked, tickPositions = axis.tickPositions, axisTitle = axis.axisTitle, stacks = axis.stacks, ticks = axis.ticks, minorTicks = axis.minorTicks, alternateBands = axis.alternateBands, stackLabelOptions = options.stackLabels, alternateGridColor = options.alternateGridColor, tickmarkOffset = axis.tickmarkOffset, lineWidth = options.lineWidth, linePath, hasRendered = chart.hasRendered, slideInTicks = hasRendered && defined(axis.oldMin) && !isNaN(axis.oldMin), hasData = axis.hasData, showAxis = axis.showAxis, from, to;
            each([ ticks, minorTicks, alternateBands ], function(coll) {
                var pos;
                for (pos in coll) {
                    coll[pos].isActive = false;
                }
            });
            if (hasData || isLinked) {
                if (axis.minorTickInterval && !axis.categories) {
                    each(axis.getMinorTickPositions(), function(pos) {
                        if (!minorTicks[pos]) {
                            minorTicks[pos] = new Tick(axis, pos, "minor");
                        }
                        if (slideInTicks && minorTicks[pos].isNew) {
                            minorTicks[pos].render(null, true);
                        }
                        minorTicks[pos].render(null, false, 1);
                    });
                }
                if (tickPositions.length) {
                    each(tickPositions.slice(1).concat([ tickPositions[0] ]), function(pos, i) {
                        i = i === tickPositions.length - 1 ? 0 : i + 1;
                        if (!isLinked || pos >= axis.min && pos <= axis.max) {
                            if (!ticks[pos]) {
                                ticks[pos] = new Tick(axis, pos);
                            }
                            if (slideInTicks && ticks[pos].isNew) {
                                ticks[pos].render(i, true);
                            }
                            ticks[pos].render(i, false, 1);
                        }
                    });
                    if (tickmarkOffset && axis.min === 0) {
                        if (!ticks[-1]) {
                            ticks[-1] = new Tick(axis, -1, null, true);
                        }
                        ticks[-1].render(-1);
                    }
                }
                if (alternateGridColor) {
                    each(tickPositions, function(pos, i) {
                        if (i % 2 === 0 && pos < axis.max) {
                            if (!alternateBands[pos]) {
                                alternateBands[pos] = new PlotLineOrBand(axis);
                            }
                            from = pos + tickmarkOffset;
                            to = tickPositions[i + 1] !== UNDEFINED ? tickPositions[i + 1] + tickmarkOffset : axis.max;
                            alternateBands[pos].options = {
                                from: isLog ? lin2log(from) : from,
                                to: isLog ? lin2log(to) : to,
                                color: alternateGridColor
                            };
                            alternateBands[pos].render();
                            alternateBands[pos].isActive = true;
                        }
                    });
                }
                if (!axis._addedPlotLB) {
                    each((options.plotLines || []).concat(options.plotBands || []), function(plotLineOptions) {
                        axis.addPlotBandOrLine(plotLineOptions);
                    });
                    axis._addedPlotLB = true;
                }
            }
            each([ ticks, minorTicks, alternateBands ], function(coll) {
                var pos, i, forDestruction = [], delay = globalAnimation ? globalAnimation.duration || 500 : 0, destroyInactiveItems = function() {
                    i = forDestruction.length;
                    while (i--) {
                        if (coll[forDestruction[i]] && !coll[forDestruction[i]].isActive) {
                            coll[forDestruction[i]].destroy();
                            delete coll[forDestruction[i]];
                        }
                    }
                };
                for (pos in coll) {
                    if (!coll[pos].isActive) {
                        coll[pos].render(pos, false, 0);
                        coll[pos].isActive = false;
                        forDestruction.push(pos);
                    }
                }
                if (coll === alternateBands || !chart.hasRendered || !delay) {
                    destroyInactiveItems();
                } else if (delay) {
                    setTimeout(destroyInactiveItems, delay);
                }
            });
            if (lineWidth) {
                linePath = axis.getLinePath(lineWidth);
                if (!axis.axisLine) {
                    axis.axisLine = renderer.path(linePath).attr({
                        stroke: options.lineColor,
                        "stroke-width": lineWidth,
                        zIndex: 7
                    }).add(axis.axisGroup);
                } else {
                    axis.axisLine.animate({
                        d: linePath
                    });
                }
                axis.axisLine[showAxis ? "show" : "hide"]();
            }
            if (axisTitle && showAxis) {
                axisTitle[axisTitle.isNew ? "attr" : "animate"](axis.getTitlePosition());
                axisTitle.isNew = false;
            }
            if (stackLabelOptions && stackLabelOptions.enabled) {
                var stackKey, oneStack, stackCategory, stackTotalGroup = axis.stackTotalGroup;
                if (!stackTotalGroup) {
                    axis.stackTotalGroup = stackTotalGroup = renderer.g("stack-labels").attr({
                        visibility: VISIBLE,
                        zIndex: 6
                    }).add();
                }
                stackTotalGroup.translate(chart.plotLeft, chart.plotTop);
                for (stackKey in stacks) {
                    oneStack = stacks[stackKey];
                    for (stackCategory in oneStack) {
                        oneStack[stackCategory].render(stackTotalGroup);
                    }
                }
            }
            axis.isDirty = false;
        },
        removePlotBandOrLine: function(id) {
            var plotLinesAndBands = this.plotLinesAndBands, options = this.options, userOptions = this.userOptions, i = plotLinesAndBands.length;
            while (i--) {
                if (plotLinesAndBands[i].id === id) {
                    plotLinesAndBands[i].destroy();
                }
            }
            each([ options.plotLines || [], userOptions.plotLines || [], options.plotBands || [], userOptions.plotBands || [] ], function(arr) {
                i = arr.length;
                while (i--) {
                    if (arr[i].id === id) {
                        erase(arr, arr[i]);
                    }
                }
            });
        },
        setTitle: function(newTitleOptions, redraw) {
            this.update({
                title: newTitleOptions
            }, redraw);
        },
        redraw: function() {
            var axis = this, chart = axis.chart, pointer = chart.pointer;
            if (pointer.reset) {
                pointer.reset(true);
            }
            axis.render();
            each(axis.plotLinesAndBands, function(plotLine) {
                plotLine.render();
            });
            each(axis.series, function(series) {
                series.isDirty = true;
            });
        },
        buildStacks: function() {
            if (this.isXAxis) {
                return;
            }
            each(this.series, function(series) {
                series.setStackedPoints();
            });
        },
        setCategories: function(categories, redraw) {
            this.update({
                categories: categories
            }, redraw);
        },
        destroy: function(keepEvents) {
            var axis = this, stacks = axis.stacks, stackKey, plotLinesAndBands = axis.plotLinesAndBands, i;
            if (!keepEvents) {
                removeEvent(axis);
            }
            for (stackKey in stacks) {
                destroyObjectProperties(stacks[stackKey]);
                stacks[stackKey] = null;
            }
            each([ axis.ticks, axis.minorTicks, axis.alternateBands ], function(coll) {
                destroyObjectProperties(coll);
            });
            i = plotLinesAndBands.length;
            while (i--) {
                plotLinesAndBands[i].destroy();
            }
            each([ "stackTotalGroup", "axisLine", "axisGroup", "gridGroup", "labelGroup", "axisTitle" ], function(prop) {
                if (axis[prop]) {
                    axis[prop] = axis[prop].destroy();
                }
            });
        }
    };
    function Tooltip() {
        this.init.apply(this, arguments);
    }
    Tooltip.prototype = {
        init: function(chart, options) {
            var borderWidth = options.borderWidth, style = options.style, padding = pInt(style.padding);
            this.chart = chart;
            this.options = options;
            this.crosshairs = [];
            this.now = {
                x: 0,
                y: 0
            };
            this.isHidden = true;
            this.label = chart.renderer.label("", 0, 0, options.shape, null, null, options.useHTML, null, "tooltip").attr({
                padding: padding,
                fill: options.backgroundColor,
                "stroke-width": borderWidth,
                r: options.borderRadius,
                zIndex: 8
            }).css(style).css({
                padding: 0
            }).hide().add();
            if (!useCanVG) {
                this.label.shadow(options.shadow);
            }
            this.shared = options.shared;
        },
        destroy: function() {
            each(this.crosshairs, function(crosshair) {
                if (crosshair) {
                    crosshair.destroy();
                }
            });
            if (this.label) {
                this.label = this.label.destroy();
            }
            clearTimeout(this.hideTimer);
            clearTimeout(this.tooltipTimeout);
        },
        move: function(x, y, anchorX, anchorY) {
            var tooltip = this, now = tooltip.now, animate = tooltip.options.animation !== false && !tooltip.isHidden;
            extend(now, {
                x: animate ? (2 * now.x + x) / 3 : x,
                y: animate ? (now.y + y) / 2 : y,
                anchorX: animate ? (2 * now.anchorX + anchorX) / 3 : anchorX,
                anchorY: animate ? (now.anchorY + anchorY) / 2 : anchorY
            });
            tooltip.label.attr(now);
            if (animate && (mathAbs(x - now.x) > 1 || mathAbs(y - now.y) > 1)) {
                clearTimeout(this.tooltipTimeout);
                this.tooltipTimeout = setTimeout(function() {
                    if (tooltip) {
                        tooltip.move(x, y, anchorX, anchorY);
                    }
                }, 32);
            }
        },
        hide: function() {
            var tooltip = this, hoverPoints;
            clearTimeout(this.hideTimer);
            if (!this.isHidden) {
                hoverPoints = this.chart.hoverPoints;
                this.hideTimer = setTimeout(function() {
                    tooltip.label.fadeOut();
                    tooltip.isHidden = true;
                }, pick(this.options.hideDelay, 500));
                if (hoverPoints) {
                    each(hoverPoints, function(point) {
                        point.setState();
                    });
                }
                this.chart.hoverPoints = null;
            }
        },
        hideCrosshairs: function() {
            each(this.crosshairs, function(crosshair) {
                if (crosshair) {
                    crosshair.hide();
                }
            });
        },
        getAnchor: function(points, mouseEvent) {
            var ret, chart = this.chart, inverted = chart.inverted, plotTop = chart.plotTop, plotX = 0, plotY = 0, yAxis;
            points = splat(points);
            ret = points[0].tooltipPos;
            if (this.followPointer && mouseEvent) {
                if (mouseEvent.chartX === UNDEFINED) {
                    mouseEvent = chart.pointer.normalize(mouseEvent);
                }
                ret = [ mouseEvent.chartX - chart.plotLeft, mouseEvent.chartY - plotTop ];
            }
            if (!ret) {
                each(points, function(point) {
                    yAxis = point.series.yAxis;
                    plotX += point.plotX;
                    plotY += (point.plotLow ? (point.plotLow + point.plotHigh) / 2 : point.plotY) + (!inverted && yAxis ? yAxis.top - plotTop : 0);
                });
                plotX /= points.length;
                plotY /= points.length;
                ret = [ inverted ? chart.plotWidth - plotY : plotX, this.shared && !inverted && points.length > 1 && mouseEvent ? mouseEvent.chartY - plotTop : inverted ? chart.plotHeight - plotX : plotY ];
            }
            return map(ret, mathRound);
        },
        getPosition: function(boxWidth, boxHeight, point) {
            var chart = this.chart, plotLeft = chart.plotLeft, plotTop = chart.plotTop, plotWidth = chart.plotWidth, plotHeight = chart.plotHeight, distance = pick(this.options.distance, 12), pointX = point.plotX, pointY = point.plotY, x = pointX + plotLeft + (chart.inverted ? distance : -boxWidth - distance), y = pointY - boxHeight + plotTop + 15, alignedRight;
            if (x < 7) {
                x = plotLeft + mathMax(pointX, 0) + distance;
            }
            if (x + boxWidth > plotLeft + plotWidth) {
                x -= x + boxWidth - (plotLeft + plotWidth);
                y = pointY - boxHeight + plotTop - distance;
                alignedRight = true;
            }
            if (y < plotTop + 5) {
                y = plotTop + 5;
                if (alignedRight && pointY >= y && pointY <= y + boxHeight) {
                    y = pointY + plotTop + distance;
                }
            }
            if (y + boxHeight > plotTop + plotHeight) {
                y = mathMax(plotTop, plotTop + plotHeight - boxHeight - distance);
            }
            return {
                x: x,
                y: y
            };
        },
        defaultFormatter: function(tooltip) {
            var items = this.points || splat(this), series = items[0].series, s;
            s = [ series.tooltipHeaderFormatter(items[0]) ];
            each(items, function(item) {
                series = item.series;
                s.push(series.tooltipFormatter && series.tooltipFormatter(item) || item.point.tooltipFormatter(series.tooltipOptions.pointFormat));
            });
            s.push(tooltip.options.footerFormat || "");
            return s.join("");
        },
        refresh: function(point, mouseEvent) {
            var tooltip = this, chart = tooltip.chart, label = tooltip.label, options = tooltip.options, x, y, anchor, textConfig = {}, text, pointConfig = [], formatter = options.formatter || tooltip.defaultFormatter, hoverPoints = chart.hoverPoints, borderColor, crosshairsOptions = options.crosshairs, shared = tooltip.shared, currentSeries;
            clearTimeout(this.hideTimer);
            tooltip.followPointer = splat(point)[0].series.tooltipOptions.followPointer;
            anchor = tooltip.getAnchor(point, mouseEvent);
            x = anchor[0];
            y = anchor[1];
            if (shared && !(point.series && point.series.noSharedTooltip)) {
                chart.hoverPoints = point;
                if (hoverPoints) {
                    each(hoverPoints, function(point) {
                        point.setState();
                    });
                }
                each(point, function(item) {
                    item.setState(HOVER_STATE);
                    pointConfig.push(item.getLabelConfig());
                });
                textConfig = {
                    x: point[0].category,
                    y: point[0].y
                };
                textConfig.points = pointConfig;
                point = point[0];
            } else {
                textConfig = point.getLabelConfig();
            }
            text = formatter.call(textConfig, tooltip);
            currentSeries = point.series;
            if (text === false) {
                this.hide();
            } else {
                if (tooltip.isHidden) {
                    stop(label);
                    label.attr("opacity", 1).show();
                }
                label.attr({
                    text: text
                });
                borderColor = options.borderColor || point.color || currentSeries.color || "#606060";
                label.attr({
                    stroke: borderColor
                });
                tooltip.updatePosition({
                    plotX: x,
                    plotY: y
                });
                this.isHidden = false;
            }
            if (crosshairsOptions) {
                crosshairsOptions = splat(crosshairsOptions);
                var path, i = crosshairsOptions.length, attribs, axis, val, series;
                while (i--) {
                    series = point.series;
                    axis = series[i ? "yAxis" : "xAxis"];
                    if (crosshairsOptions[i] && axis) {
                        val = i ? pick(point.stackY, point.y) : point.x;
                        if (axis.isLog) {
                            val = log2lin(val);
                        }
                        if (series.modifyValue) {
                            val = series.modifyValue(val);
                        }
                        path = axis.getPlotLinePath(val, 1);
                        if (tooltip.crosshairs[i]) {
                            tooltip.crosshairs[i].attr({
                                d: path,
                                visibility: VISIBLE
                            });
                        } else {
                            attribs = {
                                "stroke-width": crosshairsOptions[i].width || 1,
                                stroke: crosshairsOptions[i].color || "#C0C0C0",
                                zIndex: crosshairsOptions[i].zIndex || 2
                            };
                            if (crosshairsOptions[i].dashStyle) {
                                attribs.dashstyle = crosshairsOptions[i].dashStyle;
                            }
                            tooltip.crosshairs[i] = chart.renderer.path(path).attr(attribs).add();
                        }
                    }
                }
            }
            fireEvent(chart, "tooltipRefresh", {
                text: text,
                x: x + chart.plotLeft,
                y: y + chart.plotTop,
                borderColor: borderColor
            });
        },
        updatePosition: function(point) {
            var chart = this.chart, label = this.label, pos = (this.options.positioner || this.getPosition).call(this, label.width, label.height, point);
            this.move(mathRound(pos.x), mathRound(pos.y), point.plotX + chart.plotLeft, point.plotY + chart.plotTop);
        }
    };
    function Pointer(chart, options) {
        this.init(chart, options);
    }
    Pointer.prototype = {
        init: function(chart, options) {
            var zoomType = useCanVG ? "" : options.chart.zoomType, inverted = chart.inverted, zoomX, zoomY;
            this.options = options;
            this.chart = chart;
            this.zoomX = zoomX = /x/.test(zoomType);
            this.zoomY = zoomY = /y/.test(zoomType);
            this.zoomHor = zoomX && !inverted || zoomY && inverted;
            this.zoomVert = zoomY && !inverted || zoomX && inverted;
            this.pinchDown = [];
            this.lastValidTouch = {};
            if (options.tooltip.enabled) {
                chart.tooltip = new Tooltip(chart, options.tooltip);
            }
            this.setDOMEvents();
        },
        normalize: function(e) {
            var chartPosition, chartX, chartY, ePos;
            e = e || win.event;
            if (!e.target) {
                e.target = e.srcElement;
            }
            e = washMouseEvent(e);
            ePos = e.touches ? e.touches.item(0) : e;
            this.chartPosition = chartPosition = offset(this.chart.container);
            if (ePos.pageX === UNDEFINED) {
                chartX = mathMax(e.x, e.clientX - chartPosition.left);
                chartY = e.y;
            } else {
                chartX = ePos.pageX - chartPosition.left;
                chartY = ePos.pageY - chartPosition.top;
            }
            return extend(e, {
                chartX: mathRound(chartX),
                chartY: mathRound(chartY)
            });
        },
        getCoordinates: function(e) {
            var coordinates = {
                xAxis: [],
                yAxis: []
            };
            each(this.chart.axes, function(axis) {
                coordinates[axis.isXAxis ? "xAxis" : "yAxis"].push({
                    axis: axis,
                    value: axis.toValue(e[axis.horiz ? "chartX" : "chartY"])
                });
            });
            return coordinates;
        },
        getIndex: function(e) {
            var chart = this.chart;
            return chart.inverted ? chart.plotHeight + chart.plotTop - e.chartY : e.chartX - chart.plotLeft;
        },
        runPointActions: function(e) {
            var pointer = this, chart = pointer.chart, series = chart.series, tooltip = chart.tooltip, point, points, hoverPoint = chart.hoverPoint, hoverSeries = chart.hoverSeries, i, j, distance = chart.chartWidth, index = pointer.getIndex(e), anchor;
            if (tooltip && pointer.options.tooltip.shared && !(hoverSeries && hoverSeries.noSharedTooltip)) {
                points = [];
                i = series.length;
                for (j = 0; j < i; j++) {
                    if (series[j].visible && series[j].options.enableMouseTracking !== false && !series[j].noSharedTooltip && series[j].tooltipPoints.length) {
                        point = series[j].tooltipPoints[index];
                        if (point.series) {
                            point._dist = mathAbs(index - point.clientX);
                            distance = mathMin(distance, point._dist);
                            points.push(point);
                        }
                    }
                }
                i = points.length;
                while (i--) {
                    if (points[i]._dist > distance) {
                        points.splice(i, 1);
                    }
                }
                if (points.length && points[0].clientX !== pointer.hoverX) {
                    tooltip.refresh(points, e);
                    pointer.hoverX = points[0].clientX;
                }
            }
            if (hoverSeries && hoverSeries.tracker) {
                point = hoverSeries.tooltipPoints[index];
                if (point && point !== hoverPoint) {
                    point.onMouseOver(e);
                }
            } else if (tooltip && tooltip.followPointer && !tooltip.isHidden) {
                anchor = tooltip.getAnchor([ {} ], e);
                tooltip.updatePosition({
                    plotX: anchor[0],
                    plotY: anchor[1]
                });
            }
        },
        reset: function(allowMove) {
            var pointer = this, chart = pointer.chart, hoverSeries = chart.hoverSeries, hoverPoint = chart.hoverPoint, tooltip = chart.tooltip, tooltipPoints = tooltip && tooltip.shared ? chart.hoverPoints : hoverPoint;
            allowMove = allowMove && tooltip && tooltipPoints;
            if (allowMove && splat(tooltipPoints)[0].plotX === UNDEFINED) {
                allowMove = false;
            }
            if (allowMove) {
                tooltip.refresh(tooltipPoints);
            } else {
                if (hoverPoint) {
                    hoverPoint.onMouseOut();
                }
                if (hoverSeries) {
                    hoverSeries.onMouseOut();
                }
                if (tooltip) {
                    tooltip.hide();
                    tooltip.hideCrosshairs();
                }
                pointer.hoverX = null;
            }
        },
        scaleGroups: function(attribs, clip) {
            var chart = this.chart, seriesAttribs;
            each(chart.series, function(series) {
                seriesAttribs = attribs || series.getPlotBox();
                if (series.xAxis && series.xAxis.zoomEnabled) {
                    series.group.attr(seriesAttribs);
                    if (series.markerGroup) {
                        series.markerGroup.attr(seriesAttribs);
                        series.markerGroup.clip(clip ? chart.clipRect : null);
                    }
                    if (series.dataLabelsGroup) {
                        series.dataLabelsGroup.attr(seriesAttribs);
                    }
                }
            });
            chart.clipRect.attr(clip || chart.clipBox);
        },
        pinchTranslateDirection: function(horiz, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch) {
            var chart = this.chart, xy = horiz ? "x" : "y", XY = horiz ? "X" : "Y", sChartXY = "chart" + XY, wh = horiz ? "width" : "height", plotLeftTop = chart["plot" + (horiz ? "Left" : "Top")], selectionWH, selectionXY, clipXY, scale = 1, inverted = chart.inverted, bounds = chart.bounds[horiz ? "h" : "v"], singleTouch = pinchDown.length === 1, touch0Start = pinchDown[0][sChartXY], touch0Now = touches[0][sChartXY], touch1Start = !singleTouch && pinchDown[1][sChartXY], touch1Now = !singleTouch && touches[1][sChartXY], outOfBounds, transformScale, scaleKey, setScale = function() {
                if (!singleTouch && mathAbs(touch0Start - touch1Start) > 20) {
                    scale = mathAbs(touch0Now - touch1Now) / mathAbs(touch0Start - touch1Start);
                }
                clipXY = (plotLeftTop - touch0Now) / scale + touch0Start;
                selectionWH = chart["plot" + (horiz ? "Width" : "Height")] / scale;
            };
            setScale();
            selectionXY = clipXY;
            if (selectionXY < bounds.min) {
                selectionXY = bounds.min;
                outOfBounds = true;
            } else if (selectionXY + selectionWH > bounds.max) {
                selectionXY = bounds.max - selectionWH;
                outOfBounds = true;
            }
            if (outOfBounds) {
                touch0Now -= .8 * (touch0Now - lastValidTouch[xy][0]);
                if (!singleTouch) {
                    touch1Now -= .8 * (touch1Now - lastValidTouch[xy][1]);
                }
                setScale();
            } else {
                lastValidTouch[xy] = [ touch0Now, touch1Now ];
            }
            if (!inverted) {
                clip[xy] = clipXY - plotLeftTop;
                clip[wh] = selectionWH;
            }
            scaleKey = inverted ? horiz ? "scaleY" : "scaleX" : "scale" + XY;
            transformScale = inverted ? 1 / scale : scale;
            selectionMarker[wh] = selectionWH;
            selectionMarker[xy] = selectionXY;
            transform[scaleKey] = scale;
            transform["translate" + XY] = transformScale * plotLeftTop + (touch0Now - transformScale * touch0Start);
        },
        pinch: function(e) {
            var self = this, chart = self.chart, pinchDown = self.pinchDown, followTouchMove = chart.tooltip && chart.tooltip.options.followTouchMove, touches = e.touches, touchesLength = touches.length, lastValidTouch = self.lastValidTouch, zoomHor = self.zoomHor || self.pinchHor, zoomVert = self.zoomVert || self.pinchVert, hasZoom = zoomHor || zoomVert, selectionMarker = self.selectionMarker, transform = {}, clip = {};
            if (followTouchMove || hasZoom) {
                e.preventDefault();
            }
            map(touches, function(e) {
                return self.normalize(e);
            });
            if (e.type === "touchstart") {
                each(touches, function(e, i) {
                    pinchDown[i] = {
                        chartX: e.chartX,
                        chartY: e.chartY
                    };
                });
                lastValidTouch.x = [ pinchDown[0].chartX, pinchDown[1] && pinchDown[1].chartX ];
                lastValidTouch.y = [ pinchDown[0].chartY, pinchDown[1] && pinchDown[1].chartY ];
                each(chart.axes, function(axis) {
                    if (axis.zoomEnabled) {
                        var bounds = chart.bounds[axis.horiz ? "h" : "v"], minPixelPadding = axis.minPixelPadding, min = axis.toPixels(axis.dataMin), max = axis.toPixels(axis.dataMax), absMin = mathMin(min, max), absMax = mathMax(min, max);
                        bounds.min = mathMin(axis.pos, absMin - minPixelPadding);
                        bounds.max = mathMax(axis.pos + axis.len, absMax + minPixelPadding);
                    }
                });
            } else if (pinchDown.length) {
                if (!selectionMarker) {
                    self.selectionMarker = selectionMarker = extend({
                        destroy: noop
                    }, chart.plotBox);
                }
                if (zoomHor) {
                    self.pinchTranslateDirection(true, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);
                }
                if (zoomVert) {
                    self.pinchTranslateDirection(false, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);
                }
                self.hasPinched = hasZoom;
                self.scaleGroups(transform, clip);
                if (!hasZoom && followTouchMove && touchesLength === 1) {
                    this.runPointActions(self.normalize(e));
                }
            }
        },
        dragStart: function(e) {
            var chart = this.chart;
            chart.mouseIsDown = e.type;
            chart.cancelClick = false;
            chart.mouseDownX = this.mouseDownX = e.chartX;
            chart.mouseDownY = this.mouseDownY = e.chartY;
        },
        drag: function(e) {
            var chart = this.chart, chartOptions = chart.options.chart, chartX = e.chartX, chartY = e.chartY, zoomHor = this.zoomHor, zoomVert = this.zoomVert, plotLeft = chart.plotLeft, plotTop = chart.plotTop, plotWidth = chart.plotWidth, plotHeight = chart.plotHeight, clickedInside, size, mouseDownX = this.mouseDownX, mouseDownY = this.mouseDownY;
            if (chartX < plotLeft) {
                chartX = plotLeft;
            } else if (chartX > plotLeft + plotWidth) {
                chartX = plotLeft + plotWidth;
            }
            if (chartY < plotTop) {
                chartY = plotTop;
            } else if (chartY > plotTop + plotHeight) {
                chartY = plotTop + plotHeight;
            }
            this.hasDragged = Math.sqrt(Math.pow(mouseDownX - chartX, 2) + Math.pow(mouseDownY - chartY, 2));
            if (this.hasDragged > 10) {
                clickedInside = chart.isInsidePlot(mouseDownX - plotLeft, mouseDownY - plotTop);
                if (chart.hasCartesianSeries && (this.zoomX || this.zoomY) && clickedInside) {
                    if (!this.selectionMarker) {
                        this.selectionMarker = chart.renderer.rect(plotLeft, plotTop, zoomHor ? 1 : plotWidth, zoomVert ? 1 : plotHeight, 0).attr({
                            fill: chartOptions.selectionMarkerFill || "rgba(69,114,167,0.25)",
                            zIndex: 7
                        }).add();
                    }
                }
                if (this.selectionMarker && zoomHor) {
                    size = chartX - mouseDownX;
                    this.selectionMarker.attr({
                        width: mathAbs(size),
                        x: (size > 0 ? 0 : size) + mouseDownX
                    });
                }
                if (this.selectionMarker && zoomVert) {
                    size = chartY - mouseDownY;
                    this.selectionMarker.attr({
                        height: mathAbs(size),
                        y: (size > 0 ? 0 : size) + mouseDownY
                    });
                }
                if (clickedInside && !this.selectionMarker && chartOptions.panning) {
                    chart.pan(e, chartOptions.panning);
                }
            }
        },
        drop: function(e) {
            var chart = this.chart, hasPinched = this.hasPinched;
            if (this.selectionMarker) {
                var selectionData = {
                    xAxis: [],
                    yAxis: [],
                    originalEvent: e.originalEvent || e
                }, selectionBox = this.selectionMarker, selectionLeft = selectionBox.x, selectionTop = selectionBox.y, runZoom;
                if (this.hasDragged || hasPinched) {
                    each(chart.axes, function(axis) {
                        if (axis.zoomEnabled) {
                            var horiz = axis.horiz, selectionMin = axis.toValue(horiz ? selectionLeft : selectionTop), selectionMax = axis.toValue(horiz ? selectionLeft + selectionBox.width : selectionTop + selectionBox.height);
                            if (!isNaN(selectionMin) && !isNaN(selectionMax)) {
                                selectionData[axis.xOrY + "Axis"].push({
                                    axis: axis,
                                    min: mathMin(selectionMin, selectionMax),
                                    max: mathMax(selectionMin, selectionMax)
                                });
                                runZoom = true;
                            }
                        }
                    });
                    if (runZoom) {
                        fireEvent(chart, "selection", selectionData, function(args) {
                            chart.zoom(extend(args, hasPinched ? {
                                animation: false
                            } : null));
                        });
                    }
                }
                this.selectionMarker = this.selectionMarker.destroy();
                if (hasPinched) {
                    this.scaleGroups();
                }
            }
            if (chart) {
                css(chart.container, {
                    cursor: chart._cursor
                });
                chart.cancelClick = this.hasDragged > 10;
                chart.mouseIsDown = this.hasDragged = this.hasPinched = false;
                this.pinchDown = [];
            }
        },
        onContainerMouseDown: function(e) {
            e = this.normalize(e);
            if (e.preventDefault) {
                e.preventDefault();
            }
            this.dragStart(e);
        },
        onDocumentMouseUp: function(e) {
            this.drop(e);
        },
        onDocumentMouseMove: function(e) {
            var chart = this.chart, chartPosition = this.chartPosition, hoverSeries = chart.hoverSeries;
            e = washMouseEvent(e);
            if (chartPosition && hoverSeries && !this.inClass(e.target, "highcharts-tracker") && !chart.isInsidePlot(e.pageX - chartPosition.left - chart.plotLeft, e.pageY - chartPosition.top - chart.plotTop)) {
                this.reset();
            }
        },
        onContainerMouseLeave: function() {
            this.reset();
            this.chartPosition = null;
        },
        onContainerMouseMove: function(e) {
            var chart = this.chart;
            e = this.normalize(e);
            e.returnValue = false;
            if (chart.mouseIsDown === "mousedown") {
                this.drag(e);
            }
            if ((this.inClass(e.target, "highcharts-tracker") || chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) && !chart.openMenu) {
                this.runPointActions(e);
            }
        },
        inClass: function(element, className) {
            var elemClassName;
            while (element) {
                elemClassName = attr(element, "class");
                if (elemClassName) {
                    if (elemClassName.indexOf(className) !== -1) {
                        return true;
                    } else if (elemClassName.indexOf(PREFIX + "container") !== -1) {
                        return false;
                    }
                }
                element = element.parentNode;
            }
        },
        onTrackerMouseOut: function(e) {
            var series = this.chart.hoverSeries;
            if (series && !series.options.stickyTracking && !this.inClass(e.toElement || e.relatedTarget, PREFIX + "tooltip")) {
                series.onMouseOut();
            }
        },
        onContainerClick: function(e) {
            var chart = this.chart, hoverPoint = chart.hoverPoint, plotLeft = chart.plotLeft, plotTop = chart.plotTop, inverted = chart.inverted, chartPosition, plotX, plotY;
            e = this.normalize(e);
            e.cancelBubble = true;
            if (!chart.cancelClick) {
                if (hoverPoint && this.inClass(e.target, PREFIX + "tracker")) {
                    chartPosition = this.chartPosition;
                    plotX = hoverPoint.plotX;
                    plotY = hoverPoint.plotY;
                    extend(hoverPoint, {
                        pageX: chartPosition.left + plotLeft + (inverted ? chart.plotWidth - plotY : plotX),
                        pageY: chartPosition.top + plotTop + (inverted ? chart.plotHeight - plotX : plotY)
                    });
                    fireEvent(hoverPoint.series, "click", extend(e, {
                        point: hoverPoint
                    }));
                    if (chart.hoverPoint) {
                        hoverPoint.firePointEvent("click", e);
                    }
                } else {
                    extend(e, this.getCoordinates(e));
                    if (chart.isInsidePlot(e.chartX - plotLeft, e.chartY - plotTop)) {
                        fireEvent(chart, "click", e);
                    }
                }
            }
        },
        onContainerTouchStart: function(e) {
            var chart = this.chart;
            if (e.touches.length === 1) {
                e = this.normalize(e);
                if (chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) {
                    this.runPointActions(e);
                    this.pinch(e);
                } else {
                    this.reset();
                }
            } else if (e.touches.length === 2) {
                this.pinch(e);
            }
        },
        onContainerTouchMove: function(e) {
            if (e.touches.length === 1 || e.touches.length === 2) {
                this.pinch(e);
            }
        },
        onDocumentTouchEnd: function(e) {
            this.drop(e);
        },
        setDOMEvents: function() {
            var pointer = this, container = pointer.chart.container, events;
            this._events = events = [ [ container, "onmousedown", "onContainerMouseDown" ], [ container, "onmousemove", "onContainerMouseMove" ], [ container, "onclick", "onContainerClick" ], [ container, "mouseleave", "onContainerMouseLeave" ], [ doc, "mousemove", "onDocumentMouseMove" ], [ doc, "mouseup", "onDocumentMouseUp" ] ];
            if (hasTouch) {
                events.push([ container, "ontouchstart", "onContainerTouchStart" ], [ container, "ontouchmove", "onContainerTouchMove" ], [ doc, "touchend", "onDocumentTouchEnd" ]);
            }
            each(events, function(eventConfig) {
                pointer["_" + eventConfig[2]] = function(e) {
                    pointer[eventConfig[2]](e);
                };
                if (eventConfig[1].indexOf("on") === 0) {
                    eventConfig[0][eventConfig[1]] = pointer["_" + eventConfig[2]];
                } else {
                    addEvent(eventConfig[0], eventConfig[1], pointer["_" + eventConfig[2]]);
                }
            });
        },
        destroy: function() {
            var pointer = this;
            each(pointer._events, function(eventConfig) {
                if (eventConfig[1].indexOf("on") === 0) {
                    eventConfig[0][eventConfig[1]] = null;
                } else {
                    removeEvent(eventConfig[0], eventConfig[1], pointer["_" + eventConfig[2]]);
                }
            });
            delete pointer._events;
            clearInterval(pointer.tooltipTimeout);
        }
    };
    function Legend(chart, options) {
        this.init(chart, options);
    }
    Legend.prototype = {
        init: function(chart, options) {
            var legend = this, itemStyle = options.itemStyle, padding = pick(options.padding, 8), itemMarginTop = options.itemMarginTop || 0;
            this.options = options;
            if (!options.enabled) {
                return;
            }
            legend.baseline = pInt(itemStyle.fontSize) + 3 + itemMarginTop;
            legend.itemStyle = itemStyle;
            legend.itemHiddenStyle = merge(itemStyle, options.itemHiddenStyle);
            legend.itemMarginTop = itemMarginTop;
            legend.padding = padding;
            legend.initialItemX = padding;
            legend.initialItemY = padding - 5;
            legend.maxItemWidth = 0;
            legend.chart = chart;
            legend.itemHeight = 0;
            legend.lastLineHeight = 0;
            legend.render();
            addEvent(legend.chart, "endResize", function() {
                legend.positionCheckboxes();
            });
        },
        colorizeItem: function(item, visible) {
            var legend = this, options = legend.options, legendItem = item.legendItem, legendLine = item.legendLine, legendSymbol = item.legendSymbol, hiddenColor = legend.itemHiddenStyle.color, textColor = visible ? options.itemStyle.color : hiddenColor, symbolColor = visible ? item.color : hiddenColor, markerOptions = item.options && item.options.marker, symbolAttr = {
                stroke: symbolColor,
                fill: symbolColor
            }, key, val;
            if (legendItem) {
                legendItem.css({
                    fill: textColor,
                    color: textColor
                });
            }
            if (legendLine) {
                legendLine.attr({
                    stroke: symbolColor
                });
            }
            if (legendSymbol) {
                if (markerOptions && legendSymbol.isMarker) {
                    markerOptions = item.convertAttribs(markerOptions);
                    for (key in markerOptions) {
                        val = markerOptions[key];
                        if (val !== UNDEFINED) {
                            symbolAttr[key] = val;
                        }
                    }
                }
                legendSymbol.attr(symbolAttr);
            }
        },
        positionItem: function(item) {
            var legend = this, options = legend.options, symbolPadding = options.symbolPadding, ltr = !options.rtl, legendItemPos = item._legendItemPos, itemX = legendItemPos[0], itemY = legendItemPos[1], checkbox = item.checkbox;
            if (item.legendGroup) {
                item.legendGroup.translate(ltr ? itemX : legend.legendWidth - itemX - 2 * symbolPadding - 4, itemY);
            }
            if (checkbox) {
                checkbox.x = itemX;
                checkbox.y = itemY;
            }
        },
        destroyItem: function(item) {
            var checkbox = item.checkbox;
            each([ "legendItem", "legendLine", "legendSymbol", "legendGroup" ], function(key) {
                if (item[key]) {
                    item[key] = item[key].destroy();
                }
            });
            if (checkbox) {
                discardElement(item.checkbox);
            }
        },
        destroy: function() {
            var legend = this, legendGroup = legend.group, box = legend.box;
            if (box) {
                legend.box = box.destroy();
            }
            if (legendGroup) {
                legend.group = legendGroup.destroy();
            }
        },
        positionCheckboxes: function(scrollOffset) {
            var alignAttr = this.group.alignAttr, translateY, clipHeight = this.clipHeight || this.legendHeight;
            if (alignAttr) {
                translateY = alignAttr.translateY;
                each(this.allItems, function(item) {
                    var checkbox = item.checkbox, top;
                    if (checkbox) {
                        top = translateY + checkbox.y + (scrollOffset || 0) + 3;
                        css(checkbox, {
                            left: alignAttr.translateX + item.legendItemWidth + checkbox.x - 20 + PX,
                            top: top + PX,
                            display: top > translateY - 6 && top < translateY + clipHeight - 6 ? "" : NONE
                        });
                    }
                });
            }
        },
        renderTitle: function() {
            var options = this.options, padding = this.padding, titleOptions = options.title, titleHeight = 0, bBox;
            if (titleOptions.text) {
                if (!this.title) {
                    this.title = this.chart.renderer.label(titleOptions.text, padding - 3, padding - 4, null, null, null, null, null, "legend-title").attr({
                        zIndex: 1
                    }).css(titleOptions.style).add(this.group);
                }
                bBox = this.title.getBBox();
                titleHeight = bBox.height;
                this.offsetWidth = bBox.width;
                this.contentGroup.attr({
                    translateY: titleHeight
                });
            }
            this.titleHeight = titleHeight;
        },
        renderItem: function(item) {
            var legend = this, chart = legend.chart, renderer = chart.renderer, options = legend.options, horizontal = options.layout === "horizontal", symbolWidth = options.symbolWidth, symbolPadding = options.symbolPadding, itemStyle = legend.itemStyle, itemHiddenStyle = legend.itemHiddenStyle, padding = legend.padding, itemDistance = horizontal ? pick(options.itemDistance, 8) : 0, ltr = !options.rtl, itemHeight, widthOption = options.width, itemMarginBottom = options.itemMarginBottom || 0, itemMarginTop = legend.itemMarginTop, initialItemX = legend.initialItemX, bBox, itemWidth, li = item.legendItem, series = item.series || item, itemOptions = series.options, showCheckbox = itemOptions.showCheckbox, useHTML = options.useHTML;
            if (!li) {
                item.legendGroup = renderer.g("legend-item").attr({
                    zIndex: 1
                }).add(legend.scrollGroup);
                series.drawLegendSymbol(legend, item);
                item.legendItem = li = renderer.text(options.labelFormat ? format(options.labelFormat, item) : options.labelFormatter.call(item), ltr ? symbolWidth + symbolPadding : -symbolPadding, legend.baseline, useHTML).css(merge(item.visible ? itemStyle : itemHiddenStyle)).attr({
                    align: ltr ? "left" : "right",
                    zIndex: 2
                }).add(item.legendGroup);
                (useHTML ? li : item.legendGroup).on("mouseover", function() {
                    item.setState(HOVER_STATE);
                    li.css(legend.options.itemHoverStyle);
                }).on("mouseout", function() {
                    li.css(item.visible ? itemStyle : itemHiddenStyle);
                    item.setState();
                }).on("click", function(event) {
                    var strLegendItemClick = "legendItemClick", fnLegendItemClick = function() {
                        item.setVisible();
                    };
                    event = {
                        browserEvent: event
                    };
                    if (item.firePointEvent) {
                        item.firePointEvent(strLegendItemClick, event, fnLegendItemClick);
                    } else {
                        fireEvent(item, strLegendItemClick, event, fnLegendItemClick);
                    }
                });
                legend.colorizeItem(item, item.visible);
                if (itemOptions && showCheckbox) {
                    item.checkbox = createElement("input", {
                        type: "checkbox",
                        checked: item.selected,
                        defaultChecked: item.selected
                    }, options.itemCheckboxStyle, chart.container);
                    addEvent(item.checkbox, "click", function(event) {
                        var target = event.target;
                        fireEvent(item, "checkboxClick", {
                            checked: target.checked
                        }, function() {
                            item.select();
                        });
                    });
                }
            }
            bBox = li.getBBox();
            itemWidth = item.legendItemWidth = options.itemWidth || symbolWidth + symbolPadding + bBox.width + itemDistance + (showCheckbox ? 20 : 0);
            legend.itemHeight = itemHeight = bBox.height;
            if (horizontal && legend.itemX - initialItemX + itemWidth > (widthOption || chart.chartWidth - 2 * padding - initialItemX)) {
                legend.itemX = initialItemX;
                legend.itemY += itemMarginTop + legend.lastLineHeight + itemMarginBottom;
                legend.lastLineHeight = 0;
            }
            legend.maxItemWidth = mathMax(legend.maxItemWidth, itemWidth);
            legend.lastItemY = itemMarginTop + legend.itemY + itemMarginBottom;
            legend.lastLineHeight = mathMax(itemHeight, legend.lastLineHeight);
            item._legendItemPos = [ legend.itemX, legend.itemY ];
            if (horizontal) {
                legend.itemX += itemWidth;
            } else {
                legend.itemY += itemMarginTop + itemHeight + itemMarginBottom;
                legend.lastLineHeight = itemHeight;
            }
            legend.offsetWidth = widthOption || mathMax((horizontal ? legend.itemX - initialItemX - itemDistance : itemWidth) + padding, legend.offsetWidth);
        },
        render: function() {
            var legend = this, chart = legend.chart, renderer = chart.renderer, legendGroup = legend.group, allItems, display, legendWidth, legendHeight, box = legend.box, options = legend.options, padding = legend.padding, legendBorderWidth = options.borderWidth, legendBackgroundColor = options.backgroundColor;
            legend.itemX = legend.initialItemX;
            legend.itemY = legend.initialItemY;
            legend.offsetWidth = 0;
            legend.lastItemY = 0;
            if (!legendGroup) {
                legend.group = legendGroup = renderer.g("legend").attr({
                    zIndex: 7
                }).add();
                legend.contentGroup = renderer.g().attr({
                    zIndex: 1
                }).add(legendGroup);
                legend.scrollGroup = renderer.g().add(legend.contentGroup);
            }
            legend.renderTitle();
            allItems = [];
            each(chart.series, function(serie) {
                var seriesOptions = serie.options;
                if (!seriesOptions.showInLegend || defined(seriesOptions.linkedTo)) {
                    return;
                }
                allItems = allItems.concat(serie.legendItems || (seriesOptions.legendType === "point" ? serie.data : serie));
            });
            stableSort(allItems, function(a, b) {
                return (a.options && a.options.legendIndex || 0) - (b.options && b.options.legendIndex || 0);
            });
            if (options.reversed) {
                allItems.reverse();
            }
            legend.allItems = allItems;
            legend.display = display = !!allItems.length;
            each(allItems, function(item) {
                legend.renderItem(item);
            });
            legendWidth = options.width || legend.offsetWidth;
            legendHeight = legend.lastItemY + legend.lastLineHeight + legend.titleHeight;
            legendHeight = legend.handleOverflow(legendHeight);
            if (legendBorderWidth || legendBackgroundColor) {
                legendWidth += padding;
                legendHeight += padding;
                if (!box) {
                    legend.box = box = renderer.rect(0, 0, legendWidth, legendHeight, options.borderRadius, legendBorderWidth || 0).attr({
                        stroke: options.borderColor,
                        "stroke-width": legendBorderWidth || 0,
                        fill: legendBackgroundColor || NONE
                    }).add(legendGroup).shadow(options.shadow);
                    box.isNew = true;
                } else if (legendWidth > 0 && legendHeight > 0) {
                    box[box.isNew ? "attr" : "animate"](box.crisp(null, null, null, legendWidth, legendHeight));
                    box.isNew = false;
                }
                box[display ? "show" : "hide"]();
            }
            legend.legendWidth = legendWidth;
            legend.legendHeight = legendHeight;
            each(allItems, function(item) {
                legend.positionItem(item);
            });
            if (display) {
                legendGroup.align(extend({
                    width: legendWidth,
                    height: legendHeight
                }, options), true, "spacingBox");
            }
            if (!chart.isResizing) {
                this.positionCheckboxes();
            }
        },
        handleOverflow: function(legendHeight) {
            var legend = this, chart = this.chart, renderer = chart.renderer, pageCount, options = this.options, optionsY = options.y, alignTop = options.verticalAlign === "top", spaceHeight = chart.spacingBox.height + (alignTop ? -optionsY : optionsY) - this.padding, maxHeight = options.maxHeight, clipHeight, clipRect = this.clipRect, navOptions = options.navigation, animation = pick(navOptions.animation, true), arrowSize = navOptions.arrowSize || 12, nav = this.nav;
            if (options.layout === "horizontal") {
                spaceHeight /= 2;
            }
            if (maxHeight) {
                spaceHeight = mathMin(spaceHeight, maxHeight);
            }
            if (legendHeight > spaceHeight && !options.useHTML) {
                this.clipHeight = clipHeight = spaceHeight - 20 - this.titleHeight;
                this.pageCount = pageCount = mathCeil(legendHeight / clipHeight);
                this.currentPage = pick(this.currentPage, 1);
                this.fullHeight = legendHeight;
                if (!clipRect) {
                    clipRect = legend.clipRect = renderer.clipRect(0, 0, 9999, 0);
                    legend.contentGroup.clip(clipRect);
                }
                clipRect.attr({
                    height: clipHeight
                });
                if (!nav) {
                    this.nav = nav = renderer.g().attr({
                        zIndex: 1
                    }).add(this.group);
                    this.up = renderer.symbol("triangle", 0, 0, arrowSize, arrowSize).on("click", function() {
                        legend.scroll(-1, animation);
                    }).add(nav);
                    this.pager = renderer.text("", 15, 10).css(navOptions.style).add(nav);
                    this.down = renderer.symbol("triangle-down", 0, 0, arrowSize, arrowSize).on("click", function() {
                        legend.scroll(1, animation);
                    }).add(nav);
                }
                legend.scroll(0);
                legendHeight = spaceHeight;
            } else if (nav) {
                clipRect.attr({
                    height: chart.chartHeight
                });
                nav.hide();
                this.scrollGroup.attr({
                    translateY: 1
                });
                this.clipHeight = 0;
            }
            return legendHeight;
        },
        scroll: function(scrollBy, animation) {
            var pageCount = this.pageCount, currentPage = this.currentPage + scrollBy, clipHeight = this.clipHeight, navOptions = this.options.navigation, activeColor = navOptions.activeColor, inactiveColor = navOptions.inactiveColor, pager = this.pager, padding = this.padding, scrollOffset;
            if (currentPage > pageCount) {
                currentPage = pageCount;
            }
            if (currentPage > 0) {
                if (animation !== UNDEFINED) {
                    setAnimation(animation, this.chart);
                }
                this.nav.attr({
                    translateX: padding,
                    translateY: clipHeight + 7 + this.titleHeight,
                    visibility: VISIBLE
                });
                this.up.attr({
                    fill: currentPage === 1 ? inactiveColor : activeColor
                }).css({
                    cursor: currentPage === 1 ? "default" : "pointer"
                });
                pager.attr({
                    text: currentPage + "/" + this.pageCount
                });
                this.down.attr({
                    x: 18 + this.pager.getBBox().width,
                    fill: currentPage === pageCount ? inactiveColor : activeColor
                }).css({
                    cursor: currentPage === pageCount ? "default" : "pointer"
                });
                scrollOffset = -mathMin(clipHeight * (currentPage - 1), this.fullHeight - clipHeight + padding) + 1;
                this.scrollGroup.animate({
                    translateY: scrollOffset
                });
                pager.attr({
                    text: currentPage + "/" + pageCount
                });
                this.currentPage = currentPage;
                this.positionCheckboxes(scrollOffset);
            }
        }
    };
    function Chart() {
        this.init.apply(this, arguments);
    }
    Chart.prototype = {
        init: function(userOptions, callback) {
            var options, seriesOptions = userOptions.series;
            userOptions.series = null;
            options = merge(defaultOptions, userOptions);
            options.series = userOptions.series = seriesOptions;
            var optionsChart = options.chart, optionsMargin = optionsChart.margin, margin = isObject(optionsMargin) ? optionsMargin : [ optionsMargin, optionsMargin, optionsMargin, optionsMargin ];
            this.optionsMarginTop = pick(optionsChart.marginTop, margin[0]);
            this.optionsMarginRight = pick(optionsChart.marginRight, margin[1]);
            this.optionsMarginBottom = pick(optionsChart.marginBottom, margin[2]);
            this.optionsMarginLeft = pick(optionsChart.marginLeft, margin[3]);
            var chartEvents = optionsChart.events;
            this.bounds = {
                h: {},
                v: {}
            };
            this.callback = callback;
            this.isResizing = 0;
            this.options = options;
            this.axes = [];
            this.series = [];
            this.hasCartesianSeries = optionsChart.showAxes;
            var chart = this, eventType;
            chart.index = charts.length;
            charts.push(chart);
            if (optionsChart.reflow !== false) {
                addEvent(chart, "load", function() {
                    chart.initReflow();
                });
            }
            if (chartEvents) {
                for (eventType in chartEvents) {
                    addEvent(chart, eventType, chartEvents[eventType]);
                }
            }
            chart.xAxis = [];
            chart.yAxis = [];
            chart.animation = useCanVG ? false : pick(optionsChart.animation, true);
            chart.pointCount = 0;
            chart.counters = new ChartCounters();
            chart.firstRender();
        },
        initSeries: function(options) {
            var chart = this, optionsChart = chart.options.chart, type = options.type || optionsChart.type || optionsChart.defaultSeriesType, series, constr = seriesTypes[type];
            if (!constr) {
                error(17, true);
            }
            series = new constr();
            series.init(this, options);
            return series;
        },
        addSeries: function(options, redraw, animation) {
            var series, chart = this;
            if (options) {
                redraw = pick(redraw, true);
                fireEvent(chart, "addSeries", {
                    options: options
                }, function() {
                    series = chart.initSeries(options);
                    chart.isDirtyLegend = true;
                    chart.linkSeries();
                    if (redraw) {
                        chart.redraw(animation);
                    }
                });
            }
            return series;
        },
        addAxis: function(options, isX, redraw, animation) {
            var key = isX ? "xAxis" : "yAxis", chartOptions = this.options, axis;
            axis = new Axis(this, merge(options, {
                index: this[key].length,
                isX: isX
            }));
            chartOptions[key] = splat(chartOptions[key] || {});
            chartOptions[key].push(options);
            if (pick(redraw, true)) {
                this.redraw(animation);
            }
        },
        isInsidePlot: function(plotX, plotY, inverted) {
            var x = inverted ? plotY : plotX, y = inverted ? plotX : plotY;
            return x >= 0 && x <= this.plotWidth && y >= 0 && y <= this.plotHeight;
        },
        adjustTickAmounts: function() {
            if (this.options.chart.alignTicks !== false) {
                each(this.axes, function(axis) {
                    axis.adjustTickAmount();
                });
            }
            this.maxTicks = null;
        },
        redraw: function(animation) {
            var chart = this, axes = chart.axes, series = chart.series, pointer = chart.pointer, legend = chart.legend, redrawLegend = chart.isDirtyLegend, hasStackedSeries, hasDirtyStacks, isDirtyBox = chart.isDirtyBox, seriesLength = series.length, i = seriesLength, serie, renderer = chart.renderer, isHiddenChart = renderer.isHidden(), afterRedraw = [];
            setAnimation(animation, chart);
            if (isHiddenChart) {
                chart.cloneRenderTo();
            }
            chart.layOutTitles();
            while (i--) {
                serie = series[i];
                if (serie.options.stacking) {
                    hasStackedSeries = true;
                    if (serie.isDirty) {
                        hasDirtyStacks = true;
                        break;
                    }
                }
            }
            if (hasDirtyStacks) {
                i = seriesLength;
                while (i--) {
                    serie = series[i];
                    if (serie.options.stacking) {
                        serie.isDirty = true;
                    }
                }
            }
            each(series, function(serie) {
                if (serie.isDirty) {
                    if (serie.options.legendType === "point") {
                        redrawLegend = true;
                    }
                }
            });
            if (redrawLegend && legend.options.enabled) {
                legend.render();
                chart.isDirtyLegend = false;
            }
            if (hasStackedSeries) {
                chart.getStacks();
            }
            if (chart.hasCartesianSeries) {
                if (!chart.isResizing) {
                    chart.maxTicks = null;
                    each(axes, function(axis) {
                        axis.setScale();
                    });
                }
                chart.adjustTickAmounts();
                chart.getMargins();
                each(axes, function(axis) {
                    if (axis.isDirty) {
                        isDirtyBox = true;
                    }
                });
                each(axes, function(axis) {
                    if (axis.isDirtyExtremes) {
                        axis.isDirtyExtremes = false;
                        afterRedraw.push(function() {
                            fireEvent(axis, "afterSetExtremes", axis.getExtremes());
                        });
                    }
                    if (isDirtyBox || hasStackedSeries) {
                        axis.redraw();
                    }
                });
            }
            if (isDirtyBox) {
                chart.drawChartBox();
            }
            each(series, function(serie) {
                if (serie.isDirty && serie.visible && (!serie.isCartesian || serie.xAxis)) {
                    serie.redraw();
                }
            });
            if (pointer && pointer.reset) {
                pointer.reset(true);
            }
            renderer.draw();
            fireEvent(chart, "redraw");
            if (isHiddenChart) {
                chart.cloneRenderTo(true);
            }
            each(afterRedraw, function(callback) {
                callback.call();
            });
        },
        showLoading: function(str) {
            var chart = this, options = chart.options, loadingDiv = chart.loadingDiv;
            var loadingOptions = options.loading;
            if (!loadingDiv) {
                chart.loadingDiv = loadingDiv = createElement(DIV, {
                    className: PREFIX + "loading"
                }, extend(loadingOptions.style, {
                    zIndex: 10,
                    display: NONE
                }), chart.container);
                chart.loadingSpan = createElement("span", null, loadingOptions.labelStyle, loadingDiv);
            }
            chart.loadingSpan.innerHTML = str || options.lang.loading;
            if (!chart.loadingShown) {
                css(loadingDiv, {
                    opacity: 0,
                    display: "",
                    left: chart.plotLeft + PX,
                    top: chart.plotTop + PX,
                    width: chart.plotWidth + PX,
                    height: chart.plotHeight + PX
                });
                animate(loadingDiv, {
                    opacity: loadingOptions.style.opacity
                }, {
                    duration: loadingOptions.showDuration || 0
                });
                chart.loadingShown = true;
            }
        },
        hideLoading: function() {
            var options = this.options, loadingDiv = this.loadingDiv;
            if (loadingDiv) {
                animate(loadingDiv, {
                    opacity: 0
                }, {
                    duration: options.loading.hideDuration || 100,
                    complete: function() {
                        css(loadingDiv, {
                            display: NONE
                        });
                    }
                });
            }
            this.loadingShown = false;
        },
        get: function(id) {
            var chart = this, axes = chart.axes, series = chart.series;
            var i, j, points;
            for (i = 0; i < axes.length; i++) {
                if (axes[i].options.id === id) {
                    return axes[i];
                }
            }
            for (i = 0; i < series.length; i++) {
                if (series[i].options.id === id) {
                    return series[i];
                }
            }
            for (i = 0; i < series.length; i++) {
                points = series[i].points || [];
                for (j = 0; j < points.length; j++) {
                    if (points[j].id === id) {
                        return points[j];
                    }
                }
            }
            return null;
        },
        getAxes: function() {
            var chart = this, options = this.options, xAxisOptions = options.xAxis = splat(options.xAxis || {}), yAxisOptions = options.yAxis = splat(options.yAxis || {}), optionsArray, axis;
            each(xAxisOptions, function(axis, i) {
                axis.index = i;
                axis.isX = true;
            });
            each(yAxisOptions, function(axis, i) {
                axis.index = i;
            });
            optionsArray = xAxisOptions.concat(yAxisOptions);
            each(optionsArray, function(axisOptions) {
                axis = new Axis(chart, axisOptions);
            });
            chart.adjustTickAmounts();
        },
        getSelectedPoints: function() {
            var points = [];
            each(this.series, function(serie) {
                points = points.concat(grep(serie.points || [], function(point) {
                    return point.selected;
                }));
            });
            return points;
        },
        getSelectedSeries: function() {
            return grep(this.series, function(serie) {
                return serie.selected;
            });
        },
        getStacks: function() {
            var chart = this;
            each(chart.yAxis, function(axis) {
                if (axis.stacks && axis.hasVisibleSeries) {
                    axis.oldStacks = axis.stacks;
                }
            });
            each(chart.series, function(series) {
                if (series.options.stacking && (series.visible === true || chart.options.chart.ignoreHiddenSeries === false)) {
                    series.stackKey = series.type + pick(series.options.stack, "");
                }
            });
        },
        showResetZoom: function() {
            var chart = this, lang = defaultOptions.lang, btnOptions = chart.options.chart.resetZoomButton, theme = btnOptions.theme, states = theme.states, alignTo = btnOptions.relativeTo === "chart" ? null : "plotBox";
            this.resetZoomButton = chart.renderer.button(lang.resetZoom, null, null, function() {
                chart.zoomOut();
            }, theme, states && states.hover).attr({
                align: btnOptions.position.align,
                title: lang.resetZoomTitle
            }).add().align(btnOptions.position, false, alignTo);
        },
        zoomOut: function() {
            var chart = this;
            fireEvent(chart, "selection", {
                resetSelection: true
            }, function() {
                chart.zoom();
            });
        },
        zoom: function(event) {
            var chart = this, hasZoomed, pointer = chart.pointer, displayButton = false, resetZoomButton;
            if (!event || event.resetSelection) {
                each(chart.axes, function(axis) {
                    hasZoomed = axis.zoom();
                });
            } else {
                each(event.xAxis.concat(event.yAxis), function(axisData) {
                    var axis = axisData.axis, isXAxis = axis.isXAxis;
                    if (pointer[isXAxis ? "zoomX" : "zoomY"] || pointer[isXAxis ? "pinchX" : "pinchY"]) {
                        hasZoomed = axis.zoom(axisData.min, axisData.max);
                        if (axis.displayBtn) {
                            displayButton = true;
                        }
                    }
                });
            }
            resetZoomButton = chart.resetZoomButton;
            if (displayButton && !resetZoomButton) {
                chart.showResetZoom();
            } else if (!displayButton && isObject(resetZoomButton)) {
                chart.resetZoomButton = resetZoomButton.destroy();
            }
            if (hasZoomed) {
                chart.redraw(pick(chart.options.chart.animation, event && event.animation, chart.pointCount < 100));
            }
        },
        pan: function(e, panning) {
            var chart = this, hoverPoints = chart.hoverPoints, doRedraw;
            if (hoverPoints) {
                each(hoverPoints, function(point) {
                    point.setState();
                });
            }
            each(panning === "xy" ? [ 1, 0 ] : [ 1 ], function(isX) {
                var mousePos = e[isX ? "chartX" : "chartY"], axis = chart[isX ? "xAxis" : "yAxis"][0], startPos = chart[isX ? "mouseDownX" : "mouseDownY"], halfPointRange = (axis.pointRange || 0) / 2, extremes = axis.getExtremes(), newMin = axis.toValue(startPos - mousePos, true) + halfPointRange, newMax = axis.toValue(startPos + chart[isX ? "plotWidth" : "plotHeight"] - mousePos, true) - halfPointRange;
                if (axis.series.length && newMin > mathMin(extremes.dataMin, extremes.min) && newMax < mathMax(extremes.dataMax, extremes.max)) {
                    axis.setExtremes(newMin, newMax, false, false, {
                        trigger: "pan"
                    });
                    doRedraw = true;
                }
                chart[isX ? "mouseDownX" : "mouseDownY"] = mousePos;
            });
            if (doRedraw) {
                chart.redraw(false);
            }
            css(chart.container, {
                cursor: "move"
            });
        },
        setTitle: function(titleOptions, subtitleOptions) {
            var chart = this, options = chart.options, chartTitleOptions, chartSubtitleOptions;
            chartTitleOptions = options.title = merge(options.title, titleOptions);
            chartSubtitleOptions = options.subtitle = merge(options.subtitle, subtitleOptions);
            each([ [ "title", titleOptions, chartTitleOptions ], [ "subtitle", subtitleOptions, chartSubtitleOptions ] ], function(arr) {
                var name = arr[0], title = chart[name], titleOptions = arr[1], chartTitleOptions = arr[2];
                if (title && titleOptions) {
                    chart[name] = title = title.destroy();
                }
                if (chartTitleOptions && chartTitleOptions.text && !title) {
                    chart[name] = chart.renderer.text(chartTitleOptions.text, 0, 0, chartTitleOptions.useHTML).attr({
                        align: chartTitleOptions.align,
                        "class": PREFIX + name,
                        zIndex: chartTitleOptions.zIndex || 4
                    }).css(chartTitleOptions.style).add();
                }
            });
            chart.layOutTitles();
        },
        layOutTitles: function() {
            var titleOffset = 0, title = this.title, subtitle = this.subtitle, options = this.options, titleOptions = options.title, subtitleOptions = options.subtitle, autoWidth = this.spacingBox.width - 44;
            if (title) {
                title.css({
                    width: (titleOptions.width || autoWidth) + PX
                }).align(extend({
                    y: 15
                }, titleOptions), false, "spacingBox");
                if (!titleOptions.floating && !titleOptions.verticalAlign) {
                    titleOffset = title.getBBox().height;
                    if (titleOffset >= 18 && titleOffset <= 25) {
                        titleOffset = 15;
                    }
                }
            }
            if (subtitle) {
                subtitle.css({
                    width: (subtitleOptions.width || autoWidth) + PX
                }).align(extend({
                    y: titleOffset + titleOptions.margin
                }, subtitleOptions), false, "spacingBox");
                if (!subtitleOptions.floating && !subtitleOptions.verticalAlign) {
                    titleOffset = mathCeil(titleOffset + subtitle.getBBox().height);
                }
            }
            this.titleOffset = titleOffset;
        },
        getChartSize: function() {
            var chart = this, optionsChart = chart.options.chart, renderTo = chart.renderToClone || chart.renderTo;
            chart.containerWidth = adapterRun(renderTo, "width");
            chart.containerHeight = adapterRun(renderTo, "height");
            chart.chartWidth = mathMax(0, optionsChart.width || chart.containerWidth || 600);
            chart.chartHeight = mathMax(0, pick(optionsChart.height, chart.containerHeight > 19 ? chart.containerHeight : 400));
        },
        cloneRenderTo: function(revert) {
            var clone = this.renderToClone, container = this.container;
            if (revert) {
                if (clone) {
                    this.renderTo.appendChild(container);
                    discardElement(clone);
                    delete this.renderToClone;
                }
            } else {
                if (container && container.parentNode === this.renderTo) {
                    this.renderTo.removeChild(container);
                }
                this.renderToClone = clone = this.renderTo.cloneNode(0);
                css(clone, {
                    position: ABSOLUTE,
                    top: "-9999px",
                    display: "block"
                });
                doc.body.appendChild(clone);
                if (container) {
                    clone.appendChild(container);
                }
            }
        },
        getContainer: function() {
            var chart = this, container, optionsChart = chart.options.chart, chartWidth, chartHeight, renderTo, indexAttrName = "data-highcharts-chart", oldChartIndex, containerId;
            chart.renderTo = renderTo = optionsChart.renderTo;
            containerId = PREFIX + idCounter++;
            if (isString(renderTo)) {
                chart.renderTo = renderTo = doc.getElementById(renderTo);
            }
            if (!renderTo) {
                error(13, true);
            }
            oldChartIndex = pInt(attr(renderTo, indexAttrName));
            if (!isNaN(oldChartIndex) && charts[oldChartIndex]) {
                charts[oldChartIndex].destroy();
            }
            attr(renderTo, indexAttrName, chart.index);
            renderTo.innerHTML = "";
            if (!renderTo.offsetWidth) {
                chart.cloneRenderTo();
            }
            chart.getChartSize();
            chartWidth = chart.chartWidth;
            chartHeight = chart.chartHeight;
            chart.container = container = createElement(DIV, {
                className: PREFIX + "container" + (optionsChart.className ? " " + optionsChart.className : ""),
                id: containerId
            }, extend({
                position: RELATIVE,
                overflow: HIDDEN,
                width: chartWidth + PX,
                height: chartHeight + PX,
                textAlign: "left",
                lineHeight: "normal",
                zIndex: 0,
                "-webkit-tap-highlight-color": "rgba(0,0,0,0)"
            }, optionsChart.style), chart.renderToClone || renderTo);
            chart._cursor = container.style.cursor;
            chart.renderer = optionsChart.forExport ? new SVGRenderer(container, chartWidth, chartHeight, true) : new Renderer(container, chartWidth, chartHeight);
            if (useCanVG) {
                chart.renderer.create(chart, container, chartWidth, chartHeight);
            }
        },
        getMargins: function() {
            var chart = this, optionsChart = chart.options.chart, spacingTop = optionsChart.spacingTop, spacingRight = optionsChart.spacingRight, spacingBottom = optionsChart.spacingBottom, spacingLeft = optionsChart.spacingLeft, axisOffset, legend = chart.legend, optionsMarginTop = chart.optionsMarginTop, optionsMarginLeft = chart.optionsMarginLeft, optionsMarginRight = chart.optionsMarginRight, optionsMarginBottom = chart.optionsMarginBottom, legendOptions = chart.options.legend, legendMargin = pick(legendOptions.margin, 10), legendX = legendOptions.x, legendY = legendOptions.y, align = legendOptions.align, verticalAlign = legendOptions.verticalAlign, titleOffset = chart.titleOffset;
            chart.resetMargins();
            axisOffset = chart.axisOffset;
            if (titleOffset && !defined(optionsMarginTop)) {
                chart.plotTop = mathMax(chart.plotTop, titleOffset + chart.options.title.margin + spacingTop);
            }
            if (legend.display && !legendOptions.floating) {
                if (align === "right") {
                    if (!defined(optionsMarginRight)) {
                        chart.marginRight = mathMax(chart.marginRight, legend.legendWidth - legendX + legendMargin + spacingRight);
                    }
                } else if (align === "left") {
                    if (!defined(optionsMarginLeft)) {
                        chart.plotLeft = mathMax(chart.plotLeft, legend.legendWidth + legendX + legendMargin + spacingLeft);
                    }
                } else if (verticalAlign === "top") {
                    if (!defined(optionsMarginTop)) {
                        chart.plotTop = mathMax(chart.plotTop, legend.legendHeight + legendY + legendMargin + spacingTop);
                    }
                } else if (verticalAlign === "bottom") {
                    if (!defined(optionsMarginBottom)) {
                        chart.marginBottom = mathMax(chart.marginBottom, legend.legendHeight - legendY + legendMargin + spacingBottom);
                    }
                }
            }
            if (chart.extraBottomMargin) {
                chart.marginBottom += chart.extraBottomMargin;
            }
            if (chart.extraTopMargin) {
                chart.plotTop += chart.extraTopMargin;
            }
            if (chart.hasCartesianSeries) {
                each(chart.axes, function(axis) {
                    axis.getOffset();
                });
            }
            if (!defined(optionsMarginLeft)) {
                chart.plotLeft += axisOffset[3];
            }
            if (!defined(optionsMarginTop)) {
                chart.plotTop += axisOffset[0];
            }
            if (!defined(optionsMarginBottom)) {
                chart.marginBottom += axisOffset[2];
            }
            if (!defined(optionsMarginRight)) {
                chart.marginRight += axisOffset[1];
            }
            chart.setChartSize();
        },
        initReflow: function() {
            var chart = this, optionsChart = chart.options.chart, renderTo = chart.renderTo, reflowTimeout;
            function reflow(e) {
                var width = optionsChart.width || adapterRun(renderTo, "width"), height = optionsChart.height || adapterRun(renderTo, "height"), target = e ? e.target : win;
                if (!chart.hasUserSize && width && height && (target === win || target === doc)) {
                    if (width !== chart.containerWidth || height !== chart.containerHeight) {
                        clearTimeout(reflowTimeout);
                        chart.reflowTimeout = reflowTimeout = setTimeout(function() {
                            if (chart.container) {
                                chart.setSize(width, height, false);
                                chart.hasUserSize = null;
                            }
                        }, 100);
                    }
                    chart.containerWidth = width;
                    chart.containerHeight = height;
                }
            }
            addEvent(win, "resize", reflow);
            addEvent(chart, "destroy", function() {
                removeEvent(win, "resize", reflow);
            });
        },
        setSize: function(width, height, animation) {
            var chart = this, chartWidth, chartHeight, fireEndResize;
            chart.isResizing += 1;
            fireEndResize = function() {
                if (chart) {
                    fireEvent(chart, "endResize", null, function() {
                        chart.isResizing -= 1;
                    });
                }
            };
            setAnimation(animation, chart);
            chart.oldChartHeight = chart.chartHeight;
            chart.oldChartWidth = chart.chartWidth;
            if (defined(width)) {
                chart.chartWidth = chartWidth = mathMax(0, mathRound(width));
                chart.hasUserSize = !!chartWidth;
            }
            if (defined(height)) {
                chart.chartHeight = chartHeight = mathMax(0, mathRound(height));
            }
            css(chart.container, {
                width: chartWidth + PX,
                height: chartHeight + PX
            });
            chart.setChartSize(true);
            chart.renderer.setSize(chartWidth, chartHeight, animation);
            chart.maxTicks = null;
            each(chart.axes, function(axis) {
                axis.isDirty = true;
                axis.setScale();
            });
            each(chart.series, function(serie) {
                serie.isDirty = true;
            });
            chart.isDirtyLegend = true;
            chart.isDirtyBox = true;
            chart.getMargins();
            chart.redraw(animation);
            chart.oldChartHeight = null;
            fireEvent(chart, "resize");
            if (globalAnimation === false) {
                fireEndResize();
            } else {
                setTimeout(fireEndResize, globalAnimation && globalAnimation.duration || 500);
            }
        },
        setChartSize: function(skipAxes) {
            var chart = this, inverted = chart.inverted, renderer = chart.renderer, chartWidth = chart.chartWidth, chartHeight = chart.chartHeight, optionsChart = chart.options.chart, spacingTop = optionsChart.spacingTop, spacingRight = optionsChart.spacingRight, spacingBottom = optionsChart.spacingBottom, spacingLeft = optionsChart.spacingLeft, clipOffset = chart.clipOffset, clipX, clipY, plotLeft, plotTop, plotWidth, plotHeight, plotBorderWidth;
            chart.plotLeft = plotLeft = mathRound(chart.plotLeft);
            chart.plotTop = plotTop = mathRound(chart.plotTop);
            chart.plotWidth = plotWidth = mathMax(0, mathRound(chartWidth - plotLeft - chart.marginRight));
            chart.plotHeight = plotHeight = mathMax(0, mathRound(chartHeight - plotTop - chart.marginBottom));
            chart.plotSizeX = inverted ? plotHeight : plotWidth;
            chart.plotSizeY = inverted ? plotWidth : plotHeight;
            chart.plotBorderWidth = optionsChart.plotBorderWidth || 0;
            chart.spacingBox = renderer.spacingBox = {
                x: spacingLeft,
                y: spacingTop,
                width: chartWidth - spacingLeft - spacingRight,
                height: chartHeight - spacingTop - spacingBottom
            };
            chart.plotBox = renderer.plotBox = {
                x: plotLeft,
                y: plotTop,
                width: plotWidth,
                height: plotHeight
            };
            plotBorderWidth = 2 * mathFloor(chart.plotBorderWidth / 2);
            clipX = mathCeil(mathMax(plotBorderWidth, clipOffset[3]) / 2);
            clipY = mathCeil(mathMax(plotBorderWidth, clipOffset[0]) / 2);
            chart.clipBox = {
                x: clipX,
                y: clipY,
                width: mathFloor(chart.plotSizeX - mathMax(plotBorderWidth, clipOffset[1]) / 2 - clipX),
                height: mathFloor(chart.plotSizeY - mathMax(plotBorderWidth, clipOffset[2]) / 2 - clipY)
            };
            if (!skipAxes) {
                each(chart.axes, function(axis) {
                    axis.setAxisSize();
                    axis.setAxisTranslation();
                });
            }
        },
        resetMargins: function() {
            var chart = this, optionsChart = chart.options.chart, spacingTop = optionsChart.spacingTop, spacingRight = optionsChart.spacingRight, spacingBottom = optionsChart.spacingBottom, spacingLeft = optionsChart.spacingLeft;
            chart.plotTop = pick(chart.optionsMarginTop, spacingTop);
            chart.marginRight = pick(chart.optionsMarginRight, spacingRight);
            chart.marginBottom = pick(chart.optionsMarginBottom, spacingBottom);
            chart.plotLeft = pick(chart.optionsMarginLeft, spacingLeft);
            chart.axisOffset = [ 0, 0, 0, 0 ];
            chart.clipOffset = [ 0, 0, 0, 0 ];
        },
        drawChartBox: function() {
            var chart = this, optionsChart = chart.options.chart, renderer = chart.renderer, chartWidth = chart.chartWidth, chartHeight = chart.chartHeight, chartBackground = chart.chartBackground, plotBackground = chart.plotBackground, plotBorder = chart.plotBorder, plotBGImage = chart.plotBGImage, chartBorderWidth = optionsChart.borderWidth || 0, chartBackgroundColor = optionsChart.backgroundColor, plotBackgroundColor = optionsChart.plotBackgroundColor, plotBackgroundImage = optionsChart.plotBackgroundImage, plotBorderWidth = optionsChart.plotBorderWidth || 0, mgn, bgAttr, plotLeft = chart.plotLeft, plotTop = chart.plotTop, plotWidth = chart.plotWidth, plotHeight = chart.plotHeight, plotBox = chart.plotBox, clipRect = chart.clipRect, clipBox = chart.clipBox;
            mgn = chartBorderWidth + (optionsChart.shadow ? 8 : 0);
            if (chartBorderWidth || chartBackgroundColor) {
                if (!chartBackground) {
                    bgAttr = {
                        fill: chartBackgroundColor || NONE
                    };
                    if (chartBorderWidth) {
                        bgAttr.stroke = optionsChart.borderColor;
                        bgAttr["stroke-width"] = chartBorderWidth;
                    }
                    chart.chartBackground = renderer.rect(mgn / 2, mgn / 2, chartWidth - mgn, chartHeight - mgn, optionsChart.borderRadius, chartBorderWidth).attr(bgAttr).add().shadow(optionsChart.shadow);
                } else {
                    chartBackground.animate(chartBackground.crisp(null, null, null, chartWidth - mgn, chartHeight - mgn));
                }
            }
            if (plotBackgroundColor) {
                if (!plotBackground) {
                    chart.plotBackground = renderer.rect(plotLeft, plotTop, plotWidth, plotHeight, 0).attr({
                        fill: plotBackgroundColor
                    }).add().shadow(optionsChart.plotShadow);
                } else {
                    plotBackground.animate(plotBox);
                }
            }
            if (plotBackgroundImage) {
                if (!plotBGImage) {
                    chart.plotBGImage = renderer.image(plotBackgroundImage, plotLeft, plotTop, plotWidth, plotHeight).add();
                } else {
                    plotBGImage.animate(plotBox);
                }
            }
            if (!clipRect) {
                chart.clipRect = renderer.clipRect(clipBox);
            } else {
                clipRect.animate({
                    width: clipBox.width,
                    height: clipBox.height
                });
            }
            if (plotBorderWidth) {
                if (!plotBorder) {
                    chart.plotBorder = renderer.rect(plotLeft, plotTop, plotWidth, plotHeight, 0, -plotBorderWidth).attr({
                        stroke: optionsChart.plotBorderColor,
                        "stroke-width": plotBorderWidth,
                        zIndex: 1
                    }).add();
                } else {
                    plotBorder.animate(plotBorder.crisp(null, plotLeft, plotTop, plotWidth, plotHeight));
                }
            }
            chart.isDirtyBox = false;
        },
        propFromSeries: function() {
            var chart = this, optionsChart = chart.options.chart, klass, seriesOptions = chart.options.series, i, value;
            each([ "inverted", "angular", "polar" ], function(key) {
                klass = seriesTypes[optionsChart.type || optionsChart.defaultSeriesType];
                value = chart[key] || optionsChart[key] || klass && klass.prototype[key];
                i = seriesOptions && seriesOptions.length;
                while (!value && i--) {
                    klass = seriesTypes[seriesOptions[i].type];
                    if (klass && klass.prototype[key]) {
                        value = true;
                    }
                }
                chart[key] = value;
            });
        },
        linkSeries: function() {
            var chart = this, chartSeries = chart.series;
            each(chartSeries, function(series) {
                series.linkedSeries.length = 0;
            });
            each(chartSeries, function(series) {
                var linkedTo = series.options.linkedTo;
                if (isString(linkedTo)) {
                    if (linkedTo === ":previous") {
                        linkedTo = chart.series[series.index - 1];
                    } else {
                        linkedTo = chart.get(linkedTo);
                    }
                    if (linkedTo) {
                        linkedTo.linkedSeries.push(series);
                        series.linkedParent = linkedTo;
                    }
                }
            });
        },
        render: function() {
            var chart = this, axes = chart.axes, renderer = chart.renderer, options = chart.options;
            var labels = options.labels, credits = options.credits, creditsHref;
            chart.setTitle();
            chart.legend = new Legend(chart, options.legend);
            chart.getStacks();
            each(axes, function(axis) {
                axis.setScale();
            });
            chart.getMargins();
            chart.maxTicks = null;
            each(axes, function(axis) {
                axis.setTickPositions(true);
                axis.setMaxTicks();
            });
            chart.adjustTickAmounts();
            chart.getMargins();
            chart.drawChartBox();
            if (chart.hasCartesianSeries) {
                each(axes, function(axis) {
                    axis.render();
                });
            }
            if (!chart.seriesGroup) {
                chart.seriesGroup = renderer.g("series-group").attr({
                    zIndex: 3
                }).add();
            }
            each(chart.series, function(serie) {
                serie.translate();
                serie.setTooltipPoints();
                serie.render();
            });
            if (labels.items) {
                each(labels.items, function(label) {
                    var style = extend(labels.style, label.style), x = pInt(style.left) + chart.plotLeft, y = pInt(style.top) + chart.plotTop + 12;
                    delete style.left;
                    delete style.top;
                    renderer.text(label.html, x, y).attr({
                        zIndex: 2
                    }).css(style).add();
                });
            }
            if (credits.enabled && !chart.credits) {
                creditsHref = credits.href;
                chart.credits = renderer.text(credits.text, 0, 0).on("click", function() {
                    if (creditsHref) {
                        location.href = creditsHref;
                    }
                }).attr({
                    align: credits.position.align,
                    zIndex: 8
                }).css(credits.style).add().align(credits.position);
            }
            chart.hasRendered = true;
        },
        destroy: function() {
            var chart = this, axes = chart.axes, series = chart.series, container = chart.container, i, parentNode = container && container.parentNode;
            fireEvent(chart, "destroy");
            charts[chart.index] = UNDEFINED;
            chart.renderTo.removeAttribute("data-highcharts-chart");
            removeEvent(chart);
            i = axes.length;
            while (i--) {
                axes[i] = axes[i].destroy();
            }
            i = series.length;
            while (i--) {
                series[i] = series[i].destroy();
            }
            each([ "title", "subtitle", "chartBackground", "plotBackground", "plotBGImage", "plotBorder", "seriesGroup", "clipRect", "credits", "pointer", "scroller", "rangeSelector", "legend", "resetZoomButton", "tooltip", "renderer" ], function(name) {
                var prop = chart[name];
                if (prop && prop.destroy) {
                    chart[name] = prop.destroy();
                }
            });
            if (container) {
                container.innerHTML = "";
                removeEvent(container);
                if (parentNode) {
                    discardElement(container);
                }
            }
            for (i in chart) {
                delete chart[i];
            }
        },
        isReadyToRender: function() {
            var chart = this;
            if (!hasSVG && win == win.top && doc.readyState !== "complete" || useCanVG && !win.canvg) {
                if (useCanVG) {
                    CanVGController.push(function() {
                        chart.firstRender();
                    }, chart.options.global.canvasToolsURL);
                } else {
                    doc.attachEvent("onreadystatechange", function() {
                        doc.detachEvent("onreadystatechange", chart.firstRender);
                        if (doc.readyState === "complete") {
                            chart.firstRender();
                        }
                    });
                }
                return false;
            }
            return true;
        },
        firstRender: function() {
            var chart = this, options = chart.options, callback = chart.callback;
            if (!chart.isReadyToRender()) {
                return;
            }
            chart.getContainer();
            fireEvent(chart, "init");
            chart.resetMargins();
            chart.setChartSize();
            chart.propFromSeries();
            chart.getAxes();
            each(options.series || [], function(serieOptions) {
                chart.initSeries(serieOptions);
            });
            chart.linkSeries();
            fireEvent(chart, "beforeRender");
            chart.pointer = new Pointer(chart, options);
            chart.render();
            chart.renderer.draw();
            if (callback) {
                callback.apply(chart, [ chart ]);
            }
            each(chart.callbacks, function(fn) {
                fn.apply(chart, [ chart ]);
            });
            chart.cloneRenderTo(true);
            fireEvent(chart, "load");
        }
    };
    Chart.prototype.callbacks = [];
    var Point = function() {};
    Point.prototype = {
        init: function(series, options, x) {
            var point = this, colors;
            point.series = series;
            point.applyOptions(options, x);
            point.pointAttr = {};
            if (series.options.colorByPoint) {
                colors = series.options.colors || series.chart.options.colors;
                point.color = point.color || colors[series.colorCounter++];
                if (series.colorCounter === colors.length) {
                    series.colorCounter = 0;
                }
            }
            series.chart.pointCount++;
            return point;
        },
        applyOptions: function(options, x) {
            var point = this, series = point.series, pointValKey = series.pointValKey;
            options = Point.prototype.optionsToObject.call(this, options);
            extend(point, options);
            point.options = point.options ? extend(point.options, options) : options;
            if (pointValKey) {
                point.y = point[pointValKey];
            }
            if (point.x === UNDEFINED && series) {
                point.x = x === UNDEFINED ? series.autoIncrement() : x;
            }
            return point;
        },
        optionsToObject: function(options) {
            var ret, series = this.series, pointArrayMap = series.pointArrayMap || [ "y" ], valueCount = pointArrayMap.length, firstItemType, i = 0, j = 0;
            if (typeof options === "number" || options === null) {
                ret = {
                    y: options
                };
            } else if (isArray(options)) {
                ret = {};
                if (options.length > valueCount) {
                    firstItemType = typeof options[0];
                    if (firstItemType === "string") {
                        ret.name = options[0];
                    } else if (firstItemType === "number") {
                        ret.x = options[0];
                    }
                    i++;
                }
                while (j < valueCount) {
                    ret[pointArrayMap[j++]] = options[i++];
                }
            } else if (typeof options === "object") {
                ret = options;
                if (options.dataLabels) {
                    series._hasPointLabels = true;
                }
                if (options.marker) {
                    series._hasPointMarkers = true;
                }
            }
            return ret;
        },
        destroy: function() {
            var point = this, series = point.series, chart = series.chart, hoverPoints = chart.hoverPoints, prop;
            chart.pointCount--;
            if (hoverPoints) {
                point.setState();
                erase(hoverPoints, point);
                if (!hoverPoints.length) {
                    chart.hoverPoints = null;
                }
            }
            if (point === chart.hoverPoint) {
                point.onMouseOut();
            }
            if (point.graphic || point.dataLabel) {
                removeEvent(point);
                point.destroyElements();
            }
            if (point.legendItem) {
                chart.legend.destroyItem(point);
            }
            for (prop in point) {
                point[prop] = null;
            }
        },
        destroyElements: function() {
            var point = this, props = [ "graphic", "dataLabel", "dataLabelUpper", "group", "connector", "shadowGroup" ], prop, i = 6;
            while (i--) {
                prop = props[i];
                if (point[prop]) {
                    point[prop] = point[prop].destroy();
                }
            }
        },
        getLabelConfig: function() {
            var point = this;
            return {
                x: point.category,
                y: point.y,
                key: point.name || point.category,
                series: point.series,
                point: point,
                percentage: point.percentage,
                total: point.total || point.stackTotal
            };
        },
        select: function(selected, accumulate) {
            var point = this, series = point.series, chart = series.chart;
            selected = pick(selected, !point.selected);
            point.firePointEvent(selected ? "select" : "unselect", {
                accumulate: accumulate
            }, function() {
                point.selected = point.options.selected = selected;
                series.options.data[inArray(point, series.data)] = point.options;
                point.setState(selected && SELECT_STATE);
                if (!accumulate) {
                    each(chart.getSelectedPoints(), function(loopPoint) {
                        if (loopPoint.selected && loopPoint !== point) {
                            loopPoint.selected = loopPoint.options.selected = false;
                            series.options.data[inArray(loopPoint, series.data)] = loopPoint.options;
                            loopPoint.setState(NORMAL_STATE);
                            loopPoint.firePointEvent("unselect");
                        }
                    });
                }
            });
        },
        onMouseOver: function(e) {
            var point = this, series = point.series, chart = series.chart, tooltip = chart.tooltip, hoverPoint = chart.hoverPoint;
            if (hoverPoint && hoverPoint !== point) {
                hoverPoint.onMouseOut();
            }
            point.firePointEvent("mouseOver");
            if (tooltip && (!tooltip.shared || series.noSharedTooltip)) {
                tooltip.refresh(point, e);
            }
            point.setState(HOVER_STATE);
            chart.hoverPoint = point;
        },
        onMouseOut: function() {
            var chart = this.series.chart, hoverPoints = chart.hoverPoints;
            if (!hoverPoints || inArray(this, hoverPoints) === -1) {
                this.firePointEvent("mouseOut");
                this.setState();
                chart.hoverPoint = null;
            }
        },
        tooltipFormatter: function(pointFormat) {
            var series = this.series, seriesTooltipOptions = series.tooltipOptions, valueDecimals = pick(seriesTooltipOptions.valueDecimals, ""), valuePrefix = seriesTooltipOptions.valuePrefix || "", valueSuffix = seriesTooltipOptions.valueSuffix || "";
            each(series.pointArrayMap || [ "y" ], function(key) {
                key = "{point." + key;
                if (valuePrefix || valueSuffix) {
                    pointFormat = pointFormat.replace(key + "}", valuePrefix + key + "}" + valueSuffix);
                }
                pointFormat = pointFormat.replace(key + "}", key + ":,." + valueDecimals + "f}");
            });
            return format(pointFormat, {
                point: this,
                series: this.series
            });
        },
        update: function(options, redraw, animation) {
            var point = this, series = point.series, graphic = point.graphic, i, data = series.data, chart = series.chart, seriesOptions = series.options;
            redraw = pick(redraw, true);
            point.firePointEvent("update", {
                options: options
            }, function() {
                point.applyOptions(options);
                if (isObject(options)) {
                    series.getAttribs();
                    if (graphic) {
                        if (options.marker && options.marker.symbol) {
                            point.graphic = graphic.destroy();
                        } else {
                            graphic.attr(point.pointAttr[series.state]);
                        }
                    }
                }
                i = inArray(point, data);
                series.xData[i] = point.x;
                series.yData[i] = series.toYData ? series.toYData(point) : point.y;
                series.zData[i] = point.z;
                seriesOptions.data[i] = point.options;
                series.isDirty = series.isDirtyData = chart.isDirtyBox = true;
                if (seriesOptions.legendType === "point") {
                    chart.legend.destroyItem(point);
                }
                if (redraw) {
                    chart.redraw(animation);
                }
            });
        },
        remove: function(redraw, animation) {
            var point = this, series = point.series, chart = series.chart, i, data = series.data;
            setAnimation(animation, chart);
            redraw = pick(redraw, true);
            point.firePointEvent("remove", null, function() {
                i = inArray(point, data);
                data.splice(i, 1);
                series.options.data.splice(i, 1);
                series.xData.splice(i, 1);
                series.yData.splice(i, 1);
                series.zData.splice(i, 1);
                point.destroy();
                series.isDirty = true;
                series.isDirtyData = true;
                if (redraw) {
                    chart.redraw();
                }
            });
        },
        firePointEvent: function(eventType, eventArgs, defaultFunction) {
            var point = this, series = this.series, seriesOptions = series.options;
            if (seriesOptions.point.events[eventType] || point.options && point.options.events && point.options.events[eventType]) {
                this.importEvents();
            }
            if (eventType === "click" && seriesOptions.allowPointSelect) {
                defaultFunction = function(event) {
                    point.select(null, event.ctrlKey || event.metaKey || event.shiftKey);
                };
            }
            fireEvent(this, eventType, eventArgs, defaultFunction);
        },
        importEvents: function() {
            if (!this.hasImportedEvents) {
                var point = this, options = merge(point.series.options.point, point.options), events = options.events, eventType;
                point.events = events;
                for (eventType in events) {
                    addEvent(point, eventType, events[eventType]);
                }
                this.hasImportedEvents = true;
            }
        },
        setState: function(state) {
            var point = this, plotX = point.plotX, plotY = point.plotY, series = point.series, stateOptions = series.options.states, markerOptions = defaultPlotOptions[series.type].marker && series.options.marker, normalDisabled = markerOptions && !markerOptions.enabled, markerStateOptions = markerOptions && markerOptions.states[state], stateDisabled = markerStateOptions && markerStateOptions.enabled === false, stateMarkerGraphic = series.stateMarkerGraphic, pointMarker = point.marker || {}, chart = series.chart, radius, newSymbol, pointAttr = point.pointAttr;
            state = state || NORMAL_STATE;
            if (state === point.state || point.selected && state !== SELECT_STATE || stateOptions[state] && stateOptions[state].enabled === false || state && (stateDisabled || normalDisabled && !markerStateOptions.enabled)) {
                return;
            }
            if (point.graphic) {
                radius = markerOptions && point.graphic.symbolName && pointAttr[state].r;
                point.graphic.attr(merge(pointAttr[state], radius ? {
                    x: plotX - radius,
                    y: plotY - radius,
                    width: 2 * radius,
                    height: 2 * radius
                } : {}));
            } else {
                if (state && markerStateOptions) {
                    radius = markerStateOptions.radius;
                    newSymbol = pointMarker.symbol || series.symbol;
                    if (stateMarkerGraphic && stateMarkerGraphic.currentSymbol !== newSymbol) {
                        stateMarkerGraphic = stateMarkerGraphic.destroy();
                    }
                    if (!stateMarkerGraphic) {
                        series.stateMarkerGraphic = stateMarkerGraphic = chart.renderer.symbol(newSymbol, plotX - radius, plotY - radius, 2 * radius, 2 * radius).attr(pointAttr[state]).add(series.markerGroup);
                        stateMarkerGraphic.currentSymbol = newSymbol;
                    } else {
                        stateMarkerGraphic.attr({
                            x: plotX - radius,
                            y: plotY - radius
                        });
                    }
                }
                if (stateMarkerGraphic) {
                    stateMarkerGraphic[state && chart.isInsidePlot(plotX, plotY) ? "show" : "hide"]();
                }
            }
            point.state = state;
        }
    };
    var Series = function() {};
    Series.prototype = {
        isCartesian: true,
        type: "line",
        pointClass: Point,
        sorted: true,
        requireSorting: true,
        pointAttrToOptions: {
            stroke: "lineColor",
            "stroke-width": "lineWidth",
            fill: "fillColor",
            r: "radius"
        },
        colorCounter: 0,
        init: function(chart, options) {
            var series = this, eventType, events, chartSeries = chart.series;
            series.chart = chart;
            series.options = options = series.setOptions(options);
            series.linkedSeries = [];
            series.bindAxes();
            extend(series, {
                name: options.name,
                state: NORMAL_STATE,
                pointAttr: {},
                visible: options.visible !== false,
                selected: options.selected === true
            });
            if (useCanVG) {
                options.animation = false;
            }
            events = options.events;
            for (eventType in events) {
                addEvent(series, eventType, events[eventType]);
            }
            if (events && events.click || options.point && options.point.events && options.point.events.click || options.allowPointSelect) {
                chart.runTrackerClick = true;
            }
            series.getColor();
            series.getSymbol();
            series.setData(options.data, false);
            if (series.isCartesian) {
                chart.hasCartesianSeries = true;
            }
            chartSeries.push(series);
            series._i = chartSeries.length - 1;
            stableSort(chartSeries, function(a, b) {
                return pick(a.options.index, a._i) - pick(b.options.index, a._i);
            });
            each(chartSeries, function(series, i) {
                series.index = i;
                series.name = series.name || "Series " + (i + 1);
            });
        },
        bindAxes: function() {
            var series = this, seriesOptions = series.options, chart = series.chart, axisOptions;
            if (series.isCartesian) {
                each([ "xAxis", "yAxis" ], function(AXIS) {
                    each(chart[AXIS], function(axis) {
                        axisOptions = axis.options;
                        if (seriesOptions[AXIS] === axisOptions.index || seriesOptions[AXIS] !== UNDEFINED && seriesOptions[AXIS] === axisOptions.id || seriesOptions[AXIS] === UNDEFINED && axisOptions.index === 0) {
                            axis.series.push(series);
                            series[AXIS] = axis;
                            axis.isDirty = true;
                        }
                    });
                    if (!series[AXIS]) {
                        error(18, true);
                    }
                });
            }
        },
        autoIncrement: function() {
            var series = this, options = series.options, xIncrement = series.xIncrement;
            xIncrement = pick(xIncrement, options.pointStart, 0);
            series.pointInterval = pick(series.pointInterval, options.pointInterval, 1);
            series.xIncrement = xIncrement + series.pointInterval;
            return xIncrement;
        },
        getSegments: function() {
            var series = this, lastNull = -1, segments = [], i, points = series.points, pointsLength = points.length;
            if (pointsLength) {
                if (series.options.connectNulls) {
                    i = pointsLength;
                    while (i--) {
                        if (points[i].y === null) {
                            points.splice(i, 1);
                        }
                    }
                    if (points.length) {
                        segments = [ points ];
                    }
                } else {
                    each(points, function(point, i) {
                        if (point.y === null) {
                            if (i > lastNull + 1) {
                                segments.push(points.slice(lastNull + 1, i));
                            }
                            lastNull = i;
                        } else if (i === pointsLength - 1) {
                            segments.push(points.slice(lastNull + 1, i + 1));
                        }
                    });
                }
            }
            series.segments = segments;
        },
        setOptions: function(itemOptions) {
            var chart = this.chart, chartOptions = chart.options, plotOptions = chartOptions.plotOptions, typeOptions = plotOptions[this.type], options;
            this.userOptions = itemOptions;
            options = merge(typeOptions, plotOptions.series, itemOptions);
            this.tooltipOptions = merge(chartOptions.tooltip, options.tooltip);
            if (typeOptions.marker === null) {
                delete options.marker;
            }
            return options;
        },
        getColor: function() {
            var options = this.options, userOptions = this.userOptions, defaultColors = this.chart.options.colors, counters = this.chart.counters, color, colorIndex;
            color = options.color || defaultPlotOptions[this.type].color;
            if (!color && !options.colorByPoint) {
                if (defined(userOptions._colorIndex)) {
                    colorIndex = userOptions._colorIndex;
                } else {
                    userOptions._colorIndex = counters.color;
                    colorIndex = counters.color++;
                }
                color = defaultColors[colorIndex];
            }
            this.color = color;
            counters.wrapColor(defaultColors.length);
        },
        getSymbol: function() {
            var series = this, userOptions = series.userOptions, seriesMarkerOption = series.options.marker, chart = series.chart, defaultSymbols = chart.options.symbols, counters = chart.counters, symbolIndex;
            series.symbol = seriesMarkerOption.symbol;
            if (!series.symbol) {
                if (defined(userOptions._symbolIndex)) {
                    symbolIndex = userOptions._symbolIndex;
                } else {
                    userOptions._symbolIndex = counters.symbol;
                    symbolIndex = counters.symbol++;
                }
                series.symbol = defaultSymbols[symbolIndex];
            }
            if (/^url/.test(series.symbol)) {
                seriesMarkerOption.radius = 0;
            }
            counters.wrapSymbol(defaultSymbols.length);
        },
        drawLegendSymbol: function(legend) {
            var options = this.options, markerOptions = options.marker, radius, legendOptions = legend.options, legendSymbol, symbolWidth = legendOptions.symbolWidth, renderer = this.chart.renderer, legendItemGroup = this.legendGroup, verticalCenter = legend.baseline - mathRound(renderer.fontMetrics(legendOptions.itemStyle.fontSize).b * .3), attr;
            if (options.lineWidth) {
                attr = {
                    "stroke-width": options.lineWidth
                };
                if (options.dashStyle) {
                    attr.dashstyle = options.dashStyle;
                }
                this.legendLine = renderer.path([ M, 0, verticalCenter, L, symbolWidth, verticalCenter ]).attr(attr).add(legendItemGroup);
            }
            if (markerOptions && markerOptions.enabled) {
                radius = markerOptions.radius;
                this.legendSymbol = legendSymbol = renderer.symbol(this.symbol, symbolWidth / 2 - radius, verticalCenter - radius, 2 * radius, 2 * radius).add(legendItemGroup);
                legendSymbol.isMarker = true;
            }
        },
        addPoint: function(options, redraw, shift, animation) {
            var series = this, seriesOptions = series.options, data = series.data, graph = series.graph, area = series.area, chart = series.chart, xData = series.xData, yData = series.yData, zData = series.zData, names = series.names, currentShift = graph && graph.shift || 0, dataOptions = seriesOptions.data, point;
            setAnimation(animation, chart);
            if (shift) {
                each([ graph, area, series.graphNeg, series.areaNeg ], function(shape) {
                    if (shape) {
                        shape.shift = currentShift + 1;
                    }
                });
            }
            if (area) {
                area.isArea = true;
            }
            redraw = pick(redraw, true);
            point = {
                series: series
            };
            series.pointClass.prototype.applyOptions.apply(point, [ options ]);
            xData.push(point.x);
            yData.push(series.toYData ? series.toYData(point) : point.y);
            zData.push(point.z);
            if (names) {
                names[point.x] = point.name;
            }
            dataOptions.push(options);
            if (seriesOptions.legendType === "point") {
                series.generatePoints();
            }
            if (shift) {
                if (data[0] && data[0].remove) {
                    data[0].remove(false);
                } else {
                    data.shift();
                    xData.shift();
                    yData.shift();
                    zData.shift();
                    dataOptions.shift();
                }
            }
            series.isDirty = true;
            series.isDirtyData = true;
            if (redraw) {
                series.getAttribs();
                chart.redraw();
            }
        },
        setData: function(data, redraw) {
            var series = this, oldData = series.points, options = series.options, chart = series.chart, firstPoint = null, xAxis = series.xAxis, names = xAxis && xAxis.categories && !xAxis.categories.length ? [] : null, i;
            series.xIncrement = null;
            series.pointRange = xAxis && xAxis.categories ? 1 : options.pointRange;
            series.colorCounter = 0;
            var xData = [], yData = [], zData = [], dataLength = data ? data.length : [], turboThreshold = pick(options.turboThreshold, 1e3), pt, pointArrayMap = series.pointArrayMap, valueCount = pointArrayMap && pointArrayMap.length, hasToYData = !!series.toYData;
            if (turboThreshold && dataLength > turboThreshold) {
                i = 0;
                while (firstPoint === null && i < dataLength) {
                    firstPoint = data[i];
                    i++;
                }
                if (isNumber(firstPoint)) {
                    var x = pick(options.pointStart, 0), pointInterval = pick(options.pointInterval, 1);
                    for (i = 0; i < dataLength; i++) {
                        xData[i] = x;
                        yData[i] = data[i];
                        x += pointInterval;
                    }
                    series.xIncrement = x;
                } else if (isArray(firstPoint)) {
                    if (valueCount) {
                        for (i = 0; i < dataLength; i++) {
                            pt = data[i];
                            xData[i] = pt[0];
                            yData[i] = pt.slice(1, valueCount + 1);
                        }
                    } else {
                        for (i = 0; i < dataLength; i++) {
                            pt = data[i];
                            xData[i] = pt[0];
                            yData[i] = pt[1];
                        }
                    }
                } else {
                    error(12);
                }
            } else {
                for (i = 0; i < dataLength; i++) {
                    if (data[i] !== UNDEFINED) {
                        pt = {
                            series: series
                        };
                        series.pointClass.prototype.applyOptions.apply(pt, [ data[i] ]);
                        xData[i] = pt.x;
                        yData[i] = hasToYData ? series.toYData(pt) : pt.y;
                        zData[i] = pt.z;
                        if (names && pt.name) {
                            names[pt.x] = pt.name;
                        }
                    }
                }
            }
            if (isString(yData[0])) {
                error(14, true);
            }
            series.data = [];
            series.options.data = data;
            series.xData = xData;
            series.yData = yData;
            series.zData = zData;
            series.names = names;
            i = oldData && oldData.length || 0;
            while (i--) {
                if (oldData[i] && oldData[i].destroy) {
                    oldData[i].destroy();
                }
            }
            if (xAxis) {
                xAxis.minRange = xAxis.userMinRange;
            }
            series.isDirty = series.isDirtyData = chart.isDirtyBox = true;
            if (pick(redraw, true)) {
                chart.redraw(false);
            }
        },
        remove: function(redraw, animation) {
            var series = this, chart = series.chart;
            redraw = pick(redraw, true);
            if (!series.isRemoving) {
                series.isRemoving = true;
                fireEvent(series, "remove", null, function() {
                    series.destroy();
                    chart.isDirtyLegend = chart.isDirtyBox = true;
                    chart.linkSeries();
                    if (redraw) {
                        chart.redraw(animation);
                    }
                });
            }
            series.isRemoving = false;
        },
        processData: function(force) {
            var series = this, processedXData = series.xData, processedYData = series.yData, dataLength = processedXData.length, croppedData, cropStart = 0, cropped, distance, closestPointRange, xAxis = series.xAxis, i, options = series.options, cropThreshold = options.cropThreshold, isCartesian = series.isCartesian;
            if (isCartesian && !series.isDirty && !xAxis.isDirty && !series.yAxis.isDirty && !force) {
                return false;
            }
            if (isCartesian && series.sorted && (!cropThreshold || dataLength > cropThreshold || series.forceCrop)) {
                var min = xAxis.min, max = xAxis.max;
                if (processedXData[dataLength - 1] < min || processedXData[0] > max) {
                    processedXData = [];
                    processedYData = [];
                } else if (processedXData[0] < min || processedXData[dataLength - 1] > max) {
                    croppedData = this.cropData(series.xData, series.yData, min, max);
                    processedXData = croppedData.xData;
                    processedYData = croppedData.yData;
                    cropStart = croppedData.start;
                    cropped = true;
                }
            }
            for (i = processedXData.length - 1; i >= 0; i--) {
                distance = processedXData[i] - processedXData[i - 1];
                if (distance > 0 && (closestPointRange === UNDEFINED || distance < closestPointRange)) {
                    closestPointRange = distance;
                } else if (distance < 0 && series.requireSorting) {
                    error(15);
                }
            }
            series.cropped = cropped;
            series.cropStart = cropStart;
            series.processedXData = processedXData;
            series.processedYData = processedYData;
            if (options.pointRange === null) {
                series.pointRange = closestPointRange || 1;
            }
            series.closestPointRange = closestPointRange;
        },
        cropData: function(xData, yData, min, max) {
            var dataLength = xData.length, cropStart = 0, cropEnd = dataLength, i;
            for (i = 0; i < dataLength; i++) {
                if (xData[i] >= min) {
                    cropStart = mathMax(0, i - 1);
                    break;
                }
            }
            for (;i < dataLength; i++) {
                if (xData[i] > max) {
                    cropEnd = i + 1;
                    break;
                }
            }
            return {
                xData: xData.slice(cropStart, cropEnd),
                yData: yData.slice(cropStart, cropEnd),
                start: cropStart,
                end: cropEnd
            };
        },
        generatePoints: function() {
            var series = this, options = series.options, dataOptions = options.data, data = series.data, dataLength, processedXData = series.processedXData, processedYData = series.processedYData, pointClass = series.pointClass, processedDataLength = processedXData.length, cropStart = series.cropStart || 0, cursor, hasGroupedData = series.hasGroupedData, point, points = [], i;
            if (!data && !hasGroupedData) {
                var arr = [];
                arr.length = dataOptions.length;
                data = series.data = arr;
            }
            for (i = 0; i < processedDataLength; i++) {
                cursor = cropStart + i;
                if (!hasGroupedData) {
                    if (data[cursor]) {
                        point = data[cursor];
                    } else if (dataOptions[cursor] !== UNDEFINED) {
                        data[cursor] = point = new pointClass().init(series, dataOptions[cursor], processedXData[i]);
                    }
                    points[i] = point;
                } else {
                    points[i] = new pointClass().init(series, [ processedXData[i] ].concat(splat(processedYData[i])));
                }
            }
            if (data && (processedDataLength !== (dataLength = data.length) || hasGroupedData)) {
                for (i = 0; i < dataLength; i++) {
                    if (i === cropStart && !hasGroupedData) {
                        i += processedDataLength;
                    }
                    if (data[i]) {
                        data[i].destroyElements();
                        data[i].plotX = UNDEFINED;
                    }
                }
            }
            series.data = data;
            series.points = points;
        },
        setStackedPoints: function() {
            if (!this.options.stacking || this.visible !== true && this.chart.options.chart.ignoreHiddenSeries !== false) {
                return;
            }
            var series = this, xData = series.processedXData, yData = series.processedYData, yDataLength = yData.length, seriesOptions = series.options, threshold = seriesOptions.threshold, stackOption = seriesOptions.stack, stacking = seriesOptions.stacking, stackKey = series.stackKey, negKey = "-" + stackKey, yAxis = series.yAxis, stacks = yAxis.stacks, oldStacks = yAxis.oldStacks, stackExtremes = yAxis.stackExtremes, isNegative, total, stack, key, i, x, y;
            for (i = 0; i < yDataLength; i++) {
                x = xData[i];
                y = yData[i];
                isNegative = series.negStacks && y < threshold;
                key = isNegative ? negKey : stackKey;
                if (typeof y === "number" && !stackExtremes[stackKey]) {
                    stackExtremes[stackKey] = {
                        dataMin: y,
                        dataMax: y
                    };
                }
                if (!stacks[key]) {
                    stacks[key] = {};
                }
                if (!stacks[key][x]) {
                    if (oldStacks[key] && oldStacks[key][x]) {
                        stacks[key][x] = oldStacks[key][x];
                        stacks[key][x].total = null;
                    } else {
                        stacks[key][x] = new StackItem(yAxis, yAxis.options.stackLabels, isNegative, x, stackOption, stacking);
                    }
                }
                stack = stacks[key][x];
                total = stack.total;
                stack.addValue(y || 0);
                stack.cacheExtremes(series, [ total, total + (y || 0) ]);
                if (typeof y === "number") {
                    stackExtremes[stackKey].dataMin = mathMin(stackExtremes[stackKey].dataMin, stack.total, y);
                    stackExtremes[stackKey].dataMax = mathMax(stackExtremes[stackKey].dataMax, stack.total, y);
                }
            }
            yAxis.oldStacks = {};
        },
        getExtremes: function() {
            var xAxis = this.xAxis, yAxis = this.yAxis, stackKey = this.stackKey, stackExtremes, stackMin, stackMax, options = this.options, threshold = yAxis.isLog ? null : options.threshold, xData = this.processedXData, yData = this.processedYData, yDataLength = yData.length, activeYData = [], activeCounter = 0, xExtremes = xAxis.getExtremes(), xMin = xExtremes.min, xMax = xExtremes.max, validValue, withinRange, dataMin, dataMax, x, y, i, j;
            if (options.stacking) {
                stackExtremes = yAxis.stackExtremes[stackKey];
                stackMin = stackExtremes.dataMin;
                stackMax = stackExtremes.dataMax;
                dataMin = mathMin(stackMin, pick(threshold, stackMin));
                dataMax = mathMax(stackMax, pick(threshold, stackMax));
            }
            if (!defined(dataMin) || !defined(dataMax)) {
                for (i = 0; i < yDataLength; i++) {
                    x = xData[i];
                    y = yData[i];
                    validValue = y !== null && y !== UNDEFINED && (!yAxis.isLog || y.length || y > 0);
                    withinRange = this.getExtremesFromAll || this.cropped || (xData[i + 1] || x) >= xMin && (xData[i - 1] || x) <= xMax;
                    if (validValue && withinRange) {
                        j = y.length;
                        if (j) {
                            while (j--) {
                                if (y[j] !== null) {
                                    activeYData[activeCounter++] = y[j];
                                }
                            }
                        } else {
                            activeYData[activeCounter++] = y;
                        }
                    }
                }
                dataMin = pick(dataMin, arrayMin(activeYData));
                dataMax = pick(dataMax, arrayMax(activeYData));
            }
            this.dataMin = dataMin;
            this.dataMax = dataMax;
        },
        translate: function() {
            if (!this.processedXData) {
                this.processData();
            }
            this.generatePoints();
            var series = this, options = series.options, stacking = options.stacking, xAxis = series.xAxis, categories = xAxis.categories, yAxis = series.yAxis, points = series.points, dataLength = points.length, hasModifyValue = !!series.modifyValue, i, pointPlacement = options.pointPlacement, dynamicallyPlaced = pointPlacement === "between" || isNumber(pointPlacement), threshold = options.threshold;
            for (i = 0; i < dataLength; i++) {
                var point = points[i], xValue = point.x, yValue = point.y, yBottom = point.low, stack = yAxis.stacks[(series.negStacks && yValue < threshold ? "-" : "") + series.stackKey], pointStack, pointStackTotal;
                if (yAxis.isLog && yValue <= 0) {
                    point.y = yValue = null;
                }
                point.plotX = xAxis.translate(xValue, 0, 0, 0, 1, pointPlacement);
                if (stacking && series.visible && stack && stack[xValue]) {
                    pointStack = stack[xValue];
                    pointStackTotal = pointStack.total;
                    pointStack.cum = yBottom = pointStack.cum - yValue;
                    yValue = yBottom + yValue;
                    if (pointStack.cum === 0) {
                        yBottom = pick(threshold, yAxis.min);
                    }
                    if (yAxis.isLog && yBottom <= 0) {
                        yBottom = null;
                    }
                    if (stacking === "percent") {
                        yBottom = pointStackTotal ? yBottom * 100 / pointStackTotal : 0;
                        yValue = pointStackTotal ? yValue * 100 / pointStackTotal : 0;
                    }
                    point.percentage = pointStackTotal ? point.y * 100 / pointStackTotal : 0;
                    point.total = point.stackTotal = pointStackTotal;
                    point.stackY = yValue;
                    pointStack.setOffset(series.pointXOffset || 0, series.barW || 0);
                }
                point.yBottom = defined(yBottom) ? yAxis.translate(yBottom, 0, 1, 0, 1) : null;
                if (hasModifyValue) {
                    yValue = series.modifyValue(yValue, point);
                }
                point.plotY = typeof yValue === "number" && yValue !== Infinity ? yAxis.translate(yValue, 0, 1, 0, 1) : UNDEFINED;
                point.clientX = dynamicallyPlaced ? xAxis.translate(xValue, 0, 0, 0, 1) : point.plotX;
                point.negative = point.y < (threshold || 0);
                point.category = categories && categories[point.x] !== UNDEFINED ? categories[point.x] : point.x;
            }
            series.getSegments();
        },
        setTooltipPoints: function(renew) {
            var series = this, points = [], pointsLength, low, high, xAxis = series.xAxis, axisLength = xAxis ? xAxis.tooltipLen || xAxis.len : series.chart.plotSizeX, point, nextPoint, i, tooltipPoints = [];
            if (series.options.enableMouseTracking === false) {
                return;
            }
            if (renew) {
                series.tooltipPoints = null;
            }
            each(series.segments || series.points, function(segment) {
                points = points.concat(segment);
            });
            if (xAxis && xAxis.reversed) {
                points = points.reverse();
            }
            if (series.orderTooltipPoints) {
                series.orderTooltipPoints(points);
            }
            pointsLength = points.length;
            for (i = 0; i < pointsLength; i++) {
                point = points[i];
                nextPoint = points[i + 1];
                low = points[i - 1] ? high + 1 : 0;
                high = points[i + 1] ? mathMin(mathMax(0, mathFloor((point.clientX + (nextPoint ? nextPoint.wrappedClientX || nextPoint.clientX : axisLength)) / 2)), axisLength) : axisLength;
                while (low >= 0 && low <= high) {
                    tooltipPoints[low++] = point;
                }
            }
            series.tooltipPoints = tooltipPoints;
        },
        tooltipHeaderFormatter: function(point) {
            var series = this, tooltipOptions = series.tooltipOptions, xDateFormat = tooltipOptions.xDateFormat, dateTimeLabelFormats = tooltipOptions.dateTimeLabelFormats, xAxis = series.xAxis, isDateTime = xAxis && xAxis.options.type === "datetime", headerFormat = tooltipOptions.headerFormat, closestPointRange = xAxis && xAxis.closestPointRange, n;
            if (isDateTime && !xDateFormat) {
                if (closestPointRange) {
                    for (n in timeUnits) {
                        if (timeUnits[n] >= closestPointRange) {
                            xDateFormat = dateTimeLabelFormats[n];
                            break;
                        }
                    }
                } else {
                    xDateFormat = dateTimeLabelFormats.day;
                }
            }
            if (isDateTime && xDateFormat && isNumber(point.key)) {
                headerFormat = headerFormat.replace("{point.key}", "{point.key:" + xDateFormat + "}");
            }
            return format(headerFormat, {
                point: point,
                series: series
            });
        },
        onMouseOver: function() {
            var series = this, chart = series.chart, hoverSeries = chart.hoverSeries;
            if (hoverSeries && hoverSeries !== series) {
                hoverSeries.onMouseOut();
            }
            if (series.options.events.mouseOver) {
                fireEvent(series, "mouseOver");
            }
            series.setState(HOVER_STATE);
            chart.hoverSeries = series;
        },
        onMouseOut: function() {
            var series = this, options = series.options, chart = series.chart, tooltip = chart.tooltip, hoverPoint = chart.hoverPoint;
            if (hoverPoint) {
                hoverPoint.onMouseOut();
            }
            if (series && options.events.mouseOut) {
                fireEvent(series, "mouseOut");
            }
            if (tooltip && !options.stickyTracking && (!tooltip.shared || series.noSharedTooltip)) {
                tooltip.hide();
            }
            series.setState();
            chart.hoverSeries = null;
        },
        animate: function(init) {
            var series = this, chart = series.chart, renderer = chart.renderer, clipRect, markerClipRect, animation = series.options.animation, clipBox = chart.clipBox, inverted = chart.inverted, sharedClipKey;
            if (animation && !isObject(animation)) {
                animation = defaultPlotOptions[series.type].animation;
            }
            sharedClipKey = "_sharedClip" + animation.duration + animation.easing;
            if (init) {
                clipRect = chart[sharedClipKey];
                markerClipRect = chart[sharedClipKey + "m"];
                if (!clipRect) {
                    chart[sharedClipKey] = clipRect = renderer.clipRect(extend(clipBox, {
                        width: 0
                    }));
                    chart[sharedClipKey + "m"] = markerClipRect = renderer.clipRect(-99, inverted ? -chart.plotLeft : -chart.plotTop, 99, inverted ? chart.chartWidth : chart.chartHeight);
                }
                series.group.clip(clipRect);
                series.markerGroup.clip(markerClipRect);
                series.sharedClipKey = sharedClipKey;
            } else {
                clipRect = chart[sharedClipKey];
                if (clipRect) {
                    clipRect.animate({
                        width: chart.plotSizeX
                    }, animation);
                    chart[sharedClipKey + "m"].animate({
                        width: chart.plotSizeX + 99
                    }, animation);
                }
                series.animate = null;
                series.animationTimeout = setTimeout(function() {
                    series.afterAnimate();
                }, animation.duration);
            }
        },
        afterAnimate: function() {
            var chart = this.chart, sharedClipKey = this.sharedClipKey, group = this.group;
            if (group && this.options.clip !== false) {
                group.clip(chart.clipRect);
                this.markerGroup.clip();
            }
            setTimeout(function() {
                if (sharedClipKey && chart[sharedClipKey]) {
                    chart[sharedClipKey] = chart[sharedClipKey].destroy();
                    chart[sharedClipKey + "m"] = chart[sharedClipKey + "m"].destroy();
                }
            }, 100);
        },
        drawPoints: function() {
            var series = this, pointAttr, points = series.points, chart = series.chart, plotX, plotY, i, point, radius, symbol, isImage, graphic, options = series.options, seriesMarkerOptions = options.marker, pointMarkerOptions, enabled, isInside, markerGroup = series.markerGroup;
            if (seriesMarkerOptions.enabled || series._hasPointMarkers) {
                i = points.length;
                while (i--) {
                    point = points[i];
                    plotX = mathFloor(point.plotX);
                    plotY = point.plotY;
                    graphic = point.graphic;
                    pointMarkerOptions = point.marker || {};
                    enabled = seriesMarkerOptions.enabled && pointMarkerOptions.enabled === UNDEFINED || pointMarkerOptions.enabled;
                    isInside = chart.isInsidePlot(mathRound(plotX), plotY, chart.inverted);
                    if (enabled && plotY !== UNDEFINED && !isNaN(plotY) && point.y !== null) {
                        pointAttr = point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE];
                        radius = pointAttr.r;
                        symbol = pick(pointMarkerOptions.symbol, series.symbol);
                        isImage = symbol.indexOf("url") === 0;
                        if (graphic) {
                            graphic.attr({
                                visibility: isInside ? hasSVG ? "inherit" : VISIBLE : HIDDEN
                            }).animate(extend({
                                x: plotX - radius,
                                y: plotY - radius
                            }, graphic.symbolName ? {
                                width: 2 * radius,
                                height: 2 * radius
                            } : {}));
                        } else if (isInside && (radius > 0 || isImage)) {
                            point.graphic = graphic = chart.renderer.symbol(symbol, plotX - radius, plotY - radius, 2 * radius, 2 * radius).attr(pointAttr).add(markerGroup);
                        }
                    } else if (graphic) {
                        point.graphic = graphic.destroy();
                    }
                }
            }
        },
        convertAttribs: function(options, base1, base2, base3) {
            var conversion = this.pointAttrToOptions, attr, option, obj = {};
            options = options || {};
            base1 = base1 || {};
            base2 = base2 || {};
            base3 = base3 || {};
            for (attr in conversion) {
                option = conversion[attr];
                obj[attr] = pick(options[option], base1[attr], base2[attr], base3[attr]);
            }
            return obj;
        },
        getAttribs: function() {
            var series = this, seriesOptions = series.options, normalOptions = defaultPlotOptions[series.type].marker ? seriesOptions.marker : seriesOptions, stateOptions = normalOptions.states, stateOptionsHover = stateOptions[HOVER_STATE], pointStateOptionsHover, seriesColor = series.color, normalDefaults = {
                stroke: seriesColor,
                fill: seriesColor
            }, points = series.points || [], i, point, seriesPointAttr = [], pointAttr, pointAttrToOptions = series.pointAttrToOptions, hasPointSpecificOptions, negativeColor = seriesOptions.negativeColor, key;
            if (seriesOptions.marker) {
                stateOptionsHover.radius = stateOptionsHover.radius || normalOptions.radius + 2;
                stateOptionsHover.lineWidth = stateOptionsHover.lineWidth || normalOptions.lineWidth + 1;
            } else {
                stateOptionsHover.color = stateOptionsHover.color || Color(stateOptionsHover.color || seriesColor).brighten(stateOptionsHover.brightness).get();
            }
            seriesPointAttr[NORMAL_STATE] = series.convertAttribs(normalOptions, normalDefaults);
            each([ HOVER_STATE, SELECT_STATE ], function(state) {
                seriesPointAttr[state] = series.convertAttribs(stateOptions[state], seriesPointAttr[NORMAL_STATE]);
            });
            series.pointAttr = seriesPointAttr;
            i = points.length;
            while (i--) {
                point = points[i];
                normalOptions = point.options && point.options.marker || point.options;
                if (normalOptions && normalOptions.enabled === false) {
                    normalOptions.radius = 0;
                }
                if (point.negative && negativeColor) {
                    point.color = point.fillColor = negativeColor;
                }
                hasPointSpecificOptions = seriesOptions.colorByPoint || point.color;
                if (point.options) {
                    for (key in pointAttrToOptions) {
                        if (defined(normalOptions[pointAttrToOptions[key]])) {
                            hasPointSpecificOptions = true;
                        }
                    }
                }
                if (hasPointSpecificOptions) {
                    normalOptions = normalOptions || {};
                    pointAttr = [];
                    stateOptions = normalOptions.states || {};
                    pointStateOptionsHover = stateOptions[HOVER_STATE] = stateOptions[HOVER_STATE] || {};
                    if (!seriesOptions.marker) {
                        pointStateOptionsHover.color = Color(pointStateOptionsHover.color || point.color).brighten(pointStateOptionsHover.brightness || stateOptionsHover.brightness).get();
                    }
                    pointAttr[NORMAL_STATE] = series.convertAttribs(extend({
                        color: point.color
                    }, normalOptions), seriesPointAttr[NORMAL_STATE]);
                    pointAttr[HOVER_STATE] = series.convertAttribs(stateOptions[HOVER_STATE], seriesPointAttr[HOVER_STATE], pointAttr[NORMAL_STATE]);
                    pointAttr[SELECT_STATE] = series.convertAttribs(stateOptions[SELECT_STATE], seriesPointAttr[SELECT_STATE], pointAttr[NORMAL_STATE]);
                    if (point.negative && seriesOptions.marker && negativeColor) {
                        pointAttr[NORMAL_STATE].fill = pointAttr[HOVER_STATE].fill = pointAttr[SELECT_STATE].fill = series.convertAttribs({
                            fillColor: negativeColor
                        }).fill;
                    }
                } else {
                    pointAttr = seriesPointAttr;
                }
                point.pointAttr = pointAttr;
            }
        },
        update: function(newOptions, redraw) {
            var chart = this.chart, oldOptions = this.userOptions, oldType = this.type;
            newOptions = merge(oldOptions, {
                animation: false,
                index: this.index,
                pointStart: this.xData[0]
            }, {
                data: this.options.data
            }, newOptions);
            this.remove(false);
            extend(this, seriesTypes[newOptions.type || oldType].prototype);
            this.init(chart, newOptions);
            if (pick(redraw, true)) {
                chart.redraw(false);
            }
        },
        destroy: function() {
            var series = this, chart = series.chart, issue134 = /AppleWebKit\/533/.test(userAgent), destroy, i, data = series.data || [], point, prop, axis;
            fireEvent(series, "destroy");
            removeEvent(series);
            each([ "xAxis", "yAxis" ], function(AXIS) {
                axis = series[AXIS];
                if (axis) {
                    erase(axis.series, series);
                    axis.isDirty = axis.forceRedraw = true;
                }
            });
            if (series.legendItem) {
                series.chart.legend.destroyItem(series);
            }
            i = data.length;
            while (i--) {
                point = data[i];
                if (point && point.destroy) {
                    point.destroy();
                }
            }
            series.points = null;
            clearTimeout(series.animationTimeout);
            each([ "area", "graph", "dataLabelsGroup", "group", "markerGroup", "tracker", "graphNeg", "areaNeg", "posClip", "negClip" ], function(prop) {
                if (series[prop]) {
                    destroy = issue134 && prop === "group" ? "hide" : "destroy";
                    series[prop][destroy]();
                }
            });
            if (chart.hoverSeries === series) {
                chart.hoverSeries = null;
            }
            erase(chart.series, series);
            for (prop in series) {
                delete series[prop];
            }
        },
        drawDataLabels: function() {
            var series = this, seriesOptions = series.options, options = seriesOptions.dataLabels, points = series.points, pointOptions, generalOptions, str, dataLabelsGroup;
            if (options.enabled || series._hasPointLabels) {
                if (series.dlProcessOptions) {
                    series.dlProcessOptions(options);
                }
                dataLabelsGroup = series.plotGroup("dataLabelsGroup", "data-labels", series.visible ? VISIBLE : HIDDEN, options.zIndex || 6);
                generalOptions = options;
                each(points, function(point) {
                    var enabled, dataLabel = point.dataLabel, labelConfig, attr, name, rotation, connector = point.connector, isNew = true;
                    pointOptions = point.options && point.options.dataLabels;
                    enabled = generalOptions.enabled || pointOptions && pointOptions.enabled;
                    if (dataLabel && !enabled) {
                        point.dataLabel = dataLabel.destroy();
                    } else if (enabled) {
                        options = merge(generalOptions, pointOptions);
                        rotation = options.rotation;
                        labelConfig = point.getLabelConfig();
                        str = options.format ? format(options.format, labelConfig) : options.formatter.call(labelConfig, options);
                        options.style.color = pick(options.color, options.style.color, series.color, "black");
                        if (dataLabel) {
                            if (defined(str)) {
                                dataLabel.attr({
                                    text: str
                                });
                                isNew = false;
                            } else {
                                point.dataLabel = dataLabel = dataLabel.destroy();
                                if (connector) {
                                    point.connector = connector.destroy();
                                }
                            }
                        } else if (defined(str)) {
                            attr = {
                                fill: options.backgroundColor,
                                stroke: options.borderColor,
                                "stroke-width": options.borderWidth,
                                r: options.borderRadius || 0,
                                rotation: rotation,
                                padding: options.padding,
                                zIndex: 1
                            };
                            for (name in attr) {
                                if (attr[name] === UNDEFINED) {
                                    delete attr[name];
                                }
                            }
                            dataLabel = point.dataLabel = series.chart.renderer[rotation ? "text" : "label"](str, 0, -999, null, null, null, options.useHTML).attr(attr).css(options.style).add(dataLabelsGroup).shadow(options.shadow);
                        }
                        if (dataLabel) {
                            series.alignDataLabel(point, dataLabel, options, null, isNew);
                        }
                    }
                });
            }
        },
        alignDataLabel: function(point, dataLabel, options, alignTo, isNew) {
            var chart = this.chart, inverted = chart.inverted, plotX = pick(point.plotX, -999), plotY = pick(point.plotY, -999), bBox = dataLabel.getBBox(), alignAttr;
            alignTo = extend({
                x: inverted ? chart.plotWidth - plotY : plotX,
                y: mathRound(inverted ? chart.plotHeight - plotX : plotY),
                width: 0,
                height: 0
            }, alignTo);
            extend(options, {
                width: bBox.width,
                height: bBox.height
            });
            if (options.rotation) {
                alignAttr = {
                    align: options.align,
                    x: alignTo.x + options.x + alignTo.width / 2,
                    y: alignTo.y + options.y + alignTo.height / 2
                };
                dataLabel[isNew ? "attr" : "animate"](alignAttr);
            } else {
                dataLabel.align(options, null, alignTo);
                alignAttr = dataLabel.alignAttr;
            }
            dataLabel.attr({
                visibility: options.crop === false || chart.isInsidePlot(alignAttr.x, alignAttr.y) && chart.isInsidePlot(alignAttr.x + bBox.width, alignAttr.y + bBox.height) ? chart.renderer.isSVG ? "inherit" : VISIBLE : HIDDEN
            });
        },
        getSegmentPath: function(segment) {
            var series = this, segmentPath = [], step = series.options.step;
            each(segment, function(point, i) {
                var plotX = point.plotX, plotY = point.plotY, lastPoint;
                if (series.getPointSpline) {
                    segmentPath.push.apply(segmentPath, series.getPointSpline(segment, point, i));
                } else {
                    segmentPath.push(i ? L : M);
                    if (step && i) {
                        lastPoint = segment[i - 1];
                        if (step === "right") {
                            segmentPath.push(lastPoint.plotX, plotY);
                        } else if (step === "center") {
                            segmentPath.push((lastPoint.plotX + plotX) / 2, lastPoint.plotY, (lastPoint.plotX + plotX) / 2, plotY);
                        } else {
                            segmentPath.push(plotX, lastPoint.plotY);
                        }
                    }
                    segmentPath.push(point.plotX, point.plotY);
                }
            });
            return segmentPath;
        },
        getGraphPath: function() {
            var series = this, graphPath = [], segmentPath, singlePoints = [];
            each(series.segments, function(segment) {
                segmentPath = series.getSegmentPath(segment);
                if (segment.length > 1) {
                    graphPath = graphPath.concat(segmentPath);
                } else {
                    singlePoints.push(segment[0]);
                }
            });
            series.singlePoints = singlePoints;
            series.graphPath = graphPath;
            return graphPath;
        },
        drawGraph: function() {
            var series = this, options = this.options, props = [ [ "graph", options.lineColor || this.color ] ], lineWidth = options.lineWidth, dashStyle = options.dashStyle, graphPath = this.getGraphPath(), negativeColor = options.negativeColor;
            if (negativeColor) {
                props.push([ "graphNeg", negativeColor ]);
            }
            each(props, function(prop, i) {
                var graphKey = prop[0], graph = series[graphKey], attribs;
                if (graph) {
                    stop(graph);
                    graph.animate({
                        d: graphPath
                    });
                } else if (lineWidth && graphPath.length) {
                    attribs = {
                        stroke: prop[1],
                        "stroke-width": lineWidth,
                        zIndex: 1
                    };
                    if (dashStyle) {
                        attribs.dashstyle = dashStyle;
                    }
                    series[graphKey] = series.chart.renderer.path(graphPath).attr(attribs).add(series.group).shadow(!i && options.shadow);
                }
            });
        },
        clipNeg: function() {
            var options = this.options, chart = this.chart, renderer = chart.renderer, negativeColor = options.negativeColor || options.negativeFillColor, translatedThreshold, posAttr, negAttr, graph = this.graph, area = this.area, posClip = this.posClip, negClip = this.negClip, chartWidth = chart.chartWidth, chartHeight = chart.chartHeight, chartSizeMax = mathMax(chartWidth, chartHeight), yAxis = this.yAxis, above, below;
            if (negativeColor && (graph || area)) {
                translatedThreshold = mathRound(yAxis.toPixels(options.threshold || 0, true));
                above = {
                    x: 0,
                    y: 0,
                    width: chartSizeMax,
                    height: translatedThreshold
                };
                below = {
                    x: 0,
                    y: translatedThreshold,
                    width: chartSizeMax,
                    height: chartSizeMax
                };
                if (chart.inverted) {
                    above.height = below.y = chart.plotWidth - translatedThreshold;
                    if (renderer.isVML) {
                        above = {
                            x: chart.plotWidth - translatedThreshold - chart.plotLeft,
                            y: 0,
                            width: chartWidth,
                            height: chartHeight
                        };
                        below = {
                            x: translatedThreshold + chart.plotLeft - chartWidth,
                            y: 0,
                            width: chart.plotLeft + translatedThreshold,
                            height: chartWidth
                        };
                    }
                }
                if (yAxis.reversed) {
                    posAttr = below;
                    negAttr = above;
                } else {
                    posAttr = above;
                    negAttr = below;
                }
                if (posClip) {
                    posClip.animate(posAttr);
                    negClip.animate(negAttr);
                } else {
                    this.posClip = posClip = renderer.clipRect(posAttr);
                    this.negClip = negClip = renderer.clipRect(negAttr);
                    if (graph && this.graphNeg) {
                        graph.clip(posClip);
                        this.graphNeg.clip(negClip);
                    }
                    if (area) {
                        area.clip(posClip);
                        this.areaNeg.clip(negClip);
                    }
                }
            }
        },
        invertGroups: function() {
            var series = this, chart = series.chart;
            if (!series.xAxis) {
                return;
            }
            function setInvert() {
                var size = {
                    width: series.yAxis.len,
                    height: series.xAxis.len
                };
                each([ "group", "markerGroup" ], function(groupName) {
                    if (series[groupName]) {
                        series[groupName].attr(size).invert();
                    }
                });
            }
            addEvent(chart, "resize", setInvert);
            addEvent(series, "destroy", function() {
                removeEvent(chart, "resize", setInvert);
            });
            setInvert();
            series.invertGroups = setInvert;
        },
        plotGroup: function(prop, name, visibility, zIndex, parent) {
            var group = this[prop], isNew = !group;
            if (isNew) {
                this[prop] = group = this.chart.renderer.g(name).attr({
                    visibility: visibility,
                    zIndex: zIndex || .1
                }).add(parent);
            }
            group[isNew ? "attr" : "animate"](this.getPlotBox());
            return group;
        },
        getPlotBox: function() {
            return {
                translateX: this.xAxis ? this.xAxis.left : this.chart.plotLeft,
                translateY: this.yAxis ? this.yAxis.top : this.chart.plotTop,
                scaleX: 1,
                scaleY: 1
            };
        },
        render: function() {
            var series = this, chart = series.chart, group, options = series.options, animation = options.animation, doAnimation = animation && !!series.animate && chart.renderer.isSVG, visibility = series.visible ? VISIBLE : HIDDEN, zIndex = options.zIndex, hasRendered = series.hasRendered, chartSeriesGroup = chart.seriesGroup;
            group = series.plotGroup("group", "series", visibility, zIndex, chartSeriesGroup);
            series.markerGroup = series.plotGroup("markerGroup", "markers", visibility, zIndex, chartSeriesGroup);
            if (doAnimation) {
                series.animate(true);
            }
            series.getAttribs();
            group.inverted = series.isCartesian ? chart.inverted : false;
            if (series.drawGraph) {
                series.drawGraph();
                series.clipNeg();
            }
            series.drawDataLabels();
            series.drawPoints();
            if (series.options.enableMouseTracking !== false) {
                series.drawTracker();
            }
            if (chart.inverted) {
                series.invertGroups();
            }
            if (options.clip !== false && !series.sharedClipKey && !hasRendered) {
                group.clip(chart.clipRect);
            }
            if (doAnimation) {
                series.animate();
            } else if (!hasRendered) {
                series.afterAnimate();
            }
            series.isDirty = series.isDirtyData = false;
            series.hasRendered = true;
        },
        redraw: function() {
            var series = this, chart = series.chart, wasDirtyData = series.isDirtyData, group = series.group, xAxis = series.xAxis, yAxis = series.yAxis;
            if (group) {
                if (chart.inverted) {
                    group.attr({
                        width: chart.plotWidth,
                        height: chart.plotHeight
                    });
                }
                group.animate({
                    translateX: pick(xAxis && xAxis.left, chart.plotLeft),
                    translateY: pick(yAxis && yAxis.top, chart.plotTop)
                });
            }
            series.translate();
            series.setTooltipPoints(true);
            series.render();
            if (wasDirtyData) {
                fireEvent(series, "updatedData");
            }
        },
        setState: function(state) {
            var series = this, options = series.options, graph = series.graph, graphNeg = series.graphNeg, stateOptions = options.states, lineWidth = options.lineWidth, attribs;
            state = state || NORMAL_STATE;
            if (series.state !== state) {
                series.state = state;
                if (stateOptions[state] && stateOptions[state].enabled === false) {
                    return;
                }
                if (state) {
                    lineWidth = stateOptions[state].lineWidth || lineWidth + 1;
                }
                if (graph && !graph.dashstyle) {
                    attribs = {
                        "stroke-width": lineWidth
                    };
                    graph.attr(attribs);
                    if (graphNeg) {
                        graphNeg.attr(attribs);
                    }
                }
            }
        },
        setVisible: function(vis, redraw) {
            var series = this, chart = series.chart, legendItem = series.legendItem, showOrHide, ignoreHiddenSeries = chart.options.chart.ignoreHiddenSeries, oldVisibility = series.visible;
            series.visible = vis = series.userOptions.visible = vis === UNDEFINED ? !oldVisibility : vis;
            showOrHide = vis ? "show" : "hide";
            each([ "group", "dataLabelsGroup", "markerGroup", "tracker" ], function(key) {
                if (series[key]) {
                    series[key][showOrHide]();
                }
            });
            if (chart.hoverSeries === series) {
                series.onMouseOut();
            }
            if (legendItem) {
                chart.legend.colorizeItem(series, vis);
            }
            series.isDirty = true;
            if (series.options.stacking) {
                each(chart.series, function(otherSeries) {
                    if (otherSeries.options.stacking && otherSeries.visible) {
                        otherSeries.isDirty = true;
                    }
                });
            }
            each(series.linkedSeries, function(otherSeries) {
                otherSeries.setVisible(vis, false);
            });
            if (ignoreHiddenSeries) {
                chart.isDirtyBox = true;
            }
            if (redraw !== false) {
                chart.redraw();
            }
            fireEvent(series, showOrHide);
        },
        show: function() {
            this.setVisible(true);
        },
        hide: function() {
            this.setVisible(false);
        },
        select: function(selected) {
            var series = this;
            series.selected = selected = selected === UNDEFINED ? !series.selected : selected;
            if (series.checkbox) {
                series.checkbox.checked = selected;
            }
            fireEvent(series, selected ? "select" : "unselect");
        },
        drawTracker: function() {
            var series = this, options = series.options, trackByArea = options.trackByArea, trackerPath = [].concat(trackByArea ? series.areaPath : series.graphPath), trackerPathLength = trackerPath.length, chart = series.chart, pointer = chart.pointer, renderer = chart.renderer, snap = chart.options.tooltip.snap, tracker = series.tracker, cursor = options.cursor, css = cursor && {
                cursor: cursor
            }, singlePoints = series.singlePoints, singlePoint, i, onMouseOver = function() {
                if (chart.hoverSeries !== series) {
                    series.onMouseOver();
                }
            };
            if (trackerPathLength && !trackByArea) {
                i = trackerPathLength + 1;
                while (i--) {
                    if (trackerPath[i] === M) {
                        trackerPath.splice(i + 1, 0, trackerPath[i + 1] - snap, trackerPath[i + 2], L);
                    }
                    if (i && trackerPath[i] === M || i === trackerPathLength) {
                        trackerPath.splice(i, 0, L, trackerPath[i - 2] + snap, trackerPath[i - 1]);
                    }
                }
            }
            for (i = 0; i < singlePoints.length; i++) {
                singlePoint = singlePoints[i];
                trackerPath.push(M, singlePoint.plotX - snap, singlePoint.plotY, L, singlePoint.plotX + snap, singlePoint.plotY);
            }
            if (tracker) {
                tracker.attr({
                    d: trackerPath
                });
            } else {
                series.tracker = renderer.path(trackerPath).attr({
                    "stroke-linejoin": "round",
                    visibility: series.visible ? VISIBLE : HIDDEN,
                    stroke: TRACKER_FILL,
                    fill: trackByArea ? TRACKER_FILL : NONE,
                    "stroke-width": options.lineWidth + (trackByArea ? 0 : 2 * snap),
                    zIndex: 2
                }).add(series.group);
                each([ series.tracker, series.markerGroup ], function(tracker) {
                    tracker.addClass(PREFIX + "tracker").on("mouseover", onMouseOver).on("mouseout", function(e) {
                        pointer.onTrackerMouseOut(e);
                    }).css(css);
                    if (hasTouch) {
                        tracker.on("touchstart", onMouseOver);
                    }
                });
            }
        }
    };
    var LineSeries = extendClass(Series);
    seriesTypes.line = LineSeries;
    defaultPlotOptions.area = merge(defaultSeriesOptions, {
        threshold: 0
    });
    var AreaSeries = extendClass(Series, {
        type: "area",
        getSegments: function() {
            var segments = [], segment = [], keys = [], xAxis = this.xAxis, yAxis = this.yAxis, stack = yAxis.stacks[this.stackKey], pointMap = {}, plotX, plotY, points = this.points, val, i, x;
            if (this.options.stacking && !this.cropped) {
                for (i = 0; i < points.length; i++) {
                    pointMap[points[i].x] = points[i];
                }
                for (x in stack) {
                    keys.push(+x);
                }
                keys.sort(function(a, b) {
                    return a - b;
                });
                each(keys, function(x) {
                    if (pointMap[x]) {
                        segment.push(pointMap[x]);
                    } else {
                        plotX = xAxis.translate(x);
                        val = stack[x].percent ? stack[x].total ? stack[x].cum * 100 / stack[x].total : 0 : stack[x].cum;
                        plotY = yAxis.toPixels(val, true);
                        segment.push({
                            y: null,
                            plotX: plotX,
                            clientX: plotX,
                            plotY: plotY,
                            yBottom: plotY,
                            onMouseOver: noop
                        });
                    }
                });
                if (segment.length) {
                    segments.push(segment);
                }
            } else {
                Series.prototype.getSegments.call(this);
                segments = this.segments;
            }
            this.segments = segments;
        },
        getSegmentPath: function(segment) {
            var segmentPath = Series.prototype.getSegmentPath.call(this, segment), areaSegmentPath = [].concat(segmentPath), i, options = this.options, segLength = segmentPath.length;
            if (segLength === 3) {
                areaSegmentPath.push(L, segmentPath[1], segmentPath[2]);
            }
            if (options.stacking && !this.closedStacks) {
                for (i = segment.length - 1; i >= 0; i--) {
                    if (i < segment.length - 1 && options.step) {
                        areaSegmentPath.push(segment[i + 1].plotX, segment[i].yBottom);
                    }
                    areaSegmentPath.push(segment[i].plotX, segment[i].yBottom);
                }
            } else {
                this.closeSegment(areaSegmentPath, segment);
            }
            this.areaPath = this.areaPath.concat(areaSegmentPath);
            return segmentPath;
        },
        closeSegment: function(path, segment) {
            var translatedThreshold = this.yAxis.getThreshold(this.options.threshold);
            path.push(L, segment[segment.length - 1].plotX, translatedThreshold, L, segment[0].plotX, translatedThreshold);
        },
        drawGraph: function() {
            this.areaPath = [];
            Series.prototype.drawGraph.apply(this);
            var series = this, areaPath = this.areaPath, options = this.options, negativeColor = options.negativeColor, negativeFillColor = options.negativeFillColor, props = [ [ "area", this.color, options.fillColor ] ];
            if (negativeColor || negativeFillColor) {
                props.push([ "areaNeg", negativeColor, negativeFillColor ]);
            }
            each(props, function(prop) {
                var areaKey = prop[0], area = series[areaKey];
                if (area) {
                    area.animate({
                        d: areaPath
                    });
                } else {
                    series[areaKey] = series.chart.renderer.path(areaPath).attr({
                        fill: pick(prop[2], Color(prop[1]).setOpacity(pick(options.fillOpacity, .75)).get()),
                        zIndex: 0
                    }).add(series.group);
                }
            });
        },
        drawLegendSymbol: function(legend, item) {
            item.legendSymbol = this.chart.renderer.rect(0, legend.baseline - 11, legend.options.symbolWidth, 12, 2).attr({
                zIndex: 3
            }).add(item.legendGroup);
        }
    });
    seriesTypes.area = AreaSeries;
    defaultPlotOptions.spline = merge(defaultSeriesOptions);
    var SplineSeries = extendClass(Series, {
        type: "spline",
        getPointSpline: function(segment, point, i) {
            var smoothing = 1.5, denom = smoothing + 1, plotX = point.plotX, plotY = point.plotY, lastPoint = segment[i - 1], nextPoint = segment[i + 1], leftContX, leftContY, rightContX, rightContY, ret;
            if (lastPoint && nextPoint) {
                var lastX = lastPoint.plotX, lastY = lastPoint.plotY, nextX = nextPoint.plotX, nextY = nextPoint.plotY, correction;
                leftContX = (smoothing * plotX + lastX) / denom;
                leftContY = (smoothing * plotY + lastY) / denom;
                rightContX = (smoothing * plotX + nextX) / denom;
                rightContY = (smoothing * plotY + nextY) / denom;
                correction = (rightContY - leftContY) * (rightContX - plotX) / (rightContX - leftContX) + plotY - rightContY;
                leftContY += correction;
                rightContY += correction;
                if (leftContY > lastY && leftContY > plotY) {
                    leftContY = mathMax(lastY, plotY);
                    rightContY = 2 * plotY - leftContY;
                } else if (leftContY < lastY && leftContY < plotY) {
                    leftContY = mathMin(lastY, plotY);
                    rightContY = 2 * plotY - leftContY;
                }
                if (rightContY > nextY && rightContY > plotY) {
                    rightContY = mathMax(nextY, plotY);
                    leftContY = 2 * plotY - rightContY;
                } else if (rightContY < nextY && rightContY < plotY) {
                    rightContY = mathMin(nextY, plotY);
                    leftContY = 2 * plotY - rightContY;
                }
                point.rightContX = rightContX;
                point.rightContY = rightContY;
            }
            if (!i) {
                ret = [ M, plotX, plotY ];
            } else {
                ret = [ "C", lastPoint.rightContX || lastPoint.plotX, lastPoint.rightContY || lastPoint.plotY, leftContX || plotX, leftContY || plotY, plotX, plotY ];
                lastPoint.rightContX = lastPoint.rightContY = null;
            }
            return ret;
        }
    });
    seriesTypes.spline = SplineSeries;
    defaultPlotOptions.areaspline = merge(defaultPlotOptions.area);
    var areaProto = AreaSeries.prototype, AreaSplineSeries = extendClass(SplineSeries, {
        type: "areaspline",
        closedStacks: true,
        getSegmentPath: areaProto.getSegmentPath,
        closeSegment: areaProto.closeSegment,
        drawGraph: areaProto.drawGraph,
        drawLegendSymbol: areaProto.drawLegendSymbol
    });
    seriesTypes.areaspline = AreaSplineSeries;
    defaultPlotOptions.column = merge(defaultSeriesOptions, {
        borderColor: "#FFFFFF",
        borderWidth: 1,
        borderRadius: 0,
        groupPadding: .2,
        marker: null,
        pointPadding: .1,
        minPointLength: 0,
        cropThreshold: 50,
        pointRange: null,
        states: {
            hover: {
                brightness: .1,
                shadow: false
            },
            select: {
                color: "#C0C0C0",
                borderColor: "#000000",
                shadow: false
            }
        },
        dataLabels: {
            align: null,
            verticalAlign: null,
            y: null
        },
        stickyTracking: false,
        threshold: 0
    });
    var ColumnSeries = extendClass(Series, {
        type: "column",
        pointAttrToOptions: {
            stroke: "borderColor",
            "stroke-width": "borderWidth",
            fill: "color",
            r: "borderRadius"
        },
        trackerGroups: [ "group", "dataLabelsGroup" ],
        negStacks: true,
        init: function() {
            Series.prototype.init.apply(this, arguments);
            var series = this, chart = series.chart;
            if (chart.hasRendered) {
                each(chart.series, function(otherSeries) {
                    if (otherSeries.type === series.type) {
                        otherSeries.isDirty = true;
                    }
                });
            }
        },
        getColumnMetrics: function() {
            var series = this, options = series.options, xAxis = series.xAxis, yAxis = series.yAxis, reversedXAxis = xAxis.reversed, stackKey, stackGroups = {}, columnIndex, columnCount = 0;
            if (options.grouping === false) {
                columnCount = 1;
            } else {
                each(series.chart.series, function(otherSeries) {
                    var otherOptions = otherSeries.options, otherYAxis = otherSeries.yAxis;
                    if (otherSeries.type === series.type && otherSeries.visible && yAxis.len === otherYAxis.len && yAxis.pos === otherYAxis.pos) {
                        if (otherOptions.stacking) {
                            stackKey = otherSeries.stackKey;
                            if (stackGroups[stackKey] === UNDEFINED) {
                                stackGroups[stackKey] = columnCount++;
                            }
                            columnIndex = stackGroups[stackKey];
                        } else if (otherOptions.grouping !== false) {
                            columnIndex = columnCount++;
                        }
                        otherSeries.columnIndex = columnIndex;
                    }
                });
            }
            var categoryWidth = mathMin(mathAbs(xAxis.transA) * (xAxis.ordinalSlope || options.pointRange || xAxis.closestPointRange || 1), xAxis.len), groupPadding = categoryWidth * options.groupPadding, groupWidth = categoryWidth - 2 * groupPadding, pointOffsetWidth = groupWidth / columnCount, optionPointWidth = options.pointWidth, pointPadding = defined(optionPointWidth) ? (pointOffsetWidth - optionPointWidth) / 2 : pointOffsetWidth * options.pointPadding, pointWidth = pick(optionPointWidth, pointOffsetWidth - 2 * pointPadding), colIndex = (reversedXAxis ? columnCount - (series.columnIndex || 0) : series.columnIndex) || 0, pointXOffset = pointPadding + (groupPadding + colIndex * pointOffsetWidth - categoryWidth / 2) * (reversedXAxis ? -1 : 1);
            return series.columnMetrics = {
                width: pointWidth,
                offset: pointXOffset
            };
        },
        translate: function() {
            var series = this, chart = series.chart, options = series.options, borderWidth = options.borderWidth, yAxis = series.yAxis, threshold = options.threshold, translatedThreshold = series.translatedThreshold = yAxis.getThreshold(threshold), minPointLength = pick(options.minPointLength, 5), metrics = series.getColumnMetrics(), pointWidth = metrics.width, seriesBarW = series.barW = mathCeil(mathMax(pointWidth, 1 + 2 * borderWidth)), pointXOffset = series.pointXOffset = metrics.offset, xCrisp = -(borderWidth % 2 ? .5 : 0), yCrisp = borderWidth % 2 ? .5 : 1;
            if (chart.renderer.isVML && chart.inverted) {
                yCrisp += 1;
            }
            Series.prototype.translate.apply(series);
            each(series.points, function(point) {
                var plotY = mathMin(mathMax(-999, point.plotY), yAxis.len + 999), yBottom = pick(point.yBottom, translatedThreshold), barX = point.plotX + pointXOffset, barW = seriesBarW, barY = mathMin(plotY, yBottom), right, bottom, fromTop, fromLeft, barH = mathMax(plotY, yBottom) - barY;
                if (mathAbs(barH) < minPointLength) {
                    if (minPointLength) {
                        barH = minPointLength;
                        barY = mathRound(mathAbs(barY - translatedThreshold) > minPointLength ? yBottom - minPointLength : translatedThreshold - (yAxis.translate(point.y, 0, 1, 0, 1) <= translatedThreshold ? minPointLength : 0));
                    }
                }
                point.barX = barX;
                point.pointWidth = pointWidth;
                fromLeft = mathAbs(barX) < .5;
                right = mathRound(barX + barW) + xCrisp;
                barX = mathRound(barX) + xCrisp;
                barW = right - barX;
                fromTop = mathAbs(barY) < .5;
                bottom = mathRound(barY + barH) + yCrisp;
                barY = mathRound(barY) + yCrisp;
                barH = bottom - barY;
                if (fromLeft) {
                    barX += 1;
                    barW -= 1;
                }
                if (fromTop) {
                    barY -= 1;
                    barH += 1;
                }
                point.shapeType = "rect";
                point.shapeArgs = {
                    x: barX,
                    y: barY,
                    width: barW,
                    height: barH
                };
            });
        },
        getSymbol: noop,
        drawLegendSymbol: AreaSeries.prototype.drawLegendSymbol,
        drawGraph: noop,
        drawPoints: function() {
            var series = this, options = series.options, renderer = series.chart.renderer, shapeArgs;
            each(series.points, function(point) {
                var plotY = point.plotY, graphic = point.graphic;
                if (plotY !== UNDEFINED && !isNaN(plotY) && point.y !== null) {
                    shapeArgs = point.shapeArgs;
                    if (graphic) {
                        stop(graphic);
                        graphic.animate(merge(shapeArgs));
                    } else {
                        point.graphic = graphic = renderer[point.shapeType](shapeArgs).attr(point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE]).add(series.group).shadow(options.shadow, null, options.stacking && !options.borderRadius);
                    }
                } else if (graphic) {
                    point.graphic = graphic.destroy();
                }
            });
        },
        drawTracker: function() {
            var series = this, chart = series.chart, pointer = chart.pointer, cursor = series.options.cursor, css = cursor && {
                cursor: cursor
            }, onMouseOver = function(e) {
                var target = e.target, point;
                if (chart.hoverSeries !== series) {
                    series.onMouseOver();
                }
                while (target && !point) {
                    point = target.point;
                    target = target.parentNode;
                }
                if (point !== UNDEFINED && point !== chart.hoverPoint) {
                    point.onMouseOver(e);
                }
            };
            each(series.points, function(point) {
                if (point.graphic) {
                    point.graphic.element.point = point;
                }
                if (point.dataLabel) {
                    point.dataLabel.element.point = point;
                }
            });
            if (!series._hasTracking) {
                each(series.trackerGroups, function(key) {
                    if (series[key]) {
                        series[key].addClass(PREFIX + "tracker").on("mouseover", onMouseOver).on("mouseout", function(e) {
                            pointer.onTrackerMouseOut(e);
                        }).css(css);
                        if (hasTouch) {
                            series[key].on("touchstart", onMouseOver);
                        }
                    }
                });
                series._hasTracking = true;
            }
        },
        alignDataLabel: function(point, dataLabel, options, alignTo, isNew) {
            var chart = this.chart, inverted = chart.inverted, dlBox = point.dlBox || point.shapeArgs, below = point.below || point.plotY > pick(this.translatedThreshold, chart.plotSizeY), inside = pick(options.inside, !!this.options.stacking);
            if (dlBox) {
                alignTo = merge(dlBox);
                if (inverted) {
                    alignTo = {
                        x: chart.plotWidth - alignTo.y - alignTo.height,
                        y: chart.plotHeight - alignTo.x - alignTo.width,
                        width: alignTo.height,
                        height: alignTo.width
                    };
                }
                if (!inside) {
                    if (inverted) {
                        alignTo.x += below ? 0 : alignTo.width;
                        alignTo.width = 0;
                    } else {
                        alignTo.y += below ? alignTo.height : 0;
                        alignTo.height = 0;
                    }
                }
            }
            options.align = pick(options.align, !inverted || inside ? "center" : below ? "right" : "left");
            options.verticalAlign = pick(options.verticalAlign, inverted || inside ? "middle" : below ? "top" : "bottom");
            Series.prototype.alignDataLabel.call(this, point, dataLabel, options, alignTo, isNew);
        },
        animate: function(init) {
            var series = this, yAxis = this.yAxis, options = series.options, inverted = this.chart.inverted, attr = {}, translatedThreshold;
            if (hasSVG) {
                if (init) {
                    attr.scaleY = .001;
                    translatedThreshold = mathMin(yAxis.pos + yAxis.len, mathMax(yAxis.pos, yAxis.toPixels(options.threshold)));
                    if (inverted) {
                        attr.translateX = translatedThreshold - yAxis.len;
                    } else {
                        attr.translateY = translatedThreshold;
                    }
                    series.group.attr(attr);
                } else {
                    attr.scaleY = 1;
                    attr[inverted ? "translateX" : "translateY"] = yAxis.pos;
                    series.group.animate(attr, series.options.animation);
                    series.animate = null;
                }
            }
        },
        remove: function() {
            var series = this, chart = series.chart;
            if (chart.hasRendered) {
                each(chart.series, function(otherSeries) {
                    if (otherSeries.type === series.type) {
                        otherSeries.isDirty = true;
                    }
                });
            }
            Series.prototype.remove.apply(series, arguments);
        }
    });
    seriesTypes.column = ColumnSeries;
    defaultPlotOptions.bar = merge(defaultPlotOptions.column);
    var BarSeries = extendClass(ColumnSeries, {
        type: "bar",
        inverted: true
    });
    seriesTypes.bar = BarSeries;
    defaultPlotOptions.scatter = merge(defaultSeriesOptions, {
        lineWidth: 0,
        tooltip: {
            headerFormat: '<span style="font-size: 10px; color:{series.color}">{series.name}</span><br/>',
            pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>",
            followPointer: true
        },
        stickyTracking: false
    });
    var ScatterSeries = extendClass(Series, {
        type: "scatter",
        sorted: false,
        requireSorting: false,
        noSharedTooltip: true,
        trackerGroups: [ "markerGroup" ],
        drawTracker: ColumnSeries.prototype.drawTracker,
        setTooltipPoints: noop
    });
    seriesTypes.scatter = ScatterSeries;
    defaultPlotOptions.pie = merge(defaultSeriesOptions, {
        borderColor: "#FFFFFF",
        borderWidth: 1,
        center: [ null, null ],
        clip: false,
        colorByPoint: true,
        dataLabels: {
            distance: 30,
            enabled: true,
            formatter: function() {
                return this.point.name;
            }
        },
        ignoreHiddenPoint: true,
        legendType: "point",
        marker: null,
        size: null,
        showInLegend: false,
        slicedOffset: 10,
        states: {
            hover: {
                brightness: .1,
                shadow: false
            }
        },
        stickyTracking: false,
        tooltip: {
            followPointer: true
        }
    });
    var PiePoint = extendClass(Point, {
        init: function() {
            Point.prototype.init.apply(this, arguments);
            var point = this, toggleSlice;
            if (point.y < 0) {
                point.y = null;
            }
            extend(point, {
                visible: point.visible !== false,
                name: pick(point.name, "Slice")
            });
            toggleSlice = function(e) {
                point.slice(e.type === "select");
            };
            addEvent(point, "select", toggleSlice);
            addEvent(point, "unselect", toggleSlice);
            return point;
        },
        setVisible: function(vis) {
            var point = this, series = point.series, chart = series.chart, method;
            point.visible = point.options.visible = vis = vis === UNDEFINED ? !point.visible : vis;
            series.options.data[inArray(point, series.data)] = point.options;
            method = vis ? "show" : "hide";
            each([ "graphic", "dataLabel", "connector", "shadowGroup" ], function(key) {
                if (point[key]) {
                    point[key][method]();
                }
            });
            if (point.legendItem) {
                chart.legend.colorizeItem(point, vis);
            }
            if (!series.isDirty && series.options.ignoreHiddenPoint) {
                series.isDirty = true;
                chart.redraw();
            }
        },
        slice: function(sliced, redraw, animation) {
            var point = this, series = point.series, chart = series.chart, translation;
            setAnimation(animation, chart);
            redraw = pick(redraw, true);
            point.sliced = point.options.sliced = sliced = defined(sliced) ? sliced : !point.sliced;
            series.options.data[inArray(point, series.data)] = point.options;
            translation = sliced ? point.slicedTranslation : {
                translateX: 0,
                translateY: 0
            };
            point.graphic.animate(translation);
            if (point.shadowGroup) {
                point.shadowGroup.animate(translation);
            }
        }
    });
    var PieSeries = {
        type: "pie",
        isCartesian: false,
        pointClass: PiePoint,
        requireSorting: false,
        noSharedTooltip: true,
        trackerGroups: [ "group", "dataLabelsGroup" ],
        pointAttrToOptions: {
            stroke: "borderColor",
            "stroke-width": "borderWidth",
            fill: "color"
        },
        getColor: noop,
        animate: function(init) {
            var series = this, points = series.points, startAngleRad = series.startAngleRad;
            if (!init) {
                each(points, function(point) {
                    var graphic = point.graphic, args = point.shapeArgs;
                    if (graphic) {
                        graphic.attr({
                            r: series.center[3] / 2,
                            start: startAngleRad,
                            end: startAngleRad
                        });
                        graphic.animate({
                            r: args.r,
                            start: args.start,
                            end: args.end
                        }, series.options.animation);
                    }
                });
                series.animate = null;
            }
        },
        setData: function(data, redraw) {
            Series.prototype.setData.call(this, data, false);
            this.processData();
            this.generatePoints();
            if (pick(redraw, true)) {
                this.chart.redraw();
            }
        },
        generatePoints: function() {
            var i, total = 0, points, len, point, ignoreHiddenPoint = this.options.ignoreHiddenPoint;
            Series.prototype.generatePoints.call(this);
            points = this.points;
            len = points.length;
            for (i = 0; i < len; i++) {
                point = points[i];
                total += ignoreHiddenPoint && !point.visible ? 0 : point.y;
            }
            this.total = total;
            for (i = 0; i < len; i++) {
                point = points[i];
                point.percentage = total > 0 ? point.y / total * 100 : 0;
                point.total = total;
            }
        },
        getCenter: function() {
            var options = this.options, chart = this.chart, slicingRoom = 2 * (options.slicedOffset || 0), handleSlicingRoom, plotWidth = chart.plotWidth - 2 * slicingRoom, plotHeight = chart.plotHeight - 2 * slicingRoom, centerOption = options.center, positions = [ pick(centerOption[0], "50%"), pick(centerOption[1], "50%"), options.size || "100%", options.innerSize || 0 ], smallestSize = mathMin(plotWidth, plotHeight), isPercent;
            return map(positions, function(length, i) {
                isPercent = /%$/.test(length);
                handleSlicingRoom = i < 2 || i === 2 && isPercent;
                return (isPercent ? [ plotWidth, plotHeight, smallestSize, smallestSize ][i] * pInt(length) / 100 : length) + (handleSlicingRoom ? slicingRoom : 0);
            });
        },
        translate: function(positions) {
            this.generatePoints();
            var series = this, cumulative = 0, precision = 1e3, options = series.options, slicedOffset = options.slicedOffset, connectorOffset = slicedOffset + options.borderWidth, start, end, angle, startAngleRad = series.startAngleRad = mathPI / 180 * ((options.startAngle || 0) % 360 - 90), points = series.points, circ = 2 * mathPI, radiusX, radiusY, labelDistance = options.dataLabels.distance, ignoreHiddenPoint = options.ignoreHiddenPoint, i, len = points.length, point;
            if (!positions) {
                series.center = positions = series.getCenter();
            }
            series.getX = function(y, left) {
                angle = math.asin((y - positions[1]) / (positions[2] / 2 + labelDistance));
                return positions[0] + (left ? -1 : 1) * mathCos(angle) * (positions[2] / 2 + labelDistance);
            };
            for (i = 0; i < len; i++) {
                point = points[i];
                start = mathRound((startAngleRad + cumulative * circ) * precision) / precision;
                if (!ignoreHiddenPoint || point.visible) {
                    cumulative += point.percentage / 100;
                }
                end = mathRound((startAngleRad + cumulative * circ) * precision) / precision;
                point.shapeType = "arc";
                point.shapeArgs = {
                    x: positions[0],
                    y: positions[1],
                    r: positions[2] / 2,
                    innerR: positions[3] / 2,
                    start: start,
                    end: end
                };
                angle = (end + start) / 2;
                if (angle > .75 * circ) {
                    angle -= 2 * mathPI;
                }
                point.slicedTranslation = {
                    translateX: mathRound(mathCos(angle) * slicedOffset),
                    translateY: mathRound(mathSin(angle) * slicedOffset)
                };
                radiusX = mathCos(angle) * positions[2] / 2;
                radiusY = mathSin(angle) * positions[2] / 2;
                point.tooltipPos = [ positions[0] + radiusX * .7, positions[1] + radiusY * .7 ];
                point.half = angle < circ / 4 ? 0 : 1;
                point.angle = angle;
                connectorOffset = mathMin(connectorOffset, labelDistance / 2);
                point.labelPos = [ positions[0] + radiusX + mathCos(angle) * labelDistance, positions[1] + radiusY + mathSin(angle) * labelDistance, positions[0] + radiusX + mathCos(angle) * connectorOffset, positions[1] + radiusY + mathSin(angle) * connectorOffset, positions[0] + radiusX, positions[1] + radiusY, labelDistance < 0 ? "center" : point.half ? "right" : "left", angle ];
            }
            this.setTooltipPoints();
        },
        drawGraph: null,
        drawPoints: function() {
            var series = this, chart = series.chart, renderer = chart.renderer, groupTranslation, graphic, shadow = series.options.shadow, shadowGroup, shapeArgs;
            if (shadow && !series.shadowGroup) {
                series.shadowGroup = renderer.g("shadow").add(series.group);
            }
            each(series.points, function(point) {
                graphic = point.graphic;
                shapeArgs = point.shapeArgs;
                shadowGroup = point.shadowGroup;
                if (shadow && !shadowGroup) {
                    shadowGroup = point.shadowGroup = renderer.g("shadow").add(series.shadowGroup);
                }
                groupTranslation = point.sliced ? point.slicedTranslation : {
                    translateX: 0,
                    translateY: 0
                };
                if (shadowGroup) {
                    shadowGroup.attr(groupTranslation);
                }
                if (graphic) {
                    graphic.animate(extend(shapeArgs, groupTranslation));
                } else {
                    point.graphic = graphic = renderer.arc(shapeArgs).setRadialReference(series.center).attr(point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE]).attr({
                        "stroke-linejoin": "round"
                    }).attr(groupTranslation).add(series.group).shadow(shadow, shadowGroup);
                }
                if (point.visible === false) {
                    point.setVisible(false);
                }
            });
        },
        drawDataLabels: function() {
            var series = this, data = series.data, point, chart = series.chart, options = series.options.dataLabels, connectorPadding = pick(options.connectorPadding, 10), connectorWidth = pick(options.connectorWidth, 1), plotWidth = chart.plotWidth, plotHeight = chart.plotHeight, connector, connectorPath, softConnector = pick(options.softConnector, true), distanceOption = options.distance, seriesCenter = series.center, radius = seriesCenter[2] / 2, centerY = seriesCenter[1], outside = distanceOption > 0, dataLabel, dataLabelWidth, labelPos, labelHeight, halves = [ [], [] ], x, y, visibility, rankArr, i, j, overflow = [ 0, 0, 0, 0 ], sort = function(a, b) {
                return b.y - a.y;
            }, sortByAngle = function(points, sign) {
                points.sort(function(a, b) {
                    return a.angle !== undefined && (b.angle - a.angle) * sign;
                });
            };
            if (!series.visible || !options.enabled && !series._hasPointLabels) {
                return;
            }
            Series.prototype.drawDataLabels.apply(series);
            each(data, function(point) {
                if (point.dataLabel) {
                    halves[point.half].push(point);
                }
            });
            i = 0;
            while (!labelHeight && data[i]) {
                labelHeight = data[i] && data[i].dataLabel && (data[i].dataLabel.getBBox().height || 21);
                i++;
            }
            i = 2;
            while (i--) {
                var slots = [], slotsLength, usedSlots = [], points = halves[i], pos, length = points.length, slotIndex;
                sortByAngle(points, i - .5);
                if (distanceOption > 0) {
                    for (pos = centerY - radius - distanceOption; pos <= centerY + radius + distanceOption; pos += labelHeight) {
                        slots.push(pos);
                    }
                    slotsLength = slots.length;
                    if (length > slotsLength) {
                        rankArr = [].concat(points);
                        rankArr.sort(sort);
                        j = length;
                        while (j--) {
                            rankArr[j].rank = j;
                        }
                        j = length;
                        while (j--) {
                            if (points[j].rank >= slotsLength) {
                                points.splice(j, 1);
                            }
                        }
                        length = points.length;
                    }
                    for (j = 0; j < length; j++) {
                        point = points[j];
                        labelPos = point.labelPos;
                        var closest = 9999, distance, slotI;
                        for (slotI = 0; slotI < slotsLength; slotI++) {
                            distance = mathAbs(slots[slotI] - labelPos[1]);
                            if (distance < closest) {
                                closest = distance;
                                slotIndex = slotI;
                            }
                        }
                        if (slotIndex < j && slots[j] !== null) {
                            slotIndex = j;
                        } else if (slotsLength < length - j + slotIndex && slots[j] !== null) {
                            slotIndex = slotsLength - length + j;
                            while (slots[slotIndex] === null) {
                                slotIndex++;
                            }
                        } else {
                            while (slots[slotIndex] === null) {
                                slotIndex++;
                            }
                        }
                        usedSlots.push({
                            i: slotIndex,
                            y: slots[slotIndex]
                        });
                        slots[slotIndex] = null;
                    }
                    usedSlots.sort(sort);
                }
                for (j = 0; j < length; j++) {
                    var slot, naturalY;
                    point = points[j];
                    labelPos = point.labelPos;
                    dataLabel = point.dataLabel;
                    visibility = point.visible === false ? HIDDEN : VISIBLE;
                    naturalY = labelPos[1];
                    if (distanceOption > 0) {
                        slot = usedSlots.pop();
                        slotIndex = slot.i;
                        y = slot.y;
                        if (naturalY > y && slots[slotIndex + 1] !== null || naturalY < y && slots[slotIndex - 1] !== null) {
                            y = naturalY;
                        }
                    } else {
                        y = naturalY;
                    }
                    x = options.justify ? seriesCenter[0] + (i ? -1 : 1) * (radius + distanceOption) : series.getX(slotIndex === 0 || slotIndex === slots.length - 1 ? naturalY : y, i);
                    dataLabel._attr = {
                        visibility: visibility,
                        align: labelPos[6]
                    };
                    dataLabel._pos = {
                        x: x + options.x + ({
                            left: connectorPadding,
                            right: -connectorPadding
                        }[labelPos[6]] || 0),
                        y: y + options.y - 10
                    };
                    dataLabel.connX = x;
                    dataLabel.connY = y;
                    if (this.options.size === null) {
                        dataLabelWidth = dataLabel.width;
                        if (x - dataLabelWidth < connectorPadding) {
                            overflow[3] = mathMax(mathRound(dataLabelWidth - x + connectorPadding), overflow[3]);
                        } else if (x + dataLabelWidth > plotWidth - connectorPadding) {
                            overflow[1] = mathMax(mathRound(x + dataLabelWidth - plotWidth + connectorPadding), overflow[1]);
                        }
                        if (y - labelHeight / 2 < 0) {
                            overflow[0] = mathMax(mathRound(-y + labelHeight / 2), overflow[0]);
                        } else if (y + labelHeight / 2 > plotHeight) {
                            overflow[2] = mathMax(mathRound(y + labelHeight / 2 - plotHeight), overflow[2]);
                        }
                    }
                }
            }
            if (arrayMax(overflow) === 0 || this.verifyDataLabelOverflow(overflow)) {
                this.placeDataLabels();
                if (outside && connectorWidth) {
                    each(this.points, function(point) {
                        connector = point.connector;
                        labelPos = point.labelPos;
                        dataLabel = point.dataLabel;
                        if (dataLabel && dataLabel._pos) {
                            visibility = dataLabel._attr.visibility;
                            x = dataLabel.connX;
                            y = dataLabel.connY;
                            connectorPath = softConnector ? [ M, x + (labelPos[6] === "left" ? 5 : -5), y, "C", x, y, 2 * labelPos[2] - labelPos[4], 2 * labelPos[3] - labelPos[5], labelPos[2], labelPos[3], L, labelPos[4], labelPos[5] ] : [ M, x + (labelPos[6] === "left" ? 5 : -5), y, L, labelPos[2], labelPos[3], L, labelPos[4], labelPos[5] ];
                            if (connector) {
                                connector.animate({
                                    d: connectorPath
                                });
                                connector.attr("visibility", visibility);
                            } else {
                                point.connector = connector = series.chart.renderer.path(connectorPath).attr({
                                    "stroke-width": connectorWidth,
                                    stroke: options.connectorColor || point.color || "#606060",
                                    visibility: visibility
                                }).add(series.group);
                            }
                        } else if (connector) {
                            point.connector = connector.destroy();
                        }
                    });
                }
            }
        },
        verifyDataLabelOverflow: function(overflow) {
            var center = this.center, options = this.options, centerOption = options.center, minSize = options.minSize || 80, newSize = minSize, ret;
            if (centerOption[0] !== null) {
                newSize = mathMax(center[2] - mathMax(overflow[1], overflow[3]), minSize);
            } else {
                newSize = mathMax(center[2] - overflow[1] - overflow[3], minSize);
                center[0] += (overflow[3] - overflow[1]) / 2;
            }
            if (centerOption[1] !== null) {
                newSize = mathMax(mathMin(newSize, center[2] - mathMax(overflow[0], overflow[2])), minSize);
            } else {
                newSize = mathMax(mathMin(newSize, center[2] - overflow[0] - overflow[2]), minSize);
                center[1] += (overflow[0] - overflow[2]) / 2;
            }
            if (newSize < center[2]) {
                center[2] = newSize;
                this.translate(center);
                each(this.points, function(point) {
                    if (point.dataLabel) {
                        point.dataLabel._pos = null;
                    }
                });
                this.drawDataLabels();
            } else {
                ret = true;
            }
            return ret;
        },
        placeDataLabels: function() {
            each(this.points, function(point) {
                var dataLabel = point.dataLabel, _pos;
                if (dataLabel) {
                    _pos = dataLabel._pos;
                    if (_pos) {
                        dataLabel.attr(dataLabel._attr);
                        dataLabel[dataLabel.moved ? "animate" : "attr"](_pos);
                        dataLabel.moved = true;
                    } else if (dataLabel) {
                        dataLabel.attr({
                            y: -999
                        });
                    }
                }
            });
        },
        alignDataLabel: noop,
        drawTracker: ColumnSeries.prototype.drawTracker,
        drawLegendSymbol: AreaSeries.prototype.drawLegendSymbol,
        getSymbol: noop
    };
    PieSeries = extendClass(Series, PieSeries);
    seriesTypes.pie = PieSeries;
    extend(Highcharts, {
        Axis: Axis,
        Chart: Chart,
        Color: Color,
        Legend: Legend,
        Pointer: Pointer,
        Point: Point,
        Tick: Tick,
        Tooltip: Tooltip,
        Renderer: Renderer,
        Series: Series,
        SVGElement: SVGElement,
        SVGRenderer: SVGRenderer,
        arrayMin: arrayMin,
        arrayMax: arrayMax,
        charts: charts,
        dateFormat: dateFormat,
        format: format,
        pathAnim: pathAnim,
        getOptions: getOptions,
        hasBidiBug: hasBidiBug,
        isTouchDevice: isTouchDevice,
        numberFormat: numberFormat,
        seriesTypes: seriesTypes,
        setOptions: setOptions,
        addEvent: addEvent,
        removeEvent: removeEvent,
        createElement: createElement,
        discardElement: discardElement,
        css: css,
        each: each,
        extend: extend,
        map: map,
        merge: merge,
        pick: pick,
        splat: splat,
        extendClass: extendClass,
        pInt: pInt,
        wrap: wrap,
        svg: hasSVG,
        canvas: useCanVG,
        vml: !hasSVG && !useCanVG,
        product: PRODUCT,
        version: VERSION
    });
})();

function addCommas(nStr) {
    nStr += "";
    x = nStr.split(".");
    x1 = x[0];
    x2 = x.length > 1 ? "." + x[1] : "";
    var rgx = /(\d+)(\d{3})/;
    while (rgx.test(x1)) {
        x1 = x1.replace(rgx, "$1" + "," + "$2");
    }
    return x1 + x2;
}

$(".charts .help").tooltip();

var chart1_options = {
    chart: {
        renderTo: "hmda_chart_1",
        alignTicks: true,
        height: 400,
        plotBackgroundColor: "#FFFFFF",
        plotBorderWidth: null,
        plotShadow: false,
        spacingTop: 20,
        spacingRight: 10,
        spacingBottom: 1,
        spacingLeft: 1,
        marginTop: 20,
        marginBottom: 80,
        type: "column"
    },
    exporting: {
        enabled: false
    },
    title: {
        text: "U.S. TOTAL",
        align: "center",
        verticalAlign: "bottom",
        floating: false,
        x: 30,
        y: -20,
        style: {
            color: "#000000",
            fontSize: "14pt",
            fontFamily: '"Avenir Next LT W01 Demi", "Avenir Next Demi", "Avenir Next", "Arial"',
            fontWeight: "600"
        }
    },
    credits: {
        text: "Data are for first-lien, owner-occupied, 1-4 family and manufactured homes.",
        enabled: false
    },
    colors: [ "#acdc91", "#43af2a", "#81AFAF", "#005E5D", "#D7D2CB", "#796E65" ],
    legend: {
        align: "right",
        backgroundColor: "#FFFFFF",
        borderWidth: 0,
        borderRadius: 0,
        borderColor: "#FFFFFF",
        floating: false,
        itemStyle: {
            color: "#212121",
            fontSize: "12pt",
            lineHeight: "12pt",
            fontFamily: '"Avenir Next LT W01 Medium Cn", "Avenir Next Light", "Avenir Next", "Arial Condensed", "Arial"',
            fontWeight: "",
            paddingBottom: "8pt"
        },
        layout: "vertical",
        margin: 10,
        padding: 10,
        shadow: false,
        symbolPadding: 5,
        symbolWidth: 20,
        verticalAlign: "middle",
        x: 0,
        y: 0,
        enabled: false
    },
    tooltip: {
        backgroundColor: "rgba(0, 0, 0, 0.65)",
        borderColor: "#999999",
        borderRadius: 0,
        borderWidth: 0,
        shadow: false,
        style: {
            color: "#ffffff",
            fontSize: "10pt",
            fontFamily: "",
            fontWeight: "",
            padding: 8,
            lineHeight: "12pt"
        },
        formatter: function() {
            var tooltip_suffix = "";
            if (this.point.name != "None") {
                tooltip_suffix = this.point.name;
            }
            var format = '<span style="font-size: 12pt;><span style="font-weight: 700;">' + addCommas(this.y) + "</span> " + this.series.name + " in " + this.x + "</span>";
            return format;
        }
    },
    plotOptions: {
        series: {
            allowPointSelect: true,
            animation: false,
            borderWidth: 0,
            cursor: "pointer",
            marker: {
                radius: 10
            },
            showInLegend: true,
            shadow: false,
            point: {
                events: {
                    click: function() {
                        return false;
                    }
                }
            }
        },
        pie: {
            dataLabels: {
                enabled: false
            },
            point: {
                events: {
                    legendItemClick: function() {
                        return false;
                    }
                }
            },
            size: "90%"
        },
        column: {
            dataLabels: {
                enabled: false
            },
            grouping: true,
            groupPadding: .1,
            pointPadding: 0,
            stacking: null,
            events: {
                legendItemClick: function() {
                    return false;
                }
            }
        },
        bar: {
            dataLabels: {
                enabled: false
            },
            groupPadding: .1,
            pointPadding: 0,
            stacking: null
        },
        line: {
            lineWidth: 8,
            marker: {
                enabled: false
            }
        },
        area: {
            lineWidth: 8,
            stacking: null,
            marker: {
                enabled: false
            }
        },
        allowPointSelect: false
    },
    xAxis: {
        categories: [ "2010", "2011", "2012" ],
        gridLineWidth: 0,
        labels: {
            style: {
                color: "#212121",
                fontSize: "10pt",
                fontFamily: '"Avenir Next LT W01 Regular", "Avenir Next", "Arial"',
                fontWeight: "400"
            },
            enabled: true,
            y: 20
        },
        lineWidth: 0,
        title: {
            text: null,
            margin: 12,
            style: {
                color: "#101820",
                fontSize: "12pt",
                fontFamily: '"Avenir Next LT W01 Regular", "Avenir Next", "Arial"',
                fontWeight: "400"
            },
            x: -5
        },
        tickLength: 0,
        startOnTick: true,
        endOnTick: true,
        minPadding: 0,
        maxPadding: 0
    },
    yAxis: [ {
        title: {
            text: "Number of applications and originations",
            margin: 10,
            style: {
                color: "#101820",
                fontSize: "12pt",
                fontFamily: '"Avenir Next LT W01 Regular", "Avenir Next", "Arial"',
                fontWeight: "400"
            },
            enabled: false
        },
        labels: {
            style: {
                color: "#212121",
                fontSize: "10pt",
                fontFamily: '"Avenir Next LT W01 Regular", "Avenir Next", "Arial"',
                fontWeight: "400"
            },
            format: "{value:,.0f}",
            enabled: true
        },
        gridLineWidth: 1
    }, {
        opposite: true,
        title: {
            text: null
        },
        labels: {
            style: {
                color: "#212121",
                fontSize: "10pt",
                fontFamily: '"Avenir Next LT W01 Regular", "Avenir Next", "Arial"',
                fontWeight: "400"
            },
            format: " {value:,.0f} ",
            enabled: true
        },
        gridLineWidth: 0
    } ],
    series: [ {
        name: "Home purchase applications",
        data: [ 3358121, 3117454, 3448970 ]
    }, {
        name: "Home purchase originations",
        data: [ 2213631, 2060808, 2331989 ]
    }, {
        name: "Home improvement applications",
        data: [ 245034, 235335, 270879 ]
    }, {
        name: "Home improvement originations",
        data: [ 142357, 136967, 169193 ]
    }, {
        name: "Refinancing applications",
        data: [ 7609156, 6560190, 9264878 ]
    }, {
        name: "Refinancing originations",
        data: [ 4509310, 3840044, 5900788 ]
    } ]
};

$(document).ready(function() {
    if ($("#hmda_chart_1").length !== 0) {
        var applicationsOriginationsChart = new Highcharts.Chart(chart1_options);
    }
    if ($("#hmda_chart_1_msa").length !== 0) {
        $("#hmda_chart_1_msa").chosen({
            width: "100%"
        });
    }
    var chart1DataObj = {
        msa01: {
            name: "U.S. Total",
            data: [ [ 3358121, 3117454, 3448970 ], [ 2213631, 2060808, 2331989 ], [ 245034, 235335, 270879 ], [ 142357, 136967, 169193 ], [ 7609156, 6560190, 9264878 ], [ 4509310, 3840044, 5900788 ] ]
        },
        msa02: {
            name: "Total, all counties not part of any MSA",
            data: [ [ 596622, 546379, 589303 ], [ 304938, 290253, 325131 ], [ 60768, 58915, 67270 ], [ 36306, 35506, 43420 ], [ 1189800, 1022617, 1305309 ], [ 679482, 578242, 806149 ] ]
        },
        msa03: {
            name: "Abilene - TX",
            data: [ [ 1843, 1728, 1863 ], [ 1364, 1244, 1439 ], [ 230, 246, 219 ], [ 139, 160, 169 ], [ 1875, 1897, 2307 ], [ 1147, 1174, 1528 ] ]
        },
        msa04: {
            name: "Aguadilla, Isabela - PR",
            data: [ [ 942, 1304, 1167 ], [ 489, 715, 704 ], [ 164, 137, 117 ], [ 88, 85, 70 ], [ 1246, 1208, 1756 ], [ 697, 690, 1047 ] ]
        },
        msa05: {
            name: "Akron - OH",
            data: [ [ 6131, 5569, 6615 ], [ 4673, 4238, 5133 ], [ 376, 344, 427 ], [ 147, 153, 194 ], [ 18108, 15039, 20702 ], [ 10651, 8527, 12550 ] ]
        },
        msa06: {
            name: "Albany - GA",
            data: [ [ 1154, 1160, 1119 ], [ 740, 638, 683 ], [ 107, 72, 94 ], [ 68, 45, 60 ], [ 2338, 2036, 2547 ], [ 1345, 1107, 1574 ] ]
        },
        msa07: {
            name: "Albany, Schenectady, Troy - NY",
            data: [ [ 9159, 8367, 9319 ], [ 6564, 5932, 6800 ], [ 923, 860, 942 ], [ 600, 519, 644 ], [ 18801, 16417, 21466 ], [ 11297, 9384, 13709 ] ]
        },
        msa08: {
            name: "Albuquerque - NM",
            data: [ [ 10367, 9227, 10261 ], [ 7099, 6219, 7039 ], [ 795, 692, 791 ], [ 389, 391, 458 ], [ 25451, 21885, 31743 ], [ 13886, 11845, 18558 ] ]
        },
        msa09: {
            name: "Alexandria - LA",
            data: [ [ 1879, 1865, 1901 ], [ 1074, 1026, 1099 ], [ 210, 209, 213 ], [ 107, 127, 124 ], [ 2745, 2693, 3056 ], [ 1530, 1404, 1697 ] ]
        },
        msa10: {
            name: "Allentown, Bethlehem, Easton - PA, NJ",
            data: [ [ 8121, 7096, 7819 ], [ 5884, 5164, 5677 ], [ 1058, 1001, 1023 ], [ 697, 689, 696 ], [ 25077, 20508, 26835 ], [ 14216, 11266, 15942 ] ]
        },
        msa11: {
            name: "Altoona - PA",
            data: [ [ 988, 934, 1044 ], [ 749, 710, 777 ], [ 252, 253, 354 ], [ 166, 178, 259 ], [ 2351, 2275, 2883 ], [ 1452, 1398, 1972 ] ]
        },
        msa12: {
            name: "Amarillo - TX",
            data: [ [ 3102, 2996, 3414 ], [ 2249, 2136, 2528 ], [ 122, 92, 124 ], [ 47, 48, 68 ], [ 3932, 3613, 4801 ], [ 2254, 1942, 2804 ] ]
        },
        msa13: {
            name: "Ames - IA",
            data: [ [ 948, 874, 985 ], [ 740, 690, 763 ], [ 144, 123, 122 ], [ 124, 105, 99 ], [ 2378, 2108, 2688 ], [ 1728, 1511, 2047 ] ]
        },
        msa14: {
            name: "Anchorage - AK",
            data: [ [ 5965, 5407, 5927 ], [ 4571, 4338, 4706 ], [ 304, 248, 318 ], [ 163, 152, 200 ], [ 12668, 10678, 15160 ], [ 8025, 6757, 9916 ] ]
        },
        msa15: {
            name: "Ann Arbor - MI",
            data: [ [ 3418, 3588, 3981 ], [ 2398, 2518, 2822 ], [ 106, 130, 165 ], [ 59, 68, 109 ], [ 9448, 8928, 13866 ], [ 6391, 5931, 9826 ] ]
        },
        msa16: {
            name: "Anniston, Oxford, Jacksonville - AL",
            data: [ [ 1044, 1071, 1174 ], [ 593, 567, 619 ], [ 112, 100, 135 ], [ 46, 56, 79 ], [ 2277, 2047, 2405 ], [ 1156, 977, 1297 ] ]
        },
        msa17: {
            name: "Appleton - WI",
            data: [ [ 2423, 2384, 2763 ], [ 1918, 1879, 2182 ], [ 507, 543, 571 ], [ 407, 439, 470 ], [ 11286, 8939, 12163 ], [ 8215, 6201, 8873 ] ]
        },
        msa18: {
            name: "Asheville - NC",
            data: [ [ 4307, 4590, 5690 ], [ 2731, 2663, 3228 ], [ 273, 244, 278 ], [ 139, 128, 149 ], [ 11657, 10514, 12906 ], [ 6887, 6025, 7759 ] ]
        },
        msa19: {
            name: "Athens, Clarke County - GA",
            data: [ [ 1355, 1231, 1422 ], [ 931, 854, 991 ], [ 99, 80, 93 ], [ 48, 43, 54 ], [ 3872, 3662, 4685 ], [ 2263, 2203, 3021 ] ]
        },
        msa20: {
            name: "Atlanta, Sandy Springs, Roswell - GA",
            data: [ [ 62750, 60342, 66359 ], [ 41330, 39159, 44026 ], [ 1941, 1914, 2106 ], [ 991, 923, 1035 ], [ 129313, 120016, 180336 ], [ 67637, 66421, 110164 ] ]
        },
        msa21: {
            name: "Atlantic City, Hammonton - NJ",
            data: [ [ 2479, 2063, 2230 ], [ 1620, 1311, 1400 ], [ 365, 317, 340 ], [ 202, 190, 176 ], [ 7864, 6265, 7897 ], [ 3992, 3077, 4111 ] ]
        },
        msa22: {
            name: "Auburn, Opelika - AL",
            data: [ [ 1752, 1874, 2102 ], [ 1303, 1244, 1359 ], [ 88, 81, 90 ], [ 54, 46, 59 ], [ 3026, 2737, 3952 ], [ 1672, 1450, 2421 ] ]
        },
        msa23: {
            name: "Augusta, Richmond County - GA, SC",
            data: [ [ 6308, 6267, 6395 ], [ 4603, 4266, 4391 ], [ 337, 354, 354 ], [ 164, 159, 180 ], [ 12131, 10758, 13734 ], [ 6481, 5803, 7791 ] ]
        },
        msa24: {
            name: "Austin, Round Rock - TX",
            data: [ [ 26558, 26046, 31977 ], [ 18588, 18063, 22773 ], [ 1116, 1004, 1099 ], [ 669, 588, 606 ], [ 43887, 39578, 53850 ], [ 26118, 23592, 34541 ] ]
        },
        msa25: {
            name: "Bakersfield - CA",
            data: [ [ 9914, 8610, 8683 ], [ 6825, 6109, 6207 ], [ 211, 208, 161 ], [ 86, 100, 83 ], [ 9325, 7870, 16943 ], [ 4729, 3952, 10532 ] ]
        },
        msa26: {
            name: "Baltimore, Columbia, Towson - MD",
            data: [ [ 28655, 26483, 29628 ], [ 21068, 19547, 21949 ], [ 2439, 2240, 2243 ], [ 1568, 1368, 1449 ], [ 92870, 76191, 102648 ], [ 55584, 44740, 65277 ] ]
        },
        msa27: {
            name: "Bangor - ME",
            data: [ [ 1359, 1167, 1343 ], [ 958, 850, 969 ], [ 203, 217, 228 ], [ 131, 145, 143 ], [ 3245, 2758, 3396 ], [ 1777, 1542, 2010 ] ]
        },
        msa28: {
            name: "Barnstable Town - MA",
            data: [ [ 1871, 1795, 2187 ], [ 1353, 1308, 1588 ], [ 420, 404, 610 ], [ 332, 286, 467 ], [ 8626, 7110, 9791 ], [ 5524, 4455, 6699 ] ]
        },
        msa29: {
            name: "Baton Rouge - LA",
            data: [ [ 10688, 10023, 12695 ], [ 6587, 5943, 7856 ], [ 833, 625, 782 ], [ 428, 338, 421 ], [ 19851, 17878, 23621 ], [ 11143, 9279, 12857 ] ]
        },
        msa30: {
            name: "Battle Creek - MI",
            data: [ [ 1118, 1008, 1247 ], [ 782, 724, 841 ], [ 120, 110, 110 ], [ 67, 60, 60 ], [ 2429, 2442, 3294 ], [ 1462, 1488, 2093 ] ]
        },
        msa31: {
            name: "Bay City - MI",
            data: [ [ 932, 913, 1060 ], [ 632, 634, 747 ], [ 90, 113, 118 ], [ 46, 69, 72 ], [ 2136, 2081, 3174 ], [ 1322, 1339, 2188 ] ]
        },
        msa32: {
            name: "Beaumont, Port Arthur - TX",
            data: [ [ 3449, 3517, 3849 ], [ 2043, 2014, 2313 ], [ 690, 607, 626 ], [ 388, 334, 360 ], [ 4073, 4073, 4393 ], [ 2237, 2180, 2522 ] ]
        },
        msa33: {
            name: "Bellingham - WA",
            data: [ [ 2306, 2029, 2379 ], [ 1647, 1469, 1759 ], [ 249, 291, 408 ], [ 158, 208, 291 ], [ 7721, 5973, 8492 ], [ 5035, 3752, 5625 ] ]
        },
        msa34: {
            name: "Bend, Redmond - OR",
            data: [ [ 2414, 2148, 2673 ], [ 1674, 1504, 1956 ], [ 78, 57, 218 ], [ 49, 26, 163 ], [ 4463, 3900, 6794 ], [ 2525, 2301, 4531 ] ]
        },
        msa35: {
            name: "Bethesda, Rockville, Frederick - MD",
            data: [ [ 16005, 13795, 14648 ], [ 11835, 10155, 11070 ], [ 1053, 880, 957 ], [ 640, 556, 637 ], [ 54036, 47814, 65963 ], [ 34603, 30329, 45008 ] ]
        },
        msa36: {
            name: "Billings - MT",
            data: [ [ 2320, 2183, 2432 ], [ 1818, 1691, 1918 ], [ 234, 216, 272 ], [ 172, 167, 226 ], [ 5186, 3935, 5379 ], [ 3585, 2719, 3839 ] ]
        },
        msa37: {
            name: "Binghamton - NY",
            data: [ [ 1845, 1877, 1962 ], [ 1301, 1311, 1398 ], [ 274, 275, 387 ], [ 190, 192, 250 ], [ 3262, 2841, 3710 ], [ 1735, 1497, 2202 ] ]
        },
        msa38: {
            name: "Birmingham, Hoover - AL",
            data: [ [ 13127, 12744, 14894 ], [ 8008, 7771, 9112 ], [ 796, 916, 1043 ], [ 375, 429, 474 ], [ 31586, 24570, 33814 ], [ 15624, 11878, 18309 ] ]
        },
        msa39: {
            name: "Bismarck - ND",
            data: [ [ 1941, 2091, 2398 ], [ 1653, 1675, 2006 ], [ 125, 160, 210 ], [ 92, 124, 186 ], [ 3771, 2568, 3950 ], [ 2822, 1917, 3178 ] ]
        },
        msa40: {
            name: "Blacksburg, Christiansburg, Radford - VA",
            data: [ [ 1276, 1385, 1545 ], [ 918, 930, 1042 ], [ 263, 146, 134 ], [ 217, 95, 90 ], [ 3292, 2714, 3367 ], [ 2005, 1678, 2206 ] ]
        },
        msa41: {
            name: "Bloomington - IN",
            data: [ [ 1958, 1782, 1924 ], [ 1291, 1194, 1364 ], [ 162, 158, 262 ], [ 95, 104, 190 ], [ 4867, 4449, 5700 ], [ 2969, 2704, 3739 ] ]
        },
        msa42: {
            name: "Boise City - ID",
            data: [ [ 9520, 8669, 9659 ], [ 6937, 6552, 7489 ], [ 336, 297, 292 ], [ 170, 146, 180 ], [ 16595, 12284, 24937 ], [ 9415, 7162, 16673 ] ]
        },
        msa43: {
            name: "Boulder - CO",
            data: [ [ 3976, 3795, 4820 ], [ 2991, 2733, 3669 ], [ 189, 215, 185 ], [ 123, 125, 140 ], [ 14809, 11811, 17345 ], [ 10342, 8215, 12780 ] ]
        },
        msa44: {
            name: "Bowling Green - KY",
            data: [ [ 1231, 1204, 1375 ], [ 876, 851, 1049 ], [ 117, 126, 139 ], [ 73, 87, 100 ], [ 3024, 2960, 3234 ], [ 1812, 1823, 2078 ] ]
        },
        msa45: {
            name: "Bremerton, Silverdale - WA",
            data: [ [ 2976, 2579, 2888 ], [ 2198, 1949, 2125 ], [ 201, 210, 275 ], [ 123, 122, 188 ], [ 9683, 8337, 11865 ], [ 5894, 5016, 7660 ] ]
        },
        msa46: {
            name: "Bridgeport, Stamford, Norwalk - CT",
            data: [ [ 10030, 9011, 9887 ], [ 6954, 6251, 6856 ], [ 847, 956, 916 ], [ 518, 579, 605 ], [ 32630, 27690, 35502 ], [ 20211, 17185, 23314 ] ]
        },
        msa47: {
            name: "Brownsville, Harlingen - TX",
            data: [ [ 1999, 1961, 1915 ], [ 1222, 1194, 1229 ], [ 437, 476, 535 ], [ 90, 100, 111 ], [ 2724, 3070, 3503 ], [ 970, 1215, 1537 ] ]
        },
        msa48: {
            name: "Brunswick - GA",
            data: [ [ 889, 921, 1015 ], [ 582, 570, 655 ], [ 60, 67, 45 ], [ 30, 31, 28 ], [ 2220, 2022, 2472 ], [ 1198, 1065, 1416 ] ]
        },
        msa49: {
            name: "Buffalo, Cheektowaga, Niagara Falls - NY",
            data: [ [ 9704, 8897, 9939 ], [ 7971, 7331, 8133 ], [ 548, 519, 760 ], [ 305, 321, 476 ], [ 14515, 13653, 15864 ], [ 7695, 7666, 9515 ] ]
        },
        msa50: {
            name: "Burlington - NC",
            data: [ [ 1396, 1512, 1796 ], [ 933, 881, 964 ], [ 80, 67, 78 ], [ 41, 42, 36 ], [ 3454, 3198, 3850 ], [ 1978, 1805, 2247 ] ]
        },
        msa51: {
            name: "Burlington, South Burlington - VT",
            data: [ [ 2356, 2275, 2597 ], [ 1809, 1740, 2024 ], [ 639, 620, 658 ], [ 479, 465, 507 ], [ 8005, 6643, 9352 ], [ 5667, 4476, 6856 ] ]
        },
        msa52: {
            name: "Camden - NJ",
            data: [ [ 12061, 10588, 11366 ], [ 8371, 7345, 7879 ], [ 1714, 1621, 2181 ], [ 1042, 1005, 1326 ], [ 40987, 34768, 44385 ], [ 22738, 18903, 25674 ] ]
        },
        msa53: {
            name: "Canton, Massillon - OH",
            data: [ [ 3240, 2956, 3491 ], [ 2463, 2250, 2668 ], [ 220, 207, 248 ], [ 87, 78, 117 ], [ 9421, 7860, 10615 ], [ 5248, 4431, 6431 ] ]
        },
        msa54: {
            name: "Cape Coral, Fort Myers - FL",
            data: [ [ 7341, 6126, 6512 ], [ 4569, 3953, 4248 ], [ 187, 198, 267 ], [ 56, 70, 125 ], [ 7644, 7315, 15019 ], [ 3481, 3878, 9202 ] ]
        },
        msa55: {
            name: "Cape Girardeau - MO, IL",
            data: [ [ 1018, 1009, 1060 ], [ 742, 709, 733 ], [ 95, 99, 104 ], [ 53, 66, 84 ], [ 2328, 1994, 2561 ], [ 1470, 1258, 1778 ] ]
        },
        msa56: {
            name: "Carson City - NV",
            data: [ [ 405, 462, 490 ], [ 309, 340, 365 ], [ 13, 16, 13 ], [ 9, 4, 8 ], [ 1017, 700, 1498 ], [ 605, 407, 1028 ] ]
        },
        msa57: {
            name: "Casper - WY",
            data: [ [ 1346, 1383, 1717 ], [ 1055, 1047, 1341 ], [ 117, 93, 125 ], [ 81, 69, 102 ], [ 1987, 1598, 2177 ], [ 1271, 1003, 1504 ] ]
        },
        msa58: {
            name: "Cedar Rapids - IA",
            data: [ [ 4328, 3787, 3307 ], [ 3451, 2971, 2645 ], [ 344, 275, 282 ], [ 263, 206, 226 ], [ 10569, 8408, 9994 ], [ 7508, 5787, 7122 ] ]
        },
        msa59: {
            name: "Champaign, Urbana - IL",
            data: [ [ 2175, 2064, 2423 ], [ 1703, 1561, 1930 ], [ 209, 183, 206 ], [ 164, 116, 155 ], [ 6833, 5415, 6949 ], [ 4926, 3868, 5044 ] ]
        },
        msa60: {
            name: "Charleston - WV",
            data: [ [ 3435, 3919, 4069 ], [ 2025, 2023, 2097 ], [ 557, 585, 621 ], [ 331, 341, 375 ], [ 5527, 5194, 5752 ], [ 3075, 3001, 3483 ] ]
        },
        msa61: {
            name: "Charleston, North Charleston - SC",
            data: [ [ 10551, 10477, 12151 ], [ 6692, 6575, 7510 ], [ 356, 382, 446 ], [ 201, 235, 278 ], [ 17670, 15120, 21755 ], [ 9320, 8013, 12986 ] ]
        },
        msa62: {
            name: "Charlotte, Concord, Gastonia - NC, SC",
            data: [ [ 22692, 21829, 26020 ], [ 15899, 14934, 17934 ], [ 914, 1e3, 1242 ], [ 505, 521, 719 ], [ 55207, 48321, 65287 ], [ 31406, 27006, 39506 ] ]
        },
        msa63: {
            name: "Charlottesville - VA",
            data: [ [ 2181, 2041, 2433 ], [ 1634, 1450, 1725 ], [ 161, 183, 199 ], [ 97, 95, 137 ], [ 6257, 5246, 6999 ], [ 3820, 3174, 4540 ] ]
        },
        msa64: {
            name: "Chattanooga - TN, GA",
            data: [ [ 5818, 5912, 6922 ], [ 3841, 3570, 4165 ], [ 298, 318, 342 ], [ 164, 162, 195 ], [ 11844, 10229, 13900 ], [ 6255, 5461, 7965 ] ]
        },
        msa65: {
            name: "Cheyenne - WY",
            data: [ [ 1506, 1674, 1761 ], [ 1187, 1224, 1409 ], [ 105, 131, 114 ], [ 78, 94, 81 ], [ 3160, 2512, 3737 ], [ 1930, 1583, 2556 ] ]
        },
        msa66: {
            name: "Chicago, Joliet, Naperville - IL",
            data: [ [ 70040, 63922, 75894 ], [ 47344, 44032, 53589 ], [ 4073, 4885, 3861 ], [ 2276, 2597, 2247 ], [ 252468, 210212, 275087 ], [ 162880, 131745, 183436 ] ]
        },
        msa67: {
            name: "Chico - CA",
            data: [ [ 1838, 1774, 1858 ], [ 1248, 1271, 1362 ], [ 137, 96, 114 ], [ 80, 62, 72 ], [ 4953, 3973, 6230 ], [ 2756, 2168, 3930 ] ]
        },
        msa68: {
            name: "Cincinnati - OH, KY, IN",
            data: [ [ 23719, 21461, 24321 ], [ 17211, 15284, 17499 ], [ 1429, 1307, 1683 ], [ 713, 657, 958 ], [ 85201, 69433, 94928 ], [ 53592, 42595, 62533 ] ]
        },
        msa69: {
            name: "Clarksville - TN, KY",
            data: [ [ 4041, 4632, 4778 ], [ 3069, 3554, 3595 ], [ 210, 190, 224 ], [ 103, 95, 123 ], [ 5957, 6242, 8269 ], [ 2960, 3301, 4730 ] ]
        },
        msa70: {
            name: "Cleveland - TN",
            data: [ [ 1131, 1265, 1442 ], [ 700, 726, 800 ], [ 90, 77, 106 ], [ 47, 39, 58 ], [ 2734, 2323, 2944 ], [ 1580, 1281, 1764 ] ]
        },
        msa71: {
            name: "Cleveland, Elyria - OH",
            data: [ [ 17335, 15474, 18742 ], [ 13178, 11677, 14449 ], [ 1343, 1399, 1729 ], [ 521, 569, 721 ], [ 49016, 43719, 60935 ], [ 27914, 24032, 35712 ] ]
        },
        msa72: {
            name: "Coeur d&apos;Alene - ID",
            data: [ [ 1989, 1906, 1745 ], [ 1443, 1385, 1266 ], [ 174, 109, 130 ], [ 91, 61, 76 ], [ 5021, 3678, 5423 ], [ 2816, 2109, 3255 ] ]
        },
        msa73: {
            name: "College Station, Bryan - TX",
            data: [ [ 2290, 2068, 2464 ], [ 1629, 1443, 1694 ], [ 108, 138, 128 ], [ 56, 76, 72 ], [ 2806, 2492, 2914 ], [ 1741, 1517, 1871 ] ]
        },
        msa74: {
            name: "Colorado Springs - CO",
            data: [ [ 10403, 9647, 10607 ], [ 7943, 7374, 8347 ], [ 410, 395, 570 ], [ 246, 213, 384 ], [ 23591, 21571, 31878 ], [ 15807, 13823, 22200 ] ]
        },
        msa75: {
            name: "Columbia - MO",
            data: [ [ 2145, 2009, 2419 ], [ 1646, 1527, 1915 ], [ 179, 130, 327 ], [ 133, 100, 258 ], [ 5134, 4043, 5589 ], [ 3549, 2759, 4147 ] ]
        },
        msa76: {
            name: "Columbia - SC",
            data: [ [ 9782, 8501, 9808 ], [ 6379, 5378, 6451 ], [ 409, 473, 516 ], [ 196, 250, 332 ], [ 18818, 16694, 22136 ], [ 10217, 9040, 13130 ] ]
        },
        msa77: {
            name: "Columbus - GA, AL",
            data: [ [ 2874, 2820, 2806 ], [ 2058, 2017, 2018 ], [ 148, 102, 154 ], [ 80, 49, 70 ], [ 5646, 5188, 7061 ], [ 2850, 2637, 4051 ] ]
        },
        msa78: {
            name: "Columbus - IN",
            data: [ [ 951, 1128, 1259 ], [ 703, 839, 943 ], [ 90, 63, 61 ], [ 68, 45, 36 ], [ 2710, 2228, 2942 ], [ 1739, 1391, 1999 ] ]
        },
        msa79: {
            name: "Columbus - OH",
            data: [ [ 22047, 19677, 23566 ], [ 15594, 13982, 17405 ], [ 895, 810, 1238 ], [ 452, 397, 740 ], [ 62374, 51898, 71243 ], [ 37715, 30489, 45305 ] ]
        },
        msa80: {
            name: "Corpus Christi - TX",
            data: [ [ 4184, 4116, 4778 ], [ 2840, 2613, 3359 ], [ 395, 353, 311 ], [ 182, 158, 157 ], [ 4968, 4993, 5440 ], [ 2626, 2704, 3196 ] ]
        },
        msa81: {
            name: "Corvallis - OR",
            data: [ [ 751, 711, 786 ], [ 571, 519, 584 ], [ 61, 76, 94 ], [ 34, 39, 68 ], [ 2451, 1965, 2744 ], [ 1622, 1255, 1858 ] ]
        },
        msa82: {
            name: "Crestview, Fort Walton Beach, Destin - FL",
            data: [ [ 2387, 3010, 2987 ], [ 1708, 2148, 2100 ], [ 57, 72, 63 ], [ 36, 39, 31 ], [ 3965, 3668, 6269 ], [ 2310, 2187, 3954 ] ]
        },
        msa83: {
            name: "Cumberland - MD, WV",
            data: [ [ 578, 540, 638 ], [ 407, 372, 485 ], [ 168, 122, 132 ], [ 133, 101, 101 ], [ 1731, 1437, 1799 ], [ 988, 855, 1166 ] ]
        },
        msa84: {
            name: "Dallas, Plano, Irving - TX",
            data: [ [ 52192, 48647, 57870 ], [ 36344, 33635, 41394 ], [ 1777, 1746, 2010 ], [ 807, 807, 992 ], [ 85561, 82292, 111426 ], [ 49993, 47705, 69161 ] ]
        },
        msa85: {
            name: "Dalton - GA",
            data: [ [ 1206, 1094, 1172 ], [ 737, 604, 629 ], [ 68, 67, 84 ], [ 34, 33, 38 ], [ 2006, 1784, 2383 ], [ 871, 878, 1280 ] ]
        },
        msa86: {
            name: "Danville - IL",
            data: [ [ 508, 514, 508 ], [ 328, 305, 323 ], [ 129, 128, 133 ], [ 86, 65, 74 ], [ 1220, 1153, 1328 ], [ 625, 567, 718 ] ]
        },
        msa87: {
            name: "Davenport, Moline, Rock Island - IA, IL",
            data: [ [ 4823, 4334, 4843 ], [ 3693, 3249, 3718 ], [ 587, 550, 640 ], [ 406, 386, 456 ], [ 12974, 9860, 13525 ], [ 8961, 6407, 9552 ] ]
        },
        msa88: {
            name: "Dayton - OH",
            data: [ [ 8051, 7087, 8287 ], [ 5988, 5221, 6102 ], [ 389, 485, 486 ], [ 184, 208, 262 ], [ 24035, 21381, 29048 ], [ 14687, 12728, 18265 ] ]
        },
        msa89: {
            name: "Decatur - AL",
            data: [ [ 1776, 1814, 2020 ], [ 1052, 965, 1085 ], [ 100, 223, 146 ], [ 44, 124, 65 ], [ 3971, 3397, 4242 ], [ 1892, 1639, 2205 ] ]
        },
        msa90: {
            name: "Decatur - IL",
            data: [ [ 979, 1017, 1125 ], [ 808, 821, 931 ], [ 160, 82, 177 ], [ 108, 46, 145 ], [ 2265, 1796, 2711 ], [ 1588, 1214, 1983 ] ]
        },
        msa91: {
            name: "Deltona, Daytona Beach, Ormond Beach - FL",
            data: [ [ 4449, 4178, 4662 ], [ 2860, 2623, 2935 ], [ 199, 167, 202 ], [ 75, 47, 63 ], [ 6653, 6003, 11960 ], [ 2838, 2824, 6894 ] ]
        },
        msa92: {
            name: "Denver, Aurora, Lakewood - CO",
            data: [ [ 40730, 38616, 47604 ], [ 29768, 27699, 35544 ], [ 1429, 1398, 1800 ], [ 858, 888, 1225 ], [ 105844, 85587, 128808 ], [ 70254, 53687, 87991 ] ]
        },
        msa93: {
            name: "Des Moines, West Des Moines - IA",
            data: [ [ 8076, 7623, 8824 ], [ 6192, 5843, 6919 ], [ 718, 637, 665 ], [ 459, 419, 476 ], [ 22140, 19377, 25721 ], [ 14474, 12583, 18085 ] ]
        },
        msa94: {
            name: "Detroit, Livonia, Dearborn - MI",
            data: [ [ 12177, 11372, 12676 ], [ 7660, 7393, 8483 ], [ 555, 487, 678 ], [ 134, 117, 191 ], [ 19072, 17613, 38295 ], [ 10381, 10453, 26344 ] ]
        },
        msa95: {
            name: "Dothan - AL",
            data: [ [ 1540, 1467, 1534 ], [ 982, 943, 947 ], [ 144, 118, 127 ], [ 71, 70, 80 ], [ 3107, 2774, 3522 ], [ 1647, 1515, 2120 ] ]
        },
        msa96: {
            name: "Dover - DE",
            data: [ [ 2002, 1774, 2109 ], [ 1369, 1194, 1455 ], [ 176, 141, 145 ], [ 96, 84, 80 ], [ 4331, 3734, 5268 ], [ 2186, 1945, 3167 ] ]
        },
        msa97: {
            name: "Dubuque - IA",
            data: [ [ 1348, 1233, 1302 ], [ 1122, 1031, 1099 ], [ 54, 69, 47 ], [ 32, 49, 36 ], [ 4400, 3387, 4722 ], [ 3534, 2676, 3867 ] ]
        },
        msa98: {
            name: "Duluth - MN, WI",
            data: [ [ 2417, 2382, 2678 ], [ 1803, 1848, 2042 ], [ 462, 406, 505 ], [ 297, 260, 340 ], [ 8524, 6781, 8647 ], [ 5134, 4021, 5544 ] ]
        },
        msa99: {
            name: "Durham, Chapel Hill - NC",
            data: [ [ 5914, 5434, 6102 ], [ 4187, 3729, 4366 ], [ 232, 233, 286 ], [ 128, 147, 160 ], [ 13925, 13038, 15885 ], [ 8867, 8022, 10068 ] ]
        },
        msa100: {
            name: "Eau Claire - WI",
            data: [ [ 1573, 1411, 1712 ], [ 1209, 1075, 1334 ], [ 296, 259, 368 ], [ 224, 186, 297 ], [ 6241, 4898, 6356 ], [ 4214, 3475, 4741 ] ]
        },
        msa101: {
            name: "Edison, New Brunswick - NJ",
            data: [ [ 23858, 21370, 23344 ], [ 15799, 14163, 15288 ], [ 2139, 2178, 2418 ], [ 1321, 1262, 1491 ], [ 80132, 73279, 93993 ], [ 46759, 42750, 57210 ] ]
        },
        msa102: {
            name: "El Centro - CA",
            data: [ [ 1733, 1560, 1438 ], [ 1214, 1143, 1020 ], [ 34, 20, 31 ], [ 10, 5, 8 ], [ 1124, 1069, 2395 ], [ 467, 543, 1404 ] ]
        },
        msa103: {
            name: "El Paso - TX",
            data: [ [ 8069, 7865, 8835 ], [ 5502, 5168, 5857 ], [ 810, 664, 685 ], [ 380, 310, 306 ], [ 9606, 9726, 11709 ], [ 4465, 4545, 5858 ] ]
        },
        msa104: {
            name: "Elizabethtown, Fort Knox - KY",
            data: [ [ 2157, 1604, 1573 ], [ 1474, 1011, 1028 ], [ 121, 108, 114 ], [ 69, 65, 74 ], [ 3172, 3016, 4184 ], [ 1789, 1670, 2575 ] ]
        },
        msa105: {
            name: "Elkhart, Goshen - IN",
            data: [ [ 1913, 1825, 2120 ], [ 1321, 1351, 1602 ], [ 92, 103, 137 ], [ 59, 68, 102 ], [ 4894, 4294, 5426 ], [ 2686, 2492, 3398 ] ]
        },
        msa106: {
            name: "Elmira - NY",
            data: [ [ 776, 824, 834 ], [ 584, 614, 621 ], [ 171, 185, 207 ], [ 128, 144, 157 ], [ 1327, 1134, 1314 ], [ 807, 702, 906 ] ]
        },
        msa107: {
            name: "Erie - PA",
            data: [ [ 2601, 2313, 2515 ], [ 2029, 1773, 1987 ], [ 489, 517, 569 ], [ 347, 307, 379 ], [ 5160, 4732, 6029 ], [ 2866, 2699, 3731 ] ]
        },
        msa108: {
            name: "Eugene - OR",
            data: [ [ 3536, 2959, 3288 ], [ 2420, 2078, 2350 ], [ 251, 173, 304 ], [ 150, 105, 200 ], [ 10788, 8614, 11854 ], [ 6492, 4989, 7623 ] ]
        },
        msa109: {
            name: "Evansville - IN, KY",
            data: [ [ 4297, 4047, 4126 ], [ 3122, 2815, 2902 ], [ 343, 436, 531 ], [ 196, 274, 361 ], [ 10790, 9244, 11066 ], [ 6628, 5496, 7207 ] ]
        },
        msa110: {
            name: "Fairbanks - AK",
            data: [ [ 1289, 1132, 1268 ], [ 1065, 899, 996 ], [ 95, 86, 127 ], [ 48, 52, 77 ], [ 1919, 1917, 2793 ], [ 1225, 1303, 1934 ] ]
        },
        msa111: {
            name: "Fargo - ND, MN",
            data: [ [ 2983, 2636, 3483 ], [ 2494, 2237, 2982 ], [ 187, 190, 214 ], [ 144, 153, 166 ], [ 6148, 5268, 6836 ], [ 4197, 3639, 5042 ] ]
        },
        msa112: {
            name: "Farmington - NM",
            data: [ [ 997, 1323, 1485 ], [ 637, 581, 722 ], [ 60, 72, 77 ], [ 41, 39, 45 ], [ 1750, 1458, 1970 ], [ 983, 795, 1175 ] ]
        },
        msa113: {
            name: "Fayetteville - NC",
            data: [ [ 5194, 4648, 4300 ], [ 3990, 3348, 2915 ], [ 235, 277, 323 ], [ 118, 142, 162 ], [ 8788, 9297, 11012 ], [ 4629, 4970, 6481 ] ]
        },
        msa114: {
            name: "Fayetteville, Springdale, Rogers - AR, MO",
            data: [ [ 6421, 6411, 7345 ], [ 4518, 4420, 5218 ], [ 232, 182, 255 ], [ 94, 107, 169 ], [ 11765, 9421, 14772 ], [ 7080, 5622, 9784 ] ]
        },
        msa115: {
            name: "Flagstaff - AZ",
            data: [ [ 1012, 1148, 1286 ], [ 688, 723, 828 ], [ 53, 50, 37 ], [ 20, 24, 17 ], [ 2888, 2212, 3245 ], [ 1684, 1284, 2057 ] ]
        },
        msa116: {
            name: "Flint - MI",
            data: [ [ 3576, 3258, 3877 ], [ 2255, 2086, 2547 ], [ 185, 190, 206 ], [ 68, 60, 69 ], [ 5817, 5697, 10658 ], [ 3244, 3213, 6805 ] ]
        },
        msa117: {
            name: "Florence - SC",
            data: [ [ 1824, 2005, 2254 ], [ 1086, 971, 1146 ], [ 110, 117, 131 ], [ 54, 62, 82 ], [ 3468, 2999, 3422 ], [ 1700, 1548, 1936 ] ]
        },
        msa118: {
            name: "Florence, Muscle Shoals - AL",
            data: [ [ 1485, 1392, 1580 ], [ 963, 953, 1128 ], [ 111, 129, 122 ], [ 71, 84, 86 ], [ 3364, 3067, 3603 ], [ 1860, 1752, 2301 ] ]
        },
        msa119: {
            name: "Fond du Lac - WI",
            data: [ [ 859, 709, 887 ], [ 672, 550, 687 ], [ 166, 157, 225 ], [ 137, 129, 188 ], [ 4681, 3721, 5181 ], [ 3473, 2562, 3795 ] ]
        },
        msa120: {
            name: "Fort Collins - CO",
            data: [ [ 4784, 4463, 5725 ], [ 3502, 3273, 4296 ], [ 208, 198, 281 ], [ 135, 136, 207 ], [ 12260, 10020, 14599 ], [ 8431, 6731, 10450 ] ]
        },
        msa121: {
            name: "Fort Lauderdale, Pompano Beach, Deerfield Beach - FL",
            data: [ [ 20161, 17531, 18270 ], [ 11392, 10721, 11451 ], [ 459, 428, 545 ], [ 184, 178, 238 ], [ 21530, 19831, 37492 ], [ 10287, 10264, 21616 ] ]
        },
        msa122: {
            name: "Fort Smith - AR, OK",
            data: [ [ 3254, 3387, 3391 ], [ 2118, 1920, 1942 ], [ 370, 256, 320 ], [ 184, 169, 185 ], [ 5172, 4502, 5465 ], [ 3001, 2532, 3268 ] ]
        },
        msa123: {
            name: "Fort Wayne - IN",
            data: [ [ 4933, 4859, 5388 ], [ 3865, 3724, 4196 ], [ 357, 295, 354 ], [ 198, 169, 230 ], [ 12889, 10942, 14866 ], [ 8443, 6820, 10172 ] ]
        },
        msa124: {
            name: "Fort Worth, Arlington - TX",
            data: [ [ 26438, 24987, 28610 ], [ 18519, 17122, 20472 ], [ 1269, 1209, 1341 ], [ 579, 601, 694 ], [ 38634, 38090, 51135 ], [ 21235, 21194, 30343 ] ]
        },
        msa125: {
            name: "Fresno - CA",
            data: [ [ 8919, 8608, 7876 ], [ 6248, 6134, 5689 ], [ 311, 297, 253 ], [ 149, 171, 153 ], [ 12786, 10774, 20357 ], [ 6994, 5793, 12613 ] ]
        },
        msa126: {
            name: "Gadsden - AL",
            data: [ [ 812, 950, 1016 ], [ 454, 550, 572 ], [ 74, 76, 92 ], [ 40, 44, 48 ], [ 2071, 1588, 2067 ], [ 1045, 799, 1158 ] ]
        },
        msa127: {
            name: "Gainesville - FL",
            data: [ [ 2191, 2188, 2537 ], [ 1468, 1352, 1512 ], [ 146, 100, 102 ], [ 61, 46, 47 ], [ 4361, 3487, 4925 ], [ 2303, 1942, 3050 ] ]
        },
        msa128: {
            name: "Gainesville - GA",
            data: [ [ 1535, 1595, 1513 ], [ 998, 1088, 1038 ], [ 53, 45, 61 ], [ 22, 22, 27 ], [ 3698, 3587, 4929 ], [ 1854, 1992, 2957 ] ]
        },
        msa129: {
            name: "Gary - IN",
            data: [ [ 6092, 5936, 7011 ], [ 4434, 4533, 5423 ], [ 608, 578, 744 ], [ 344, 330, 457 ], [ 21056, 17656, 22220 ], [ 11827, 10260, 14137 ] ]
        },
        msa130: {
            name: "Glens Falls - NY",
            data: [ [ 1183, 1019, 1190 ], [ 761, 661, 772 ], [ 234, 203, 248 ], [ 139, 133, 164 ], [ 2117, 2030, 2405 ], [ 1001, 981, 1294 ] ]
        },
        msa131: {
            name: "Goldsboro - NC",
            data: [ [ 1090, 997, 1141 ], [ 737, 614, 687 ], [ 83, 91, 87 ], [ 43, 57, 52 ], [ 1959, 2027, 2539 ], [ 1158, 1263, 1620 ] ]
        },
        msa132: {
            name: "Grand Forks - ND, MN",
            data: [ [ 1104, 1071, 1216 ], [ 858, 850, 938 ], [ 122, 108, 141 ], [ 95, 78, 110 ], [ 2065, 1771, 2535 ], [ 1387, 1189, 1861 ] ]
        },
        msa133: {
            name: "Grand Junction - CO",
            data: [ [ 2012, 1896, 2375 ], [ 1473, 1385, 1861 ], [ 158, 144, 148 ], [ 85, 90, 99 ], [ 5576, 3677, 5825 ], [ 3598, 2210, 4057 ] ]
        },
        msa134: {
            name: "Grand Rapids, Wyoming - MI",
            data: [ [ 7998, 8057, 10183 ], [ 5637, 5688, 7250 ], [ 475, 532, 625 ], [ 266, 300, 366 ], [ 21889, 18733, 26353 ], [ 14291, 11860, 17706 ] ]
        },
        msa135: {
            name: "Great Falls - MT",
            data: [ [ 1106, 1002, 1147 ], [ 874, 776, 900 ], [ 183, 156, 195 ], [ 124, 101, 133 ], [ 2514, 2238, 3190 ], [ 1661, 1380, 2189 ] ]
        },
        msa136: {
            name: "Greeley - CO",
            data: [ [ 4567, 4431, 5415 ], [ 3204, 2978, 3736 ], [ 119, 129, 141 ], [ 73, 66, 84 ], [ 7700, 6414, 10082 ], [ 4822, 3915, 6697 ] ]
        },
        msa137: {
            name: "Green Bay - WI",
            data: [ [ 3172, 2810, 3261 ], [ 2468, 2204, 2583 ], [ 392, 390, 501 ], [ 299, 301, 427 ], [ 16957, 11676, 15764 ], [ 12235, 8083, 11711 ] ]
        },
        msa138: {
            name: "Greensboro, High Point - NC",
            data: [ [ 7076, 6786, 7673 ], [ 4766, 4337, 4731 ], [ 327, 312, 393 ], [ 175, 181, 232 ], [ 17519, 16357, 19107 ], [ 9930, 9092, 11417 ] ]
        },
        msa139: {
            name: "Greenville - NC",
            data: [ [ 2058, 1923, 2075 ], [ 1383, 1113, 1116 ], [ 87, 116, 94 ], [ 60, 58, 55 ], [ 3305, 3047, 3723 ], [ 1956, 1826, 2311 ] ]
        },
        msa140: {
            name: "Greenville, Anderson, Mauldin - SC",
            data: [ [ 7390, 7829, 9384 ], [ 4823, 4779, 5815 ], [ 350, 359, 463 ], [ 217, 209, 275 ], [ 15238, 13831, 17653 ], [ 8643, 7925, 11048 ] ]
        },
        msa141: {
            name: "Guayama - PR",
            data: [ [ 443, 519, 435 ], [ 242, 269, 268 ], [ 60, 43, 54 ], [ 27, 18, 32 ], [ 392, 300, 438 ], [ 179, 165, 264 ] ]
        },
        msa142: {
            name: "Gulfport, Biloxi, Pascagoula - MS",
            data: [ [ 2356, 2192, 2148 ], [ 1411, 1344, 1328 ], [ 282, 195, 148 ], [ 139, 91, 64 ], [ 4725, 3916, 4793 ], [ 2077, 1718, 2416 ] ]
        },
        msa143: {
            name: "Hagerstown, Martinsburg - MD, WV",
            data: [ [ 3152, 2939, 3028 ], [ 2180, 2051, 2118 ], [ 305, 227, 262 ], [ 178, 135, 145 ], [ 6693, 5571, 7984 ], [ 3530, 2931, 4822 ] ]
        },
        msa144: {
            name: "Hanford, Corcoran - CA",
            data: [ [ 1181, 1029, 1165 ], [ 864, 765, 883 ], [ 59, 42, 42 ], [ 34, 16, 21 ], [ 1626, 1448, 2595 ], [ 815, 722, 1543 ] ]
        },
        msa145: {
            name: "Harrisburg, Carlisle - PA",
            data: [ [ 6319, 5585, 6014 ], [ 4733, 4119, 4558 ], [ 783, 764, 1094 ], [ 537, 522, 765 ], [ 16586, 14227, 17666 ], [ 10157, 8537, 11142 ] ]
        },
        msa146: {
            name: "Harrisonburg - VA",
            data: [ [ 1e3, 937, 1085 ], [ 753, 701, 768 ], [ 100, 88, 107 ], [ 69, 61, 80 ], [ 2761, 2293, 2956 ], [ 1783, 1403, 1977 ] ]
        },
        msa147: {
            name: "Hartford, West Hartford, East Hartford - CT",
            data: [ [ 12076, 10431, 11930 ], [ 8908, 7514, 8890 ], [ 1507, 1521, 1785 ], [ 1035, 1073, 1319 ], [ 38040, 30833, 42115 ], [ 23165, 18454, 27012 ] ]
        },
        msa148: {
            name: "Hattiesburg - MS",
            data: [ [ 1848, 1709, 1817 ], [ 1081, 928, 1025 ], [ 106, 63, 81 ], [ 51, 42, 44 ], [ 2825, 2195, 2714 ], [ 1514, 1222, 1672 ] ]
        },
        msa149: {
            name: "Hickory, Lenoir, Morganton - NC",
            data: [ [ 2849, 2928, 3467 ], [ 1878, 1779, 1926 ], [ 208, 249, 324 ], [ 122, 140, 175 ], [ 7333, 6967, 8060 ], [ 4295, 4028, 4862 ] ]
        },
        msa150: {
            name: "Hinesville - GA",
            data: [ [ 665, 927, 840 ], [ 501, 699, 631 ], [ 34, 22, 40 ], [ 16, 11, 17 ], [ 1303, 1350, 1589 ], [ 601, 670, 848 ] ]
        },
        msa151: {
            name: "Hot Springs - AR",
            data: [ [ 1276, 1234, 1485 ], [ 735, 658, 717 ], [ 121, 75, 95 ], [ 46, 33, 51 ], [ 2513, 2074, 2891 ], [ 1302, 1052, 1572 ] ]
        },
        msa152: {
            name: "Houma, Thibodaux - LA",
            data: [ [ 2345, 2494, 3095 ], [ 1329, 1207, 1574 ], [ 332, 324, 318 ], [ 205, 199, 192 ], [ 4746, 4192, 4627 ], [ 2776, 2423, 2872 ] ]
        },
        msa153: {
            name: "Houston, The Woodlands, Sugar Land - TX",
            data: [ [ 70943, 67816, 81316 ], [ 48948, 45710, 56848 ], [ 3187, 3103, 3254 ], [ 1353, 1461, 1398 ], [ 91536, 93713, 115122 ], [ 50369, 52841, 68989 ] ]
        },
        msa154: {
            name: "Huntington, Ashland - WV, KY, OH",
            data: [ [ 2774, 2867, 2861 ], [ 1716, 1642, 1617 ], [ 561, 573, 667 ], [ 324, 336, 384 ], [ 5701, 5294, 5679 ], [ 3178, 2960, 3344 ] ]
        },
        msa155: {
            name: "Huntsville - AL",
            data: [ [ 7072, 6702, 7012 ], [ 5147, 4745, 5094 ], [ 279, 657, 374 ], [ 145, 404, 174 ], [ 15751, 13194, 17994 ], [ 8534, 6819, 10278 ] ]
        },
        msa156: {
            name: "Idaho Falls - ID",
            data: [ [ 1519, 1362, 1502 ], [ 1201, 1057, 1142 ], [ 102, 90, 134 ], [ 68, 46, 101 ], [ 3985, 2948, 4046 ], [ 2352, 1667, 2560 ] ]
        },
        msa157: {
            name: "Indianapolis, Carmel, Anderson - IN",
            data: [ [ 23775, 23319, 25661 ], [ 17050, 16558, 19228 ], [ 1043, 1165, 1501 ], [ 573, 615, 888 ], [ 67131, 54926, 72521 ], [ 40409, 32973, 47336 ] ]
        },
        msa158: {
            name: "Iowa City - IA",
            data: [ [ 2301, 2153, 2269 ], [ 1839, 1763, 1857 ], [ 237, 169, 207 ], [ 203, 142, 166 ], [ 4860, 3825, 5079 ], [ 3461, 2646, 3850 ] ]
        },
        msa159: {
            name: "Ithaca - NY",
            data: [ [ 786, 697, 764 ], [ 624, 557, 648 ], [ 146, 124, 171 ], [ 118, 107, 142 ], [ 1140, 971, 1191 ], [ 804, 680, 905 ] ]
        },
        msa160: {
            name: "Jackson - MI",
            data: [ [ 1218, 1119, 1389 ], [ 843, 784, 978 ], [ 170, 165, 159 ], [ 85, 93, 84 ], [ 2886, 2656, 4535 ], [ 1663, 1456, 2862 ] ]
        },
        msa161: {
            name: "Jackson - MS",
            data: [ [ 4912, 4631, 5257 ], [ 3318, 3040, 3327 ], [ 320, 218, 241 ], [ 146, 129, 122 ], [ 11109, 8761, 11407 ], [ 6413, 4908, 7154 ] ]
        },
        msa162: {
            name: "Jackson - TN",
            data: [ [ 1154, 1157, 1252 ], [ 785, 763, 792 ], [ 63, 43, 55 ], [ 28, 28, 35 ], [ 2332, 1904, 2554 ], [ 1256, 971, 1440 ] ]
        },
        msa163: {
            name: "Jacksonville - FL",
            data: [ [ 18320, 16705, 18755 ], [ 11693, 10626, 12031 ], [ 918, 596, 677 ], [ 503, 313, 395 ], [ 26937, 22509, 37573 ], [ 13310, 12015, 22641 ] ]
        },
        msa164: {
            name: "Jacksonville - NC",
            data: [ [ 3872, 2997, 2788 ], [ 3061, 2347, 2130 ], [ 128, 112, 129 ], [ 79, 65, 76 ], [ 4159, 4359, 5971 ], [ 2233, 2412, 3601 ] ]
        },
        msa165: {
            name: "Janesville, Beloit - WI",
            data: [ [ 1381, 1261, 1569 ], [ 1031, 943, 1194 ], [ 153, 151, 174 ], [ 95, 94, 121 ], [ 5518, 4614, 6010 ], [ 3640, 2910, 4077 ] ]
        },
        msa166: {
            name: "Jefferson City - MO",
            data: [ [ 1681, 1534, 1729 ], [ 1196, 1076, 1232 ], [ 303, 270, 347 ], [ 247, 209, 271 ], [ 4046, 3482, 4792 ], [ 2897, 2333, 3404 ] ]
        },
        msa167: {
            name: "Johnson City - TN",
            data: [ [ 2120, 2305, 2739 ], [ 1350, 1324, 1506 ], [ 200, 193, 225 ], [ 129, 123, 157 ], [ 4076, 3615, 4461 ], [ 2349, 2025, 2687 ] ]
        },
        msa168: {
            name: "Johnstown - PA",
            data: [ [ 1152, 1051, 973 ], [ 885, 802, 738 ], [ 414, 382, 398 ], [ 282, 253, 271 ], [ 2353, 2210, 2940 ], [ 1391, 1309, 1831 ] ]
        },
        msa169: {
            name: "Jonesboro - AR",
            data: [ [ 1523, 1508, 1640 ], [ 1025, 1007, 1107 ], [ 122, 104, 104 ], [ 66, 59, 68 ], [ 2232, 2066, 2656 ], [ 1338, 1259, 1698 ] ]
        },
        msa170: {
            name: "Joplin - MO",
            data: [ [ 2033, 2378, 2278 ], [ 1361, 1584, 1502 ], [ 152, 116, 167 ], [ 61, 65, 91 ], [ 3842, 3091, 4039 ], [ 2180, 1719, 2551 ] ]
        },
        msa171: {
            name: "Kalamazoo, Portage - MI",
            data: [ [ 2970, 3002, 3630 ], [ 2205, 2210, 2746 ], [ 209, 234, 205 ], [ 113, 123, 99 ], [ 7678, 6894, 10304 ], [ 4851, 4276, 7061 ] ]
        },
        msa172: {
            name: "Kankakee - IL",
            data: [ [ 827, 814, 824 ], [ 551, 560, 563 ], [ 124, 164, 175 ], [ 87, 103, 119 ], [ 2936, 2274, 3183 ], [ 1805, 1209, 2021 ] ]
        },
        msa173: {
            name: "Kansas City - MO, KS",
            data: [ [ 24023, 21812, 25497 ], [ 17793, 16498, 19730 ], [ 1501, 1332, 1897 ], [ 878, 844, 1265 ], [ 67338, 55302, 74522 ], [ 42950, 33398, 49186 ] ]
        },
        msa174: {
            name: "Kennewick, Richland - WA",
            data: [ [ 4703, 3912, 3680 ], [ 3566, 2989, 2916 ], [ 334, 265, 290 ], [ 212, 163, 194 ], [ 8053, 7326, 9363 ], [ 4929, 4535, 6233 ] ]
        },
        msa175: {
            name: "Killeen, Temple - TX",
            data: [ [ 6184, 5543, 5809 ], [ 4634, 3944, 4126 ], [ 209, 271, 302 ], [ 116, 165, 151 ], [ 5875, 5946, 8338 ], [ 3417, 3301, 4795 ] ]
        },
        msa176: {
            name: "Kingsport, Bristol, Bristol - TN, VA",
            data: [ [ 3074, 3221, 3746 ], [ 1934, 1770, 2027 ], [ 345, 383, 390 ], [ 201, 250, 248 ], [ 5961, 5226, 6539 ], [ 3259, 2802, 3697 ] ]
        },
        msa177: {
            name: "Kingston - NY",
            data: [ [ 1311, 1116, 1115 ], [ 915, 730, 799 ], [ 144, 155, 136 ], [ 88, 93, 90 ], [ 2903, 2644, 3164 ], [ 1413, 1276, 1676 ] ]
        },
        msa178: {
            name: "Knoxville - TN",
            data: [ [ 8908, 9438, 9940 ], [ 6005, 5446, 6239 ], [ 633, 572, 703 ], [ 377, 381, 472 ], [ 19944, 16141, 22460 ], [ 11954, 9195, 13547 ] ]
        },
        msa179: {
            name: "Kokomo - IN",
            data: [ [ 941, 831, 1067 ], [ 699, 603, 772 ], [ 58, 72, 80 ], [ 33, 50, 56 ], [ 2234, 1985, 3260 ], [ 1175, 1069, 1979 ] ]
        },
        msa180: {
            name: "La Crosse, Onalaska - WI, MN",
            data: [ [ 1355, 1236, 1535 ], [ 1017, 929, 1211 ], [ 197, 169, 241 ], [ 147, 128, 216 ], [ 5481, 4809, 6038 ], [ 4054, 3471, 4688 ] ]
        },
        msa181: {
            name: "Lafayette - LA",
            data: [ [ 3965, 3721, 4605 ], [ 2336, 2158, 2753 ], [ 259, 221, 275 ], [ 145, 125, 170 ], [ 6175, 5352, 6376 ], [ 3545, 2881, 3786 ] ]
        },
        msa182: {
            name: "Lake Charles - LA",
            data: [ [ 2170, 2180, 2649 ], [ 1303, 1243, 1587 ], [ 203, 207, 230 ], [ 102, 94, 125 ], [ 3651, 3362, 3705 ], [ 2078, 1891, 2244 ] ]
        },
        msa183: {
            name: "Lake County, Kenosha County - IL",
            data: [ [ 7604, 7392, 8751 ], [ 5369, 5221, 6385 ], [ 508, 595, 434 ], [ 315, 355, 259 ], [ 36778, 29139, 39327 ], [ 24302, 18835, 27176 ] ]
        },
        msa184: {
            name: "Lake Havasu City, Kingman - AZ",
            data: [ [ 1948, 1595, 1896 ], [ 1297, 1066, 1280 ], [ 124, 88, 120 ], [ 38, 36, 50 ], [ 3221, 2897, 4860 ], [ 1563, 1484, 2955 ] ]
        },
        msa185: {
            name: "Lakeland, Winter Haven - FL",
            data: [ [ 5788, 4889, 5421 ], [ 3623, 3050, 3264 ], [ 342, 269, 270 ], [ 169, 128, 128 ], [ 6519, 5487, 10290 ], [ 2942, 2688, 6071 ] ]
        },
        msa186: {
            name: "Lancaster - PA",
            data: [ [ 5318, 4706, 5317 ], [ 4036, 3547, 4104 ], [ 644, 625, 621 ], [ 491, 449, 450 ], [ 13363, 10844, 14234 ], [ 8165, 6307, 9178 ] ]
        },
        msa187: {
            name: "Lansing, East Lansing - MI",
            data: [ [ 4164, 3890, 4606 ], [ 2923, 2759, 3337 ], [ 321, 294, 353 ], [ 184, 179, 216 ], [ 10861, 8971, 13755 ], [ 6523, 5333, 8941 ] ]
        },
        msa188: {
            name: "Laredo - TX",
            data: [ [ 1636, 1514, 1792 ], [ 1092, 1003, 1217 ], [ 108, 106, 92 ], [ 20, 26, 31 ], [ 1735, 1625, 1990 ], [ 617, 649, 869 ] ]
        },
        msa189: {
            name: "Las Cruces - NM",
            data: [ [ 2146, 1961, 2165 ], [ 1447, 1174, 1326 ], [ 140, 123, 118 ], [ 50, 64, 54 ], [ 4002, 3609, 4454 ], [ 2229, 2005, 2659 ] ]
        },
        msa190: {
            name: "Las Vegas, Henderson, Paradise - NV",
            data: [ [ 30515, 25650, 25742 ], [ 20805, 17787, 17453 ], [ 337, 349, 435 ], [ 114, 128, 154 ], [ 22089, 17244, 45481 ], [ 12503, 9853, 30090 ] ]
        },
        msa191: {
            name: "Lawrence - KS",
            data: [ [ 1214, 999, 1170 ], [ 939, 789, 916 ], [ 77, 73, 152 ], [ 47, 49, 116 ], [ 3067, 2462, 3292 ], [ 2077, 1642, 2302 ] ]
        },
        msa192: {
            name: "Lawton - OK",
            data: [ [ 1720, 1414, 1440 ], [ 1345, 1094, 1118 ], [ 130, 75, 45 ], [ 61, 44, 18 ], [ 2111, 2034, 2380 ], [ 1130, 1076, 1396 ] ]
        },
        msa193: {
            name: "Lebanon - PA",
            data: [ [ 1373, 1232, 1309 ], [ 1025, 935, 1015 ], [ 170, 183, 207 ], [ 116, 131, 162 ], [ 3384, 2937, 3747 ], [ 2025, 1788, 2442 ] ]
        },
        msa194: {
            name: "Lewiston - ID, WA",
            data: [ [ 693, 641, 688 ], [ 520, 438, 482 ], [ 100, 93, 84 ], [ 63, 56, 54 ], [ 2087, 1624, 2305 ], [ 1237, 951, 1444 ] ]
        },
        msa195: {
            name: "Lewiston, Auburn - ME",
            data: [ [ 1024, 910, 1020 ], [ 715, 639, 715 ], [ 156, 163, 150 ], [ 100, 117, 103 ], [ 2524, 2233, 2956 ], [ 1363, 1180, 1731 ] ]
        },
        msa196: {
            name: "Lexington, Fayette - KY",
            data: [ [ 5895, 5911, 6955 ], [ 4190, 3829, 4651 ], [ 296, 242, 287 ], [ 162, 122, 191 ], [ 15008, 13011, 17691 ], [ 9006, 7827, 11420 ] ]
        },
        msa197: {
            name: "Lima - OH",
            data: [ [ 829, 782, 853 ], [ 576, 552, 614 ], [ 63, 41, 59 ], [ 22, 20, 32 ], [ 2715, 2272, 3104 ], [ 1660, 1374, 2025 ] ]
        },
        msa198: {
            name: "Lincoln - NE",
            data: [ [ 3574, 3238, 3952 ], [ 2888, 2690, 3279 ], [ 297, 275, 337 ], [ 223, 205, 235 ], [ 11008, 8875, 12040 ], [ 8040, 6367, 8904 ] ]
        },
        msa199: {
            name: "Little Rock, North Little Rock, Conway - AR",
            data: [ [ 10378, 9585, 10373 ], [ 7455, 6515, 7197 ], [ 662, 576, 619 ], [ 305, 285, 368 ], [ 18243, 14538, 20501 ], [ 10506, 8108, 12564 ] ]
        },
        msa200: {
            name: "Logan - UT, ID",
            data: [ [ 1400, 1310, 1385 ], [ 1067, 970, 1082 ], [ 104, 85, 101 ], [ 74, 50, 66 ], [ 3970, 2941, 4120 ], [ 2663, 1906, 2961 ] ]
        },
        msa201: {
            name: "Longview - TX",
            data: [ [ 2518, 2703, 2704 ], [ 1563, 1554, 1627 ], [ 287, 226, 279 ], [ 190, 128, 170 ], [ 2201, 2332, 2442 ], [ 1257, 1318, 1369 ] ]
        },
        msa202: {
            name: "Longview - WA",
            data: [ [ 1037, 872, 1060 ], [ 645, 558, 688 ], [ 83, 64, 93 ], [ 46, 39, 57 ], [ 3227, 2566, 3670 ], [ 1843, 1429, 2177 ] ]
        },
        msa203: {
            name: "Los Angeles, Long Beach, Glendale - CA",
            data: [ [ 84544, 75205, 75798 ], [ 53690, 47457, 49623 ], [ 5719, 6700, 6186 ], [ 3357, 3785, 4050 ], [ 210565, 200072, 302299 ], [ 125254, 119496, 192385 ] ]
        },
        msa204: {
            name: "Louisville/Jefferson County - KY, IN",
            data: [ [ 15798, 14822, 17430 ], [ 10854, 10021, 12037 ], [ 1422, 1344, 1570 ], [ 825, 817, 969 ], [ 44849, 37534, 49062 ], [ 25348, 21089, 29759 ] ]
        },
        msa205: {
            name: "Lubbock - TX",
            data: [ [ 3294, 2883, 3427 ], [ 2596, 2235, 2705 ], [ 233, 181, 148 ], [ 114, 88, 82 ], [ 3627, 3292, 4224 ], [ 2218, 1982, 2718 ] ]
        },
        msa206: {
            name: "Lynchburg - VA",
            data: [ [ 2418, 2199, 2434 ], [ 1708, 1573, 1630 ], [ 276, 248, 221 ], [ 183, 147, 139 ], [ 5982, 5235, 6069 ], [ 3778, 3123, 3883 ] ]
        },
        msa207: {
            name: "Macon - GA",
            data: [ [ 1600, 1480, 1583 ], [ 967, 875, 955 ], [ 122, 129, 127 ], [ 57, 74, 62 ], [ 3799, 3738, 4407 ], [ 1814, 1913, 2545 ] ]
        },
        msa208: {
            name: "Madera - CA",
            data: [ [ 1483, 1424, 1190 ], [ 1014, 948, 831 ], [ 50, 47, 37 ], [ 23, 22, 21 ], [ 1823, 1652, 3251 ], [ 863, 833, 1960 ] ]
        },
        msa209: {
            name: "Madison - WI",
            data: [ [ 6423, 5879, 7227 ], [ 4839, 4517, 5712 ], [ 1014, 1160, 1344 ], [ 790, 865, 1096 ], [ 30252, 25426, 33515 ], [ 21592, 17969, 25033 ] ]
        },
        msa210: {
            name: "Manchester, Nashua - NH",
            data: [ [ 4198, 3960, 4800 ], [ 3028, 2857, 3523 ], [ 387, 399, 458 ], [ 228, 236, 290 ], [ 14839, 12348, 17031 ], [ 8917, 7262, 10761 ] ]
        },
        msa211: {
            name: "Manhattan - KS",
            data: [ [ 1544, 1496, 1711 ], [ 1076, 1044, 1284 ], [ 134, 125, 157 ], [ 101, 90, 130 ], [ 2417, 2255, 2917 ], [ 1498, 1395, 1982 ] ]
        },
        msa212: {
            name: "Mankato, North Mankato - MN",
            data: [ [ 899, 893, 997 ], [ 685, 670, 801 ], [ 80, 68, 87 ], [ 48, 43, 70 ], [ 3027, 2509, 3345 ], [ 2039, 1696, 2412 ] ]
        },
        msa213: {
            name: "Mansfield - OH",
            data: [ [ 829, 813, 939 ], [ 584, 615, 719 ], [ 103, 96, 130 ], [ 63, 58, 81 ], [ 2149, 1920, 2830 ], [ 1232, 1110, 1751 ] ]
        },
        msa214: {
            name: "Mayagez - PR",
            data: [ [ 357, 461, 390 ], [ 177, 249, 206 ], [ 50, 40, 24 ], [ 23, 24, 14 ], [ 444, 414, 605 ], [ 226, 206, 314 ] ]
        },
        msa215: {
            name: "McAllen, Edinburg, Mission - TX",
            data: [ [ 4305, 3827, 3774 ], [ 2572, 2144, 2183 ], [ 638, 537, 525 ], [ 136, 126, 132 ], [ 4989, 5494, 5583 ], [ 1718, 2040, 2373 ] ]
        },
        msa216: {
            name: "Medford - OR",
            data: [ [ 2100, 1964, 2459 ], [ 1437, 1326, 1695 ], [ 117, 83, 118 ], [ 64, 50, 82 ], [ 4829, 4059, 6782 ], [ 2716, 2203, 4228 ] ]
        },
        msa217: {
            name: "Memphis - TN, MS, AR",
            data: [ [ 12290, 10836, 12003 ], [ 9093, 7872, 8825 ], [ 513, 470, 524 ], [ 220, 201, 228 ], [ 26194, 21777, 30181 ], [ 13699, 10896, 17429 ] ]
        },
        msa218: {
            name: "Merced - CA",
            data: [ [ 3087, 2460, 2135 ], [ 2040, 1676, 1429 ], [ 69, 72, 45 ], [ 46, 40, 17 ], [ 1936, 1849, 4774 ], [ 915, 932, 2885 ] ]
        },
        msa219: {
            name: "Miami, Miami Beach, Kendall - FL",
            data: [ [ 17495, 16227, 16994 ], [ 8891, 8910, 10032 ], [ 472, 475, 597 ], [ 158, 199, 257 ], [ 20366, 18858, 33782 ], [ 8720, 9005, 18389 ] ]
        },
        msa220: {
            name: "Michigan City, La Porte - IN",
            data: [ [ 927, 818, 927 ], [ 645, 594, 650 ], [ 115, 164, 151 ], [ 65, 92, 87 ], [ 3021, 2610, 3350 ], [ 1476, 1386, 1950 ] ]
        },
        msa221: {
            name: "Midland - TX",
            data: [ [ 1995, 2731, 3501 ], [ 1426, 1986, 2430 ], [ 129, 117, 141 ], [ 62, 61, 76 ], [ 1967, 1883, 2170 ], [ 1082, 1039, 1293 ] ]
        },
        msa222: {
            name: "Milwaukee, Waukesha, West Allis - WI",
            data: [ [ 12733, 11721, 14506 ], [ 9633, 9060, 11324 ], [ 1647, 1343, 1753 ], [ 1068, 955, 1321 ], [ 61161, 46852, 65019 ], [ 42075, 31173, 45847 ] ]
        },
        msa223: {
            name: "Minneapolis, St. Paul, Bloomington - MN, WI",
            data: [ [ 38508, 37817, 45280 ], [ 29178, 29380, 35971 ], [ 2859, 2484, 3150 ], [ 1710, 1534, 2155 ], [ 130279, 101198, 154336 ], [ 81867, 62168, 105427 ] ]
        },
        msa224: {
            name: "Missoula - MT",
            data: [ [ 1148, 1023, 1145 ], [ 838, 766, 856 ], [ 112, 89, 86 ], [ 87, 64, 60 ], [ 3438, 2629, 3857 ], [ 2267, 1714, 2684 ] ]
        },
        msa225: {
            name: "Mobile - AL",
            data: [ [ 4153, 3810, 3881 ], [ 2578, 2397, 2376 ], [ 250, 223, 227 ], [ 84, 63, 84 ], [ 8741, 7090, 8409 ], [ 4073, 3113, 4276 ] ]
        },
        msa226: {
            name: "Modesto - CA",
            data: [ [ 6943, 5924, 5400 ], [ 4845, 4225, 3939 ], [ 154, 144, 168 ], [ 71, 64, 93 ], [ 6854, 5532, 13031 ], [ 3833, 2993, 8521 ] ]
        },
        msa227: {
            name: "Monroe - LA",
            data: [ [ 2283, 2119, 2113 ], [ 1293, 1210, 1254 ], [ 146, 118, 135 ], [ 66, 59, 67 ], [ 3052, 2957, 3491 ], [ 1739, 1583, 1979 ] ]
        },
        msa228: {
            name: "Monroe - MI",
            data: [ [ 1538, 1606, 1685 ], [ 985, 1076, 1160 ], [ 76, 66, 105 ], [ 39, 32, 58 ], [ 3288, 2978, 5573 ], [ 1795, 1696, 3642 ] ]
        },
        msa229: {
            name: "Montgomery - AL",
            data: [ [ 3626, 3501, 3830 ], [ 2376, 2119, 2456 ], [ 155, 157, 179 ], [ 59, 72, 82 ], [ 8716, 7428, 10426 ], [ 4484, 3628, 5623 ] ]
        },
        msa230: {
            name: "Morgantown - WV",
            data: [ [ 1643, 1670, 1794 ], [ 1039, 1063, 1124 ], [ 159, 169, 212 ], [ 91, 101, 142 ], [ 2721, 2197, 2514 ], [ 1557, 1351, 1591 ] ]
        },
        msa231: {
            name: "Morristown - TN",
            data: [ [ 1338, 1532, 1641 ], [ 761, 752, 807 ], [ 132, 125, 166 ], [ 64, 73, 112 ], [ 3050, 2611, 3166 ], [ 1617, 1353, 1693 ] ]
        },
        msa232: {
            name: "Mount Vernon, Anacortes - WA",
            data: [ [ 1237, 1088, 1325 ], [ 869, 777, 947 ], [ 110, 92, 128 ], [ 69, 55, 74 ], [ 4142, 3306, 4521 ], [ 2546, 1975, 2811 ] ]
        },
        msa233: {
            name: "Muncie - IN",
            data: [ [ 817, 713, 826 ], [ 599, 504, 569 ], [ 90, 104, 160 ], [ 48, 67, 92 ], [ 2144, 1936, 2343 ], [ 1184, 999, 1374 ] ]
        },
        msa234: {
            name: "Muskegon - MI",
            data: [ [ 1360, 1462, 1636 ], [ 924, 1009, 1107 ], [ 120, 107, 105 ], [ 59, 47, 46 ], [ 3483, 3233, 4558 ], [ 1883, 1838, 2852 ] ]
        },
        msa235: {
            name: "Myrtle Beach, Conway, North Myrtle Beach - SC, NC",
            data: [ [ 3361, 3333, 3965 ], [ 2057, 1935, 2432 ], [ 188, 164, 189 ], [ 134, 96, 127 ], [ 6827, 5937, 8035 ], [ 3359, 3049, 4498 ] ]
        },
        msa236: {
            name: "Napa - CA",
            data: [ [ 1399, 1311, 1520 ], [ 902, 885, 959 ], [ 88, 104, 67 ], [ 48, 66, 43 ], [ 3892, 3220, 5111 ], [ 2250, 1836, 3154 ] ]
        },
        msa237: {
            name: "Naples, Immokalee, Marco Island - FL",
            data: [ [ 3388, 3079, 3547 ], [ 2113, 1962, 2305 ], [ 72, 88, 116 ], [ 31, 36, 53 ], [ 5064, 4491, 7356 ], [ 2483, 2393, 4213 ] ]
        },
        msa238: {
            name: "Nashville, Davidson--Murfreesboro--Franklin - TN",
            data: [ [ 21661, 21235, 26505 ], [ 15719, 15053, 18977 ], [ 1023, 994, 1166 ], [ 563, 539, 642 ], [ 49395, 44203, 60192 ], [ 27673, 23862, 35367 ] ]
        },
        msa239: {
            name: "Nassau, Suffolk - NY",
            data: [ [ 24512, 21727, 23518 ], [ 16445, 14871, 16051 ], [ 1776, 1866, 2632 ], [ 899, 977, 1529 ], [ 55635, 50048, 59772 ], [ 26633, 23104, 31288 ] ]
        },
        msa240: {
            name: "New Haven, Milford - CT",
            data: [ [ 7633, 6499, 6930 ], [ 5339, 4494, 5023 ], [ 943, 900, 872 ], [ 585, 538, 552 ], [ 22591, 19263, 25164 ], [ 13078, 11022, 15514 ] ]
        },
        msa241: {
            name: "New Orleans, Metairie - LA",
            data: [ [ 10535, 11048, 12728 ], [ 6582, 7080, 8356 ], [ 1211, 1103, 1131 ], [ 430, 399, 506 ], [ 26731, 25733, 29023 ], [ 13775, 12707, 15216 ] ]
        },
        msa242: {
            name: "New York, White Plains, Wayne - NJ, NY",
            data: [ [ 75574, 66424, 68755 ], [ 46147, 41813, 43226 ], [ 3929, 4533, 4616 ], [ 1989, 2243, 2431 ], [ 135185, 126546, 154554 ], [ 63905, 60586, 79701 ] ]
        },
        msa243: {
            name: "Newark, Union - NJ, PA",
            data: [ [ 20711, 18292, 19937 ], [ 12872, 11633, 12525 ], [ 1567, 1595, 1907 ], [ 928, 931, 1188 ], [ 63091, 55746, 73479 ], [ 36405, 32813, 45006 ] ]
        },
        msa244: {
            name: "Niles, Benton Harbor - MI",
            data: [ [ 1184, 1157, 1384 ], [ 850, 802, 951 ], [ 259, 270, 268 ], [ 141, 133, 147 ], [ 4045, 3843, 4610 ], [ 2343, 2140, 2848 ] ]
        },
        msa245: {
            name: "North Port, Sarasota, Bradenton - FL",
            data: [ [ 7174, 6839, 8276 ], [ 4614, 4500, 5611 ], [ 264, 187, 303 ], [ 100, 95, 144 ], [ 11207, 10065, 18046 ], [ 5719, 5582, 11134 ] ]
        },
        msa246: {
            name: "Norwich, New London - CT",
            data: [ [ 2510, 2133, 2351 ], [ 1742, 1516, 1723 ], [ 449, 398, 475 ], [ 323, 271, 349 ], [ 8020, 6527, 9020 ], [ 4591, 3772, 5699 ] ]
        },
        msa247: {
            name: "Oakland, Fremont, Hayward - CA",
            data: [ [ 32975, 29310, 30827 ], [ 21889, 19784, 21440 ], [ 1832, 1970, 2031 ], [ 1180, 1200, 1413 ], [ 102375, 87746, 133832 ], [ 67048, 56852, 93698 ] ]
        },
        msa248: {
            name: "Ocala - FL",
            data: [ [ 2886, 2793, 3055 ], [ 1755, 1739, 1889 ], [ 160, 114, 167 ], [ 48, 42, 63 ], [ 4526, 3859, 6615 ], [ 1992, 1857, 3830 ] ]
        },
        msa249: {
            name: "Ocean City - NJ",
            data: [ [ 743, 707, 740 ], [ 492, 474, 516 ], [ 203, 167, 205 ], [ 134, 97, 128 ], [ 3320, 2716, 3297 ], [ 1726, 1448, 1844 ] ]
        },
        msa250: {
            name: "Odessa - TX",
            data: [ [ 1507, 1681, 2431 ], [ 928, 1009, 1472 ], [ 168, 124, 114 ], [ 55, 47, 54 ], [ 1232, 1056, 1179 ], [ 596, 520, 638 ] ]
        },
        msa251: {
            name: "Ogden, Clearfield - UT",
            data: [ [ 7461, 6731, 8666 ], [ 5628, 4909, 6663 ], [ 845, 641, 825 ], [ 627, 437, 578 ], [ 22600, 15507, 25986 ], [ 15335, 9813, 18495 ] ]
        },
        msa252: {
            name: "Oklahoma City - OK",
            data: [ [ 18001, 17578, 20055 ], [ 13117, 12532, 14510 ], [ 1603, 1241, 1637 ], [ 745, 643, 949 ], [ 28216, 25124, 31522 ], [ 15962, 14605, 19646 ] ]
        },
        msa253: {
            name: "Olympia, Tumwater - WA",
            data: [ [ 3556, 3046, 3290 ], [ 2632, 2264, 2483 ], [ 171, 162, 212 ], [ 100, 98, 132 ], [ 10107, 8097, 11885 ], [ 6387, 4995, 7819 ] ]
        },
        msa254: {
            name: "Omaha, Council Bluffs - NE, IA",
            data: [ [ 10931, 10193, 11906 ], [ 8994, 8278, 9745 ], [ 968, 962, 1149 ], [ 609, 611, 780 ], [ 34252, 25749, 36155 ], [ 23303, 17060, 25296 ] ]
        },
        msa255: {
            name: "Orlando, Kissimmee, Sanford - FL",
            data: [ [ 25642, 23212, 25357 ], [ 16062, 14627, 16167 ], [ 662, 457, 667 ], [ 248, 175, 299 ], [ 27270, 24398, 53527 ], [ 13174, 13173, 33039 ] ]
        },
        msa256: {
            name: "Oshkosh, Neenah - WI",
            data: [ [ 1624, 1531, 1759 ], [ 1224, 1167, 1365 ], [ 256, 268, 326 ], [ 197, 204, 248 ], [ 6896, 5750, 7540 ], [ 4749, 3837, 5320 ] ]
        },
        msa257: {
            name: "Owensboro - KY",
            data: [ [ 1441, 1588, 1864 ], [ 998, 1006, 1270 ], [ 139, 180, 209 ], [ 87, 114, 135 ], [ 2766, 2527, 2987 ], [ 1664, 1549, 1912 ] ]
        },
        msa258: {
            name: "Oxnard, Thousand Oaks, Ventura - CA",
            data: [ [ 8618, 7606, 8364 ], [ 5839, 5252, 5935 ], [ 608, 800, 578 ], [ 408, 501, 395 ], [ 27497, 23869, 37385 ], [ 17481, 15189, 24963 ] ]
        },
        msa259: {
            name: "Palm Bay, Melbourne, Titusville - FL",
            data: [ [ 5530, 5272, 6386 ], [ 3871, 3562, 4363 ], [ 184, 176, 216 ], [ 82, 73, 94 ], [ 8855, 8167, 16673 ], [ 4333, 4450, 9931 ] ]
        },
        msa260: {
            name: "Panama City - FL",
            data: [ [ 1837, 2047, 2207 ], [ 1085, 1158, 1254 ], [ 216, 175, 163 ], [ 92, 105, 84 ], [ 3191, 2556, 4200 ], [ 1509, 1297, 2314 ] ]
        },
        msa261: {
            name: "Parkersburg, Vienna - WV",
            data: [ [ 1484, 1717, 1687 ], [ 995, 1114, 1074 ], [ 217, 203, 209 ], [ 141, 131, 159 ], [ 2888, 2419, 3141 ], [ 1606, 1493, 2088 ] ]
        },
        msa262: {
            name: "Pensacola, Ferry Pass, Brent - FL",
            data: [ [ 4636, 4813, 5395 ], [ 3289, 3314, 3684 ], [ 200, 192, 164 ], [ 86, 114, 79 ], [ 8519, 7472, 11653 ], [ 4453, 4131, 7057 ] ]
        },
        msa263: {
            name: "Peoria - IL",
            data: [ [ 4185, 4142, 4905 ], [ 3447, 3437, 4067 ], [ 532, 500, 565 ], [ 348, 307, 397 ], [ 11228, 9209, 11842 ], [ 7583, 5968, 8268 ] ]
        },
        msa264: {
            name: "Philadelphia - PA",
            data: [ [ 38243, 33761, 38287 ], [ 27556, 24459, 27752 ], [ 5254, 4759, 5128 ], [ 2885, 2640, 2991 ], [ 125546, 109667, 138192 ], [ 72392, 62475, 83157 ] ]
        },
        msa265: {
            name: "Phoenix, Mesa, Scottsdale - AZ",
            data: [ [ 64261, 60049, 62117 ], [ 45347, 42699, 43900 ], [ 1237, 1210, 1515 ], [ 502, 534, 804 ], [ 80038, 62892, 148519 ], [ 48038, 37827, 101446 ] ]
        },
        msa266: {
            name: "Pine Bluff - AR",
            data: [ [ 948, 877, 911 ], [ 485, 396, 381 ], [ 82, 57, 70 ], [ 40, 25, 35 ], [ 1331, 973, 1270 ], [ 668, 461, 639 ] ]
        },
        msa267: {
            name: "Pittsburgh - PA",
            data: [ [ 22993, 21476, 23946 ], [ 17570, 16241, 18386 ], [ 4266, 4352, 5327 ], [ 2739, 2681, 3478 ], [ 54008, 49988, 61985 ], [ 31085, 29182, 38806 ] ]
        },
        msa268: {
            name: "Pittsfield - MA",
            data: [ [ 1166, 1084, 1245 ], [ 834, 727, 872 ], [ 424, 313, 397 ], [ 313, 210, 292 ], [ 3292, 2459, 3671 ], [ 2104, 1435, 2364 ] ]
        },
        msa269: {
            name: "Pocatello - ID",
            data: [ [ 1094, 994, 1031 ], [ 799, 734, 678 ], [ 66, 55, 73 ], [ 41, 29, 40 ], [ 2705, 2184, 2831 ], [ 1587, 1280, 1766 ] ]
        },
        msa270: {
            name: "Ponce - PR",
            data: [ [ 1267, 1601, 1258 ], [ 694, 966, 745 ], [ 149, 148, 99 ], [ 72, 54, 60 ], [ 1244, 999, 1434 ], [ 723, 576, 892 ] ]
        },
        msa271: {
            name: "Port St. Lucie - FL",
            data: [ [ 4612, 3927, 4537 ], [ 2882, 2554, 3041 ], [ 206, 165, 269 ], [ 83, 81, 101 ], [ 5426, 5004, 10223 ], [ 2425, 2555, 6134 ] ]
        },
        msa272: {
            name: "Portland, South Portland - ME",
            data: [ [ 6211, 5540, 6448 ], [ 4293, 3911, 4582 ], [ 1263, 820, 1111 ], [ 907, 537, 758 ], [ 20670, 16550, 21784 ], [ 12437, 9571, 13874 ] ]
        },
        msa273: {
            name: "Portland, Vancouver, Hillsboro - OR, WA",
            data: [ [ 27816, 24692, 29884 ], [ 19348, 17693, 22028 ], [ 1476, 1273, 2303 ], [ 780, 697, 1599 ], [ 87120, 66358, 96913 ], [ 54397, 39789, 62739 ] ]
        },
        msa274: {
            name: "Prescott - AZ",
            data: [ [ 2400, 2460, 2862 ], [ 1621, 1662, 1906 ], [ 116, 73, 98 ], [ 49, 32, 47 ], [ 5320, 4468, 7429 ], [ 2836, 2567, 4793 ] ]
        },
        msa275: {
            name: "Providence, Warwick - RI, MA",
            data: [ [ 13901, 12585, 13927 ], [ 9631, 8776, 9901 ], [ 1743, 1692, 2031 ], [ 1186, 1151, 1496 ], [ 46374, 37942, 53488 ], [ 28440, 22867, 35194 ] ]
        },
        msa276: {
            name: "Provo, Orem - UT",
            data: [ [ 6708, 6420, 7550 ], [ 5033, 4741, 5828 ], [ 259, 253, 276 ], [ 163, 149, 189 ], [ 16976, 11659, 19915 ], [ 11406, 7434, 14179 ] ]
        },
        msa277: {
            name: "Pueblo - CO",
            data: [ [ 1892, 1639, 1535 ], [ 1410, 1158, 1109 ], [ 124, 108, 112 ], [ 66, 55, 58 ], [ 4097, 3824, 4680 ], [ 2437, 2034, 2797 ] ]
        },
        msa278: {
            name: "Punta Gorda - FL",
            data: [ [ 1307, 1241, 1474 ], [ 835, 787, 963 ], [ 50, 41, 77 ], [ 27, 21, 33 ], [ 2569, 2252, 4092 ], [ 1221, 1192, 2574 ] ]
        },
        msa279: {
            name: "Racine - WI",
            data: [ [ 1520, 1460, 1609 ], [ 1157, 1115, 1270 ], [ 154, 137, 179 ], [ 93, 92, 116 ], [ 7655, 6079, 8182 ], [ 5059, 4001, 5834 ] ]
        },
        msa280: {
            name: "Raleigh - NC",
            data: [ [ 16754, 15576, 18605 ], [ 12305, 11046, 13565 ], [ 560, 523, 630 ], [ 301, 327, 398 ], [ 42847, 37681, 50068 ], [ 28072, 23378, 33127 ] ]
        },
        msa281: {
            name: "Rapid City - SD",
            data: [ [ 1559, 1644, 2034 ], [ 1127, 1303, 1569 ], [ 158, 155, 293 ], [ 114, 95, 199 ], [ 3393, 2945, 4188 ], [ 2171, 1971, 2830 ] ]
        },
        msa282: {
            name: "Reading - PA",
            data: [ [ 3777, 3218, 3571 ], [ 2918, 2521, 2781 ], [ 410, 352, 526 ], [ 256, 215, 348 ], [ 9908, 9092, 10942 ], [ 5727, 5209, 6732 ] ]
        },
        msa283: {
            name: "Redding - CA",
            data: [ [ 1690, 1499, 1675 ], [ 1152, 967, 1177 ], [ 104, 97, 99 ], [ 46, 47, 58 ], [ 4018, 3293, 5557 ], [ 2240, 1793, 3505 ] ]
        },
        msa284: {
            name: "Reno - NV",
            data: [ [ 5992, 5340, 5287 ], [ 4277, 3960, 4015 ], [ 138, 143, 134 ], [ 69, 80, 70 ], [ 7487, 6114, 12903 ], [ 4489, 3668, 8834 ] ]
        },
        msa285: {
            name: "Richmond - VA",
            data: [ [ 14114, 13927, 15406 ], [ 10476, 10139, 11478 ], [ 1297, 1083, 1233 ], [ 740, 581, 693 ], [ 38548, 32059, 44073 ], [ 22512, 18315, 27759 ] ]
        },
        msa286: {
            name: "Riverside, San Bernardino, Ontario - CA",
            data: [ [ 62038, 51644, 49035 ], [ 4e4, 34182, 32917 ], [ 1553, 1489, 1652 ], [ 777, 768, 979 ], [ 68529, 63967, 126141 ], [ 38129, 35302, 77743 ] ]
        },
        msa287: {
            name: "Roanoke - VA",
            data: [ [ 2899, 2986, 3039 ], [ 2154, 2091, 2191 ], [ 547, 245, 295 ], [ 434, 136, 181 ], [ 7898, 6758, 8605 ], [ 4796, 3950, 5447 ] ]
        },
        msa288: {
            name: "Rochester - MN",
            data: [ [ 2511, 2466, 2989 ], [ 1926, 1905, 2383 ], [ 218, 189, 172 ], [ 142, 125, 125 ], [ 7270, 5812, 7873 ], [ 4812, 3748, 5633 ] ]
        },
        msa289: {
            name: "Rochester - NY",
            data: [ [ 10169, 9886, 10559 ], [ 7890, 7770, 8457 ], [ 650, 706, 860 ], [ 402, 482, 590 ], [ 14800, 14108, 16749 ], [ 8588, 8186, 10521 ] ]
        },
        msa290: {
            name: "Rockford - IL",
            data: [ [ 3086, 2404, 2831 ], [ 2228, 1728, 2096 ], [ 234, 220, 227 ], [ 117, 109, 119 ], [ 11747, 9350, 12356 ], [ 7622, 5694, 8059 ] ]
        },
        msa291: {
            name: "Rocky Mount - NC",
            data: [ [ 1045, 1235, 1267 ], [ 591, 589, 595 ], [ 76, 74, 109 ], [ 34, 34, 53 ], [ 2455, 2099, 2565 ], [ 1300, 1066, 1451 ] ]
        },
        msa292: {
            name: "Rome - GA",
            data: [ [ 529, 549, 643 ], [ 366, 365, 463 ], [ 23, 28, 30 ], [ 12, 15, 8 ], [ 1396, 1333, 1893 ], [ 673, 720, 1067 ] ]
        },
        msa293: {
            name: "Sacramento--Roseville--Arden, Arcade - CA",
            data: [ [ 28632, 27059, 27836 ], [ 19645, 18933, 19710 ], [ 1473, 1366, 1575 ], [ 848, 802, 1077 ], [ 59245, 47e3, 91948 ], [ 36046, 27011, 58886 ] ]
        },
        msa294: {
            name: "Saginaw - MI",
            data: [ [ 1459, 1522, 1632 ], [ 993, 1076, 1157 ], [ 120, 133, 177 ], [ 57, 79, 107 ], [ 3547, 3203, 5027 ], [ 2181, 2030, 3388 ] ]
        },
        msa295: {
            name: "Salem - OR",
            data: [ [ 3608, 2919, 3533 ], [ 2401, 2011, 2406 ], [ 286, 236, 241 ], [ 145, 119, 149 ], [ 12067, 9158, 12273 ], [ 6940, 5107, 7435 ] ]
        },
        msa296: {
            name: "Salinas - CA",
            data: [ [ 4028, 3468, 3059 ], [ 2537, 2250, 2048 ], [ 154, 158, 207 ], [ 75, 84, 145 ], [ 6769, 6258, 9946 ], [ 3942, 3671, 6169 ] ]
        },
        msa297: {
            name: "Salisbury - MD, DE",
            data: [ [ 1033, 899, 945 ], [ 722, 584, 595 ], [ 110, 95, 92 ], [ 60, 54, 45 ], [ 2563, 2351, 2808 ], [ 1318, 1209, 1592 ] ]
        },
        msa298: {
            name: "Salt Lake City - UT",
            data: [ [ 14330, 13291, 16892 ], [ 10546, 9740, 12857 ], [ 897, 784, 934 ], [ 562, 505, 577 ], [ 41741, 28518, 47007 ], [ 27568, 17808, 32839 ] ]
        },
        msa299: {
            name: "San Angelo - TX",
            data: [ [ 1064, 1051, 1299 ], [ 841, 848, 995 ], [ 133, 134, 101 ], [ 67, 74, 53 ], [ 1370, 1322, 1559 ], [ 775, 833, 983 ] ]
        },
        msa300: {
            name: "San Antonio, New Braunfels - TX",
            data: [ [ 28244, 26042, 31064 ], [ 19280, 16998, 20192 ], [ 2237, 2278, 2261 ], [ 997, 1040, 1017 ], [ 34171, 35515, 46028 ], [ 18398, 19469, 26538 ] ]
        },
        msa301: {
            name: "San Diego, Carlsbad - CA",
            data: [ [ 36668, 32405, 35036 ], [ 24340, 21922, 24196 ], [ 1760, 1736, 2047 ], [ 1151, 1115, 1480 ], [ 91820, 83530, 132611 ], [ 58482, 52460, 89252 ] ]
        },
        msa302: {
            name: "San Francisco, San Mateo, Redwood City - CA",
            data: [ [ 15516, 14956, 16538 ], [ 10848, 10577, 12122 ], [ 1424, 1670, 1744 ], [ 934, 1024, 1237 ], [ 68272, 64072, 88697 ], [ 43622, 41674, 63145 ] ]
        },
        msa303: {
            name: "San Germn - PR",
            data: [ [ 702, 982, 738 ], [ 379, 541, 402 ], [ 89, 62, 58 ], [ 42, 30, 34 ], [ 635, 674, 889 ], [ 345, 345, 521 ] ]
        },
        msa304: {
            name: "San Jose, Sunnyvale, Santa Clara - CA",
            data: [ [ 20712, 18654, 19596 ], [ 13855, 12608, 13908 ], [ 1425, 1484, 1844 ], [ 973, 942, 1386 ], [ 89586, 78023, 109780 ], [ 60887, 52861, 81014 ] ]
        },
        msa305: {
            name: "San Juan, Carolina, Caguas - PR",
            data: [ [ 15323, 19314, 15730 ], [ 8688, 11251, 9207 ], [ 1887, 1336, 1229 ], [ 1063, 730, 737 ], [ 17374, 13452, 22169 ], [ 9318, 7001, 13439 ] ]
        },
        msa306: {
            name: "San Luis Obispo, Paso Robles, Arroyo Grande - CA",
            data: [ [ 2447, 2594, 2803 ], [ 1689, 1818, 2025 ], [ 233, 200, 227 ], [ 138, 138, 162 ], [ 8997, 7264, 11190 ], [ 5473, 4468, 7422 ] ]
        },
        msa307: {
            name: "Santa Ana, Anaheim, Irvine - CA",
            data: [ [ 31361, 26953, 29891 ], [ 20187, 17644, 20104 ], [ 2255, 2169, 2904 ], [ 1513, 1461, 2247 ], [ 101128, 92710, 144494 ], [ 65106, 59235, 98532 ] ]
        },
        msa308: {
            name: "Santa Cruz, Watsonville - CA",
            data: [ [ 2086, 2051, 2353 ], [ 1318, 1346, 1583 ], [ 182, 162, 230 ], [ 113, 100, 146 ], [ 8141, 7116, 10837 ], [ 5132, 4595, 7346 ] ]
        },
        msa309: {
            name: "Santa Fe - NM",
            data: [ [ 1381, 1320, 1464 ], [ 835, 766, 870 ], [ 107, 87, 106 ], [ 54, 61, 58 ], [ 4750, 4096, 5676 ], [ 2551, 2187, 3112 ] ]
        },
        msa310: {
            name: "Santa Rosa - CA",
            data: [ [ 4685, 4430, 4807 ], [ 3220, 3099, 3422 ], [ 339, 406, 430 ], [ 213, 258, 303 ], [ 15296, 12410, 19563 ], [ 9839, 7958, 13412 ] ]
        },
        msa311: {
            name: "Savannah - GA",
            data: [ [ 4146, 4301, 4494 ], [ 3043, 3036, 3297 ], [ 151, 135, 142 ], [ 67, 64, 74 ], [ 7967, 7276, 9150 ], [ 4036, 3851, 5264 ] ]
        },
        msa312: {
            name: "Scranton--Wilkes, Barre--Hazleton - PA",
            data: [ [ 4181, 4024, 4182 ], [ 2851, 2785, 2929 ], [ 1004, 918, 1089 ], [ 655, 590, 706 ], [ 11016, 10016, 12206 ], [ 5659, 5083, 6931 ] ]
        },
        msa313: {
            name: "Seattle, Bellevue, Everett - WA",
            data: [ [ 34485, 34009, 39280 ], [ 24523, 24461, 29004 ], [ 1556, 1687, 2273 ], [ 948, 1072, 1557 ], [ 115249, 90152, 130015 ], [ 74807, 56593, 86570 ] ]
        },
        msa314: {
            name: "Sebastian, Vero Beach - FL",
            data: [ [ 1196, 1084, 1377 ], [ 816, 721, 929 ], [ 57, 63, 86 ], [ 21, 26, 40 ], [ 2110, 1956, 3405 ], [ 1051, 1026, 2054 ] ]
        },
        msa315: {
            name: "Sheboygan - WI",
            data: [ [ 829, 726, 996 ], [ 645, 582, 800 ], [ 206, 186, 257 ], [ 146, 144, 197 ], [ 4801, 3801, 4868 ], [ 3351, 2597, 3517 ] ]
        },
        msa316: {
            name: "Sherman, Denison - TX",
            data: [ [ 1186, 1178, 1359 ], [ 715, 677, 799 ], [ 83, 51, 82 ], [ 34, 25, 34 ], [ 1592, 1759, 1924 ], [ 837, 914, 1050 ] ]
        },
        msa317: {
            name: "Shreveport, Bossier City - LA",
            data: [ [ 5801, 5130, 5527 ], [ 3809, 3221, 3636 ], [ 277, 353, 484 ], [ 104, 168, 191 ], [ 7480, 6900, 9248 ], [ 4004, 3570, 5287 ] ]
        },
        msa318: {
            name: "Sioux City - IA, NE, SD",
            data: [ [ 1741, 1512, 1625 ], [ 1217, 1009, 1177 ], [ 189, 152, 220 ], [ 121, 95, 151 ], [ 3330, 3112, 4094 ], [ 1914, 1822, 2537 ] ]
        },
        msa319: {
            name: "Sioux Falls - SD",
            data: [ [ 3626, 3209, 3968 ], [ 2850, 2574, 3246 ], [ 285, 260, 363 ], [ 200, 159, 278 ], [ 9459, 7496, 10888 ], [ 6048, 4756, 7454 ] ]
        },
        msa320: {
            name: "South Bend, Mishawaka - IN, MI",
            data: [ [ 2476, 2375, 2677 ], [ 1875, 1805, 2104 ], [ 209, 206, 268 ], [ 104, 102, 165 ], [ 8117, 6986, 8971 ], [ 4601, 4006, 5589 ] ]
        },
        msa321: {
            name: "Spartanburg - SC",
            data: [ [ 3526, 4120, 4771 ], [ 1897, 1748, 2260 ], [ 141, 156, 184 ], [ 70, 91, 91 ], [ 5962, 5391, 6724 ], [ 3008, 2765, 3840 ] ]
        },
        msa322: {
            name: "Spokane, Spokane Valley - WA",
            data: [ [ 5366, 4631, 5205 ], [ 4016, 3455, 3891 ], [ 705, 483, 753 ], [ 485, 285, 458 ], [ 16032, 12641, 17614 ], [ 9565, 7410, 10792 ] ]
        },
        msa323: {
            name: "Springfield - IL",
            data: [ [ 2766, 2640, 2914 ], [ 2270, 2181, 2435 ], [ 444, 310, 520 ], [ 379, 239, 431 ], [ 9708, 7277, 10262 ], [ 7786, 5384, 8067 ] ]
        },
        msa324: {
            name: "Springfield - MA",
            data: [ [ 6110, 5504, 6007 ], [ 4375, 3887, 4298 ], [ 1079, 1025, 1197 ], [ 734, 719, 876 ], [ 16054, 13092, 17297 ], [ 9770, 7936, 11109 ] ]
        },
        msa325: {
            name: "Springfield - MO",
            data: [ [ 5370, 4812, 5424 ], [ 4007, 3411, 3939 ], [ 287, 231, 268 ], [ 166, 138, 159 ], [ 13508, 10513, 14048 ], [ 8465, 6468, 9317 ] ]
        },
        msa326: {
            name: "Springfield - OH",
            data: [ [ 1083, 978, 1147 ], [ 753, 685, 795 ], [ 76, 84, 103 ], [ 29, 44, 49 ], [ 3098, 2636, 3621 ], [ 1722, 1437, 2076 ] ]
        },
        msa327: {
            name: "St. Cloud - MN",
            data: [ [ 1632, 1687, 1968 ], [ 1240, 1310, 1558 ], [ 136, 107, 138 ], [ 97, 78, 98 ], [ 6025, 4477, 6332 ], [ 4061, 2923, 4578 ] ]
        },
        msa328: {
            name: "St. George - UT",
            data: [ [ 1879, 1980, 2151 ], [ 1331, 1422, 1608 ], [ 61, 41, 85 ], [ 36, 22, 55 ], [ 3580, 2783, 4642 ], [ 2175, 1665, 3150 ] ]
        },
        msa329: {
            name: "St. Joseph - MO, KS",
            data: [ [ 1009, 1034, 1153 ], [ 699, 727, 804 ], [ 150, 131, 189 ], [ 94, 78, 124 ], [ 2752, 2281, 2854 ], [ 1567, 1229, 1703 ] ]
        },
        msa330: {
            name: "St. Louis - MO, IL",
            data: [ [ 31149, 28608, 32230 ], [ 22975, 20780, 23404 ], [ 2483, 2242, 2645 ], [ 1543, 1291, 1718 ], [ 112775, 87527, 119334 ], [ 77096, 57350, 82560 ] ]
        },
        msa331: {
            name: "State College - PA",
            data: [ [ 1308, 1248, 1449 ], [ 1024, 977, 1132 ], [ 205, 185, 227 ], [ 152, 146, 181 ], [ 3485, 2989, 3844 ], [ 2329, 1942, 2662 ] ]
        },
        msa332: {
            name: "Stockton, Lodi - CA",
            data: [ [ 9766, 8282, 7709 ], [ 6628, 5727, 5506 ], [ 197, 219, 187 ], [ 94, 83, 108 ], [ 9497, 8383, 18340 ], [ 5135, 4565, 11602 ] ]
        },
        msa333: {
            name: "Sumter - SC",
            data: [ [ 1054, 1e3, 989 ], [ 581, 576, 518 ], [ 60, 88, 73 ], [ 28, 42, 41 ], [ 1844, 1613, 1884 ], [ 887, 847, 1078 ] ]
        },
        msa334: {
            name: "Syracuse - NY",
            data: [ [ 6094, 5940, 6631 ], [ 4784, 4570, 5078 ], [ 458, 510, 665 ], [ 326, 342, 480 ], [ 9511, 9162, 10679 ], [ 5704, 5378, 6897 ] ]
        },
        msa335: {
            name: "Tacoma - WA",
            data: [ [ 9677, 9566, 9811 ], [ 6767, 6921, 7170 ], [ 539, 503, 543 ], [ 313, 302, 352 ], [ 26678, 21455, 33064 ], [ 15868, 12379, 20802 ] ]
        },
        msa336: {
            name: "Tallahassee - FL",
            data: [ [ 3410, 3044, 3337 ], [ 2185, 1899, 2081 ], [ 205, 140, 193 ], [ 99, 82, 125 ], [ 6335, 5325, 7883 ], [ 3499, 2920, 4744 ] ]
        },
        msa337: {
            name: "Tampa, St. Petersburg, Clearwater - FL",
            data: [ [ 29116, 28215, 32044 ], [ 18877, 18272, 21046 ], [ 966, 976, 1390 ], [ 374, 404, 651 ], [ 41028, 36142, 65482 ], [ 20251, 18825, 39097 ] ]
        },
        msa338: {
            name: "Terre Haute - IN",
            data: [ [ 1706, 1611, 1537 ], [ 1161, 1092, 1089 ], [ 225, 260, 320 ], [ 143, 152, 182 ], [ 3779, 3297, 4093 ], [ 2014, 1738, 2383 ] ]
        },
        msa339: {
            name: "Texarkana - TX, AR",
            data: [ [ 1416, 1426, 1430 ], [ 898, 848, 882 ], [ 121, 125, 208 ], [ 55, 53, 91 ], [ 1513, 1584, 1831 ], [ 830, 893, 1075 ] ]
        },
        msa340: {
            name: "Toledo - OH",
            data: [ [ 5066, 4930, 5471 ], [ 3686, 3568, 4020 ], [ 337, 292, 367 ], [ 158, 123, 182 ], [ 14770, 12974, 18126 ], [ 8386, 7299, 11237 ] ]
        },
        msa341: {
            name: "Topeka - KS",
            data: [ [ 2690, 2569, 2496 ], [ 1925, 1819, 1819 ], [ 259, 255, 337 ], [ 180, 181, 253 ], [ 6161, 5389, 6170 ], [ 3648, 3249, 3960 ] ]
        },
        msa342: {
            name: "Trenton - NJ",
            data: [ [ 3159, 2818, 3060 ], [ 2221, 1894, 2144 ], [ 346, 387, 359 ], [ 206, 233, 235 ], [ 10895, 9809, 12306 ], [ 6186, 5736, 7737 ] ]
        },
        msa343: {
            name: "Tucson - AZ",
            data: [ [ 11350, 11386, 12348 ], [ 7645, 7871, 8677 ], [ 451, 529, 604 ], [ 207, 296, 364 ], [ 23700, 17860, 30501 ], [ 14088, 10749, 20076 ] ]
        },
        msa344: {
            name: "Tulsa - OK",
            data: [ [ 11950, 11258, 13244 ], [ 8598, 7562, 9162 ], [ 1290, 986, 1239 ], [ 614, 523, 691 ], [ 21408, 17903, 22685 ], [ 12044, 10086, 13641 ] ]
        },
        msa345: {
            name: "Tuscaloosa - AL",
            data: [ [ 2324, 2469, 2656 ], [ 1611, 1688, 1742 ], [ 104, 112, 118 ], [ 54, 60, 72 ], [ 4836, 3705, 5286 ], [ 2751, 2017, 3339 ] ]
        },
        msa346: {
            name: "Tyler - TX",
            data: [ [ 2724, 2514, 2915 ], [ 1677, 1632, 1847 ], [ 273, 191, 281 ], [ 154, 109, 149 ], [ 3166, 3019, 3606 ], [ 1826, 1718, 2104 ] ]
        },
        msa347: {
            name: "Utica, Rome - NY",
            data: [ [ 2045, 2098, 2249 ], [ 1548, 1527, 1697 ], [ 286, 276, 500 ], [ 198, 195, 383 ], [ 3858, 3721, 4147 ], [ 2396, 2201, 2737 ] ]
        },
        msa348: {
            name: "Valdosta - GA",
            data: [ [ 1231, 1057, 1236 ], [ 915, 742, 835 ], [ 95, 79, 90 ], [ 66, 51, 54 ], [ 2387, 2450, 2725 ], [ 1429, 1539, 1709 ] ]
        },
        msa349: {
            name: "Vallejo, Fairfield - CA",
            data: [ [ 6335, 5581, 5568 ], [ 4333, 3834, 3618 ], [ 155, 162, 147 ], [ 83, 85, 89 ], [ 8382, 7138, 15048 ], [ 4876, 4009, 9611 ] ]
        },
        msa350: {
            name: "Victoria - TX",
            data: [ [ 1103, 1180, 1460 ], [ 743, 774, 979 ], [ 92, 126, 119 ], [ 39, 66, 65 ], [ 1249, 1058, 1185 ], [ 695, 587, 688 ] ]
        },
        msa351: {
            name: "Vineland, Bridgeton - NJ",
            data: [ [ 1033, 848, 816 ], [ 707, 588, 562 ], [ 211, 184, 190 ], [ 117, 112, 101 ], [ 2754, 2263, 2646 ], [ 1334, 1042, 1409 ] ]
        },
        msa352: {
            name: "Virginia Beach, Norfolk, Newport News - VA, NC",
            data: [ [ 18180, 18789, 20393 ], [ 14247, 14381, 15761 ], [ 2401, 1431, 1605 ], [ 1853, 837, 993 ], [ 49458, 45313, 61968 ], [ 29222, 26673, 39431 ] ]
        },
        msa353: {
            name: "Visalia, Porterville - CA",
            data: [ [ 3243, 3060, 3001 ], [ 2357, 2228, 2188 ], [ 166, 142, 118 ], [ 76, 73, 62 ], [ 4685, 4122, 8263 ], [ 2302, 2049, 5093 ] ]
        },
        msa354: {
            name: "Waco - TX",
            data: [ [ 2506, 2475, 2707 ], [ 1844, 1718, 1834 ], [ 204, 210, 231 ], [ 107, 111, 131 ], [ 2534, 2569, 3040 ], [ 1495, 1483, 1790 ] ]
        },
        msa355: {
            name: "Warner Robins - GA",
            data: [ [ 1927, 1685, 1698 ], [ 1520, 1267, 1287 ], [ 107, 75, 64 ], [ 61, 50, 29 ], [ 3316, 3202, 4367 ], [ 1913, 1950, 2793 ] ]
        },
        msa356: {
            name: "Warren, Farmington Hills, Troy - MI",
            data: [ [ 28012, 28554, 32367 ], [ 18490, 19479, 22634 ], [ 724, 724, 1197 ], [ 354, 324, 645 ], [ 57910, 56492, 109268 ], [ 34350, 35004, 75973 ] ]
        },
        msa357: {
            name: "Washington, Arlington, Alexandria - DC, VA, MD",
            data: [ [ 69279, 62529, 67375 ], [ 49858, 44969, 49314 ], [ 2918, 3105, 3670 ], [ 1628, 1782, 2309 ], [ 157966, 144742, 218949 ], [ 96127, 87742, 145586 ] ]
        },
        msa358: {
            name: "Waterloo, Cedar Falls - IA",
            data: [ [ 2507, 2207, 2303 ], [ 1993, 1703, 1846 ], [ 197, 169, 152 ], [ 144, 124, 104 ], [ 5159, 4228, 5106 ], [ 3554, 2803, 3714 ] ]
        },
        msa359: {
            name: "Wausau - WI",
            data: [ [ 1242, 1187, 1330 ], [ 892, 884, 1033 ], [ 247, 239, 458 ], [ 181, 195, 377 ], [ 5534, 4054, 5709 ], [ 3789, 2663, 4134 ] ]
        },
        msa360: {
            name: "Wenatchee - WA",
            data: [ [ 1042, 955, 1198 ], [ 708, 696, 868 ], [ 178, 110, 160 ], [ 118, 76, 127 ], [ 3402, 2794, 3559 ], [ 2093, 1638, 2262 ] ]
        },
        msa361: {
            name: "West Palm Beach, Boca Raton, Boynton Beach - FL",
            data: [ [ 13239, 12936, 14160 ], [ 8030, 8194, 9090 ], [ 448, 352, 504 ], [ 213, 162, 218 ], [ 20170, 17950, 31713 ], [ 9974, 9560, 18422 ] ]
        },
        msa362: {
            name: "Wheeling - WV, OH",
            data: [ [ 1258, 1131, 1258 ], [ 840, 759, 907 ], [ 245, 198, 255 ], [ 154, 121, 162 ], [ 2162, 1902, 2234 ], [ 1165, 1089, 1427 ] ]
        },
        msa363: {
            name: "Wichita - KS",
            data: [ [ 8002, 6929, 7533 ], [ 5752, 5052, 5558 ], [ 740, 639, 865 ], [ 473, 453, 619 ], [ 16099, 12517, 15024 ], [ 9967, 7487, 9932 ] ]
        },
        msa364: {
            name: "Wichita Falls - TX",
            data: [ [ 1705, 1324, 1431 ], [ 1377, 1039, 1078 ], [ 106, 109, 99 ], [ 65, 75, 67 ], [ 1775, 1635, 2117 ], [ 1146, 1042, 1427 ] ]
        },
        msa365: {
            name: "Williamsport - PA",
            data: [ [ 1019, 1048, 1007 ], [ 774, 795, 812 ], [ 201, 189, 309 ], [ 148, 139, 227 ], [ 2056, 1964, 2458 ], [ 1191, 1124, 1598 ] ]
        },
        msa366: {
            name: "Wilmington - DE",
            data: [ [ 7055, 6388, 7177 ], [ 5109, 4718, 5310 ], [ 729, 684, 672 ], [ 441, 402, 428 ], [ 21432, 17701, 23254 ], [ 12518, 10258, 14602 ] ]
        },
        msa367: {
            name: "Wilmington - NC",
            data: [ [ 3980, 4027, 4722 ], [ 2532, 2383, 2802 ], [ 243, 232, 237 ], [ 127, 133, 149 ], [ 11617, 9883, 12884 ], [ 6519, 5391, 7670 ] ]
        },
        msa368: {
            name: "Winchester - VA, WV",
            data: [ [ 1675, 1475, 1648 ], [ 1192, 1053, 1233 ], [ 120, 101, 129 ], [ 78, 69, 88 ], [ 3316, 2844, 4336 ], [ 1969, 1747, 2923 ] ]
        },
        msa369: {
            name: "Winston, Salem - NC",
            data: [ [ 4847, 4683, 4954 ], [ 3299, 3202, 3273 ], [ 299, 356, 426 ], [ 186, 226, 240 ], [ 12371, 11274, 13074 ], [ 7130, 6383, 7761 ] ]
        },
        msa370: {
            name: "Worcester - MA, CT",
            data: [ [ 8140, 7202, 8562 ], [ 5663, 5106, 6073 ], [ 1135, 1219, 1421 ], [ 786, 821, 1023 ], [ 26828, 21075, 31253 ], [ 17045, 13346, 20899 ] ]
        },
        msa371: {
            name: "Yakima - WA",
            data: [ [ 1929, 1692, 1809 ], [ 1347, 1167, 1248 ], [ 288, 245, 229 ], [ 153, 137, 136 ], [ 5032, 4697, 6202 ], [ 2684, 2509, 3592 ] ]
        },
        msa372: {
            name: "York, Hanover - PA",
            data: [ [ 5105, 4423, 4707 ], [ 3846, 3330, 3582 ], [ 622, 456, 516 ], [ 443, 330, 359 ], [ 13225, 11115, 14431 ], [ 7746, 6313, 8814 ] ]
        },
        msa373: {
            name: "Youngstown, Warren, Boardman - OH, PA",
            data: [ [ 3812, 3601, 3978 ], [ 2821, 2657, 2868 ], [ 711, 655, 701 ], [ 375, 347, 397 ], [ 11835, 9853, 12558 ], [ 6159, 5086, 6804 ] ]
        },
        msa374: {
            name: "Yuba City - CA",
            data: [ [ 2157, 2002, 1842 ], [ 1494, 1386, 1354 ], [ 72, 56, 42 ], [ 29, 26, 17 ], [ 2456, 2112, 4720 ], [ 1279, 1094, 2781 ] ]
        },
        msa375: {
            name: "Yuma - AZ",
            data: [ [ 1834, 1591, 1920 ], [ 1419, 1233, 1441 ], [ 84, 58, 58 ], [ 33, 32, 27 ], [ 2714, 2151, 3850 ], [ 1391, 1094, 2317 ] ]
        }
    };
    var $home_purchase_checkbox = $("#home_purchase_checkbox");
    $home_purchase_checkbox.click(function() {
        var series1 = applicationsOriginationsChart.series[0];
        var series2 = applicationsOriginationsChart.series[1];
        if (series1.visible) {
            series1.hide();
            series2.hide();
            $home_purchase_checkbox.removeAttr("checked");
        } else {
            series1.show();
            series2.show();
            $home_purchase_checkbox.attr("checked");
        }
    });
    var $home_improvements_checkbox = $("#home_improvements_checkbox");
    $home_improvements_checkbox.click(function() {
        var series1 = applicationsOriginationsChart.series[2];
        var series2 = applicationsOriginationsChart.series[3];
        if (series1.visible) {
            series1.hide();
            series2.hide();
            $home_improvements_checkbox.removeAttr("checked");
        } else {
            series1.show();
            series2.show();
            $home_improvements_checkbox.attr("checked");
        }
    });
    var $refinancing_checkbox = $("#refinancing_checkbox");
    $refinancing_checkbox.click(function() {
        var series1 = applicationsOriginationsChart.series[4];
        var series2 = applicationsOriginationsChart.series[5];
        if (series1.visible) {
            series1.hide();
            series2.hide();
            $refinancing_checkbox.removeAttr("checked");
        } else {
            series1.show();
            series2.show();
            $refinancing_checkbox.attr("checked");
        }
    });
    var $msa = $("#hmda_chart_1_msa");
    $msa.change(function() {
        var msaID = $msa.val();
        var msaName = chart1DataObj[msaID].name.replace("&apos;", "").toUpperCase();
        applicationsOriginationsChart.setTitle({
            text: msaName
        });
        for (var i = 0; i < 6; i++) {
            applicationsOriginationsChart.series[i].setData(chart1DataObj[msaID].data[i]);
        }
    });
});

var chart2_options = {
    chart: {
        renderTo: "hmda_chart_2",
        alignTicks: true,
        height: 400,
        plotBackgroundColor: "#FFFFFF",
        plotBorderWidth: null,
        plotShadow: false,
        spacingTop: 20,
        spacingRight: 10,
        spacingBottom: 1,
        spacingLeft: 1,
        marginTop: 20,
        marginBottom: 80,
        type: "column"
    },
    exporting: {
        enabled: false
    },
    title: {
        text: "U.S. TOTAL",
        align: "center",
        verticalAlign: "bottom",
        floating: false,
        x: 30,
        y: -20,
        style: {
            color: "#000000",
            fontSize: "14pt",
            fontFamily: '"Avenir Next LT W01 Demi", "Avenir Next Demi", "Avenir Next", "Arial"',
            fontWeight: "600"
        }
    },
    credits: {
        text: "Data are for first-lien, owner-occupied, 1-4 family and manufactured homes.",
        enabled: false
    },
    colors: [ "#DBEDD4", "#ADDC91", "#2CB34A", "#005E5D" ],
    legend: {
        align: "right",
        backgroundColor: "#FFFFFF",
        borderWidth: 0,
        borderRadius: 0,
        borderColor: "#FFFFFF",
        floating: false,
        itemStyle: {
            color: "#212121",
            fontSize: "12pt",
            lineHeight: "12pt",
            fontFamily: '"Avenir Next LT W01 Medium Cn", "Avenir Next Light", "Avenir Next", "Arial Condensed", "Arial"',
            fontWeight: "",
            paddingBottom: "8pt"
        },
        layout: "vertical",
        margin: 10,
        padding: 10,
        shadow: false,
        symbolPadding: 5,
        symbolWidth: 20,
        verticalAlign: "middle",
        x: 0,
        y: 0,
        enabled: false
    },
    tooltip: {
        backgroundColor: "rgba(0, 0, 0, 0.65)",
        borderColor: "#999999",
        borderRadius: 0,
        borderWidth: 0,
        shadow: false,
        style: {
            color: "#ffffff",
            fontSize: "10pt",
            fontFamily: "",
            fontWeight: "",
            padding: 8,
            lineHeight: "12pt"
        },
        formatter: function() {
            var format = '<span style="font-size: 12pt;><span style="font-weight: 700;">' + addCommas(this.y) + "</span> " + this.series.name + "<br>originations in " + this.x + "</span>";
            return format;
        }
    },
    plotOptions: {
        series: {
            allowPointSelect: true,
            animation: false,
            borderWidth: 0,
            cursor: "pointer",
            marker: {
                radius: 10
            },
            showInLegend: true,
            shadow: false,
            point: {
                events: {
                    click: function() {
                        return false;
                    }
                }
            }
        },
        pie: {
            dataLabels: {
                enabled: false
            },
            point: {
                events: {
                    legendItemClick: function() {
                        return false;
                    }
                }
            },
            size: "90%"
        },
        column: {
            dataLabels: {
                enabled: false
            },
            grouping: true,
            groupPadding: .1,
            pointPadding: 0,
            stacking: null,
            events: {
                legendItemClick: function() {
                    return false;
                }
            }
        },
        bar: {
            dataLabels: {
                enabled: false
            },
            groupPadding: .1,
            pointPadding: 0,
            stacking: null
        },
        line: {
            lineWidth: 8,
            marker: {
                enabled: false
            }
        },
        area: {
            lineWidth: 8,
            stacking: null,
            marker: {
                enabled: false
            }
        },
        allowPointSelect: false
    },
    xAxis: {
        categories: [ "2010", "2011", "2012" ],
        gridLineWidth: 0,
        labels: {
            style: {
                color: "#212121",
                fontSize: "10pt",
                fontFamily: '"Avenir Next LT W01 Regular", "Avenir Next", "Arial"',
                fontWeight: "400"
            },
            enabled: true,
            y: 20
        },
        lineWidth: 0,
        title: {
            text: null,
            margin: 12,
            style: {
                color: "#101820",
                fontSize: "12pt",
                fontFamily: '"Avenir Next LT W01 Regular", "Avenir Next", "Arial"',
                fontWeight: "400"
            },
            x: -5
        },
        tickLength: 0,
        startOnTick: true,
        endOnTick: true,
        minPadding: 0,
        maxPadding: 0
    },
    yAxis: [ {
        title: {
            text: "Number of originations per year",
            margin: 10,
            style: {
                color: "#101820",
                fontSize: "12pt",
                fontFamily: '"Avenir Next LT W01 Regular", "Avenir Next", "Arial"',
                fontWeight: "400"
            },
            enabled: false
        },
        labels: {
            style: {
                color: "#212121",
                fontSize: "10pt",
                fontFamily: '"Avenir Next LT W01 Regular", "Avenir Next", "Arial"',
                fontWeight: "400"
            },
            format: "{value:,.0f}",
            enabled: true
        },
        gridLineWidth: 1
    }, {
        opposite: true,
        title: {
            text: null
        },
        labels: {
            style: {
                color: "#212121",
                fontSize: "10pt",
                fontFamily: '"Avenir Next LT W01 Regular", "Avenir Next", "Arial"',
                fontWeight: "400"
            },
            format: " {value:,.0f} ",
            enabled: true
        },
        gridLineWidth: 0
    } ],
    series: [ {
        name: "Conventional",
        data: [ 5038561, 4493378, 6432249 ]
    }, {
        name: "FHA",
        data: [ 1428357, 1057843, 1278827 ]
    }, {
        name: "VA",
        data: [ 310522, 372783, 558690 ]
    }, {
        name: "RHS",
        data: [ 87858, 113815, 132204 ]
    } ]
};

$(document).ready(function() {
    if ($("#hmda_chart_2").length !== 0) {
        var originationsByTypeChart = new Highcharts.Chart(chart2_options);
    }
    if ($("#hmda_chart_2_msa").length !== 0) {
        $("#hmda_chart_2_msa").chosen({
            width: "100%"
        });
    }
    var chart2DataObj = {
        msa01: {
            name: "U.S. Total",
            data: [ [ 5038561, 4493378, 6432249 ], [ 1428357, 1057843, 1278827 ], [ 310522, 372783, 558690 ], [ 87858, 113815, 132204 ] ]
        },
        msa02: {
            name: "Total, all counties not part of any MSA",
            data: [ [ 778787, 687423, 919699 ], [ 165165, 122509, 132983 ], [ 42025, 51167, 73957 ], [ 34749, 42902, 48061 ] ]
        },
        msa03: {
            name: "Abilene - TX",
            data: [ [ 1511, 1555, 1838 ], [ 602, 461, 539 ], [ 506, 524, 731 ], [ 31, 38, 28 ] ]
        },
        msa04: {
            name: "Aguadilla, Isabela - PR",
            data: [ [ 708, 778, 1091 ], [ 317, 328, 360 ], [ 51, 77, 77 ], [ 198, 307, 293 ] ]
        },
        msa05: {
            name: "Akron - OH",
            data: [ [ 11436, 9854, 13832 ], [ 3652, 2594, 3355 ], [ 351, 404, 624 ], [ 32, 66, 66 ] ]
        },
        msa06: {
            name: "Albany - GA",
            data: [ [ 1275, 1138, 1487 ], [ 640, 401, 483 ], [ 208, 209, 320 ], [ 30, 42, 27 ] ]
        },
        msa07: {
            name: "Albany, Schenectady, Troy - NY",
            data: [ [ 13865, 12191, 16815 ], [ 4074, 2988, 3268 ], [ 418, 488, 800 ], [ 104, 168, 270 ] ]
        },
        msa08: {
            name: "Albuquerque - NM",
            data: [ [ 13342, 11943, 16855 ], [ 6161, 4216, 5570 ], [ 1821, 2239, 3535 ], [ 50, 57, 95 ] ]
        },
        msa09: {
            name: "Alexandria - LA",
            data: [ [ 1873, 1752, 2064 ], [ 471, 372, 374 ], [ 122, 183, 261 ], [ 245, 250, 221 ] ]
        },
        msa10: {
            name: "Allentown, Bethlehem, Easton - PA, NJ",
            data: [ [ 15810, 13222, 17473 ], [ 4486, 3135, 3782 ], [ 393, 489, 757 ], [ 108, 273, 303 ] ]
        },
        msa11: {
            name: "Altoona - PA",
            data: [ [ 1861, 1800, 2436 ], [ 419, 357, 389 ], [ 66, 80, 133 ], [ 21, 49, 50 ] ]
        },
        msa12: {
            name: "Amarillo - TX",
            data: [ [ 2772, 2550, 3642 ], [ 1506, 1210, 1270 ], [ 254, 345, 440 ], [ 18, 21, 48 ] ]
        },
        msa13: {
            name: "Ames - IA",
            data: [ [ 2175, 1941, 2526 ], [ 326, 226, 206 ], [ 44, 64, 98 ], [ 47, 75, 79 ] ]
        },
        msa14: {
            name: "Anchorage - AK",
            data: [ [ 7677, 6483, 8781 ], [ 2821, 2147, 2526 ], [ 2112, 2440, 3372 ], [ 149, 177, 143 ] ]
        },
        msa15: {
            name: "Ann Arbor - MI",
            data: [ [ 7518, 7190, 11295 ], [ 1180, 1016, 1080 ], [ 79, 156, 234 ], [ 71, 155, 148 ] ]
        },
        msa16: {
            name: "Anniston, Oxford, Jacksonville - AL",
            data: [ [ 1089, 996, 1319 ], [ 527, 358, 369 ], [ 147, 199, 246 ], [ 32, 47, 61 ] ]
        },
        msa17: {
            name: "Appleton - WI",
            data: [ [ 9102, 7537, 10068 ], [ 1211, 708, 1056 ], [ 164, 208, 328 ], [ 63, 66, 73 ] ]
        },
        msa18: {
            name: "Asheville - NC",
            data: [ [ 8148, 7468, 9350 ], [ 1109, 696, 763 ], [ 241, 317, 588 ], [ 259, 335, 435 ] ]
        },
        msa19: {
            name: "Athens, Clarke County - GA",
            data: [ [ 2384, 2401, 3281 ], [ 743, 549, 604 ], [ 83, 95, 132 ], [ 32, 55, 49 ] ]
        },
        msa20: {
            name: "Atlanta, Sandy Springs, Roswell - GA",
            data: [ [ 70815, 73872, 112667 ], [ 33197, 25318, 32334 ], [ 5061, 6050, 9007 ], [ 885, 1263, 1217 ] ]
        },
        msa21: {
            name: "Atlantic City, Hammonton - NJ",
            data: [ [ 4247, 3396, 4279 ], [ 1330, 855, 979 ], [ 133, 149, 226 ], [ 104, 178, 203 ] ]
        },
        msa22: {
            name: "Auburn, Opelika - AL",
            data: [ [ 1857, 1668, 2588 ], [ 752, 518, 604 ], [ 381, 515, 588 ], [ 39, 39, 59 ] ]
        },
        msa23: {
            name: "Augusta, Richmond County - GA, SC",
            data: [ [ 6317, 5653, 6750 ], [ 2749, 2006, 2159 ], [ 2050, 2416, 3238 ], [ 132, 153, 215 ] ]
        },
        msa24: {
            name: "Austin, Round Rock - TX",
            data: [ [ 33544, 31863, 44069 ], [ 8712, 6840, 8662 ], [ 2130, 2540, 4044 ], [ 989, 1e3, 1145 ] ]
        },
        msa25: {
            name: "Bakersfield - CA",
            data: [ [ 4986, 4500, 9857 ], [ 5689, 4569, 5401 ], [ 803, 897, 1342 ], [ 162, 195, 222 ] ]
        },
        msa26: {
            name: "Baltimore, Columbia, Towson - MD",
            data: [ [ 55887, 48121, 64385 ], [ 18391, 12502, 15873 ], [ 3840, 4778, 8073 ], [ 102, 254, 344 ] ]
        },
        msa27: {
            name: "Bangor - ME",
            data: [ [ 2065, 1894, 2372 ], [ 507, 375, 406 ], [ 135, 154, 210 ], [ 159, 114, 134 ] ]
        },
        msa28: {
            name: "Barnstable Town - MA",
            data: [ [ 6386, 5414, 7874 ], [ 669, 421, 503 ], [ 102, 144, 267 ], [ 52, 70, 110 ] ]
        },
        msa29: {
            name: "Baton Rouge - LA",
            data: [ [ 12290, 10706, 14830 ], [ 4121, 2886, 3697 ], [ 476, 675, 962 ], [ 1271, 1293, 1645 ] ]
        },
        msa30: {
            name: "Battle Creek - MI",
            data: [ [ 1735, 1717, 2329 ], [ 432, 363, 458 ], [ 67, 127, 126 ], [ 77, 65, 81 ] ]
        },
        msa31: {
            name: "Bay City - MI",
            data: [ [ 1503, 1594, 2452 ], [ 425, 327, 425 ], [ 41, 70, 76 ], [ 31, 51, 54 ] ]
        },
        msa32: {
            name: "Beaumont, Port Arthur - TX",
            data: [ [ 3360, 3208, 3600 ], [ 1036, 1003, 1192 ], [ 189, 224, 276 ], [ 83, 93, 127 ] ]
        },
        msa33: {
            name: "Bellingham - WA",
            data: [ [ 5604, 4431, 6290 ], [ 911, 509, 749 ], [ 228, 309, 467 ], [ 97, 180, 169 ] ]
        },
        msa34: {
            name: "Bend, Redmond - OR",
            data: [ [ 3038, 2874, 5376 ], [ 847, 554, 698 ], [ 199, 255, 414 ], [ 164, 148, 162 ] ]
        },
        msa35: {
            name: "Bethesda, Rockville, Frederick - MD",
            data: [ [ 38409, 34485, 47930 ], [ 7297, 4761, 5887 ], [ 1315, 1630, 2668 ], [ 57, 164, 230 ] ]
        },
        msa36: {
            name: "Billings - MT",
            data: [ [ 3847, 3290, 4478 ], [ 1354, 860, 914 ], [ 301, 318, 464 ], [ 73, 109, 127 ] ]
        },
        msa37: {
            name: "Binghamton - NY",
            data: [ [ 2284, 2056, 2854 ], [ 783, 763, 757 ], [ 92, 108, 153 ], [ 67, 73, 86 ] ]
        },
        msa38: {
            name: "Birmingham, Hoover - AL",
            data: [ [ 16264, 13762, 20047 ], [ 6335, 4663, 5593 ], [ 837, 1034, 1480 ], [ 571, 619, 775 ] ]
        },
        msa39: {
            name: "Bismarck - ND",
            data: [ [ 3441, 2793, 4489 ], [ 909, 617, 518 ], [ 165, 237, 308 ], [ 52, 69, 55 ] ]
        },
        msa40: {
            name: "Blacksburg, Christiansburg, Radford - VA",
            data: [ [ 2369, 2026, 2542 ], [ 485, 338, 398 ], [ 80, 137, 170 ], [ 206, 202, 228 ] ]
        },
        msa41: {
            name: "Bloomington - IN",
            data: [ [ 3453, 3244, 4333 ], [ 663, 449, 560 ], [ 100, 167, 259 ], [ 139, 142, 141 ] ]
        },
        msa42: {
            name: "Boise City - ID",
            data: [ [ 10137, 8747, 17990 ], [ 5161, 3609, 4067 ], [ 1093, 1261, 2071 ], [ 131, 243, 214 ] ]
        },
        msa43: {
            name: "Boulder - CO",
            data: [ [ 11772, 10003, 15028 ], [ 1535, 852, 1168 ], [ 149, 217, 390 ], [ 0, 1, 3 ] ]
        },
        msa44: {
            name: "Bowling Green - KY",
            data: [ [ 2087, 2167, 2512 ], [ 569, 422, 456 ], [ 73, 96, 146 ], [ 32, 76, 113 ] ]
        },
        msa45: {
            name: "Bremerton, Silverdale - WA",
            data: [ [ 5515, 4529, 6303 ], [ 1145, 709, 975 ], [ 1394, 1623, 2438 ], [ 161, 226, 257 ] ]
        },
        msa46: {
            name: "Bridgeport, Stamford, Norwalk - CT",
            data: [ [ 24697, 21833, 28178 ], [ 2857, 2010, 2289 ], [ 123, 170, 294 ], [ 6, 2, 14 ] ]
        },
        msa47: {
            name: "Brownsville, Harlingen - TX",
            data: [ [ 1225, 1516, 1634 ], [ 876, 807, 1003 ], [ 158, 174, 239 ], [ 23, 12, 1 ] ]
        },
        msa48: {
            name: "Brunswick - GA",
            data: [ [ 1280, 1151, 1494 ], [ 373, 305, 313 ], [ 143, 178, 243 ], [ 14, 32, 49 ] ]
        },
        msa49: {
            name: "Buffalo, Cheektowaga, Niagara Falls - NY",
            data: [ [ 10171, 9650, 12103 ], [ 5160, 4890, 5025 ], [ 574, 702, 930 ], [ 66, 76, 66 ] ]
        },
        msa50: {
            name: "Burlington - NC",
            data: [ [ 2086, 1986, 2354 ], [ 666, 502, 573 ], [ 125, 153, 199 ], [ 75, 87, 121 ] ]
        },
        msa51: {
            name: "Burlington, South Burlington - VT",
            data: [ [ 7143, 5997, 8433 ], [ 567, 317, 376 ], [ 143, 189, 323 ], [ 102, 178, 255 ] ]
        },
        msa52: {
            name: "Camden - NJ",
            data: [ [ 23503, 20399, 25838 ], [ 7556, 5379, 6936 ], [ 969, 1172, 1670 ], [ 123, 303, 435 ] ]
        },
        msa53: {
            name: "Canton, Massillon - OH",
            data: [ [ 5504, 4907, 6816 ], [ 2074, 1504, 1911 ], [ 188, 262, 401 ], [ 32, 86, 88 ] ]
        },
        msa54: {
            name: "Cape Coral, Fort Myers - FL",
            data: [ [ 4943, 5335, 10724 ], [ 2619, 1923, 2007 ], [ 339, 473, 704 ], [ 205, 170, 140 ] ]
        },
        msa55: {
            name: "Cape Girardeau - MO, IL",
            data: [ [ 1692, 1577, 2136 ], [ 384, 260, 233 ], [ 79, 69, 112 ], [ 110, 127, 114 ] ]
        },
        msa56: {
            name: "Carson City - NV",
            data: [ [ 640, 496, 1039 ], [ 240, 199, 262 ], [ 43, 56, 99 ], [ 0, 0, 1 ] ]
        },
        msa57: {
            name: "Casper - WY",
            data: [ [ 1542, 1297, 1965 ], [ 719, 608, 685 ], [ 111, 141, 195 ], [ 35, 73, 102 ] ]
        },
        msa58: {
            name: "Cedar Rapids - IA",
            data: [ [ 9156, 7714, 8521 ], [ 1734, 870, 898 ], [ 244, 257, 425 ], [ 88, 123, 149 ] ]
        },
        msa59: {
            name: "Champaign, Urbana - IL",
            data: [ [ 5809, 4720, 6137 ], [ 720, 489, 481 ], [ 146, 162, 271 ], [ 118, 174, 240 ] ]
        },
        msa60: {
            name: "Charleston - WV",
            data: [ [ 4153, 4186, 4710 ], [ 991, 800, 782 ], [ 172, 248, 321 ], [ 115, 131, 142 ] ]
        },
        msa61: {
            name: "Charleston, North Charleston - SC",
            data: [ [ 10445, 9673, 14068 ], [ 3652, 2721, 3111 ], [ 1964, 2276, 3392 ], [ 152, 153, 203 ] ]
        },
        msa62: {
            name: "Charlotte, Concord, Gastonia - NC, SC",
            data: [ [ 34632, 32094, 44537 ], [ 10871, 7638, 9433 ], [ 1663, 1960, 3124 ], [ 644, 769, 1065 ] ]
        },
        msa63: {
            name: "Charlottesville - VA",
            data: [ [ 4391, 3827, 5188 ], [ 817, 487, 594 ], [ 290, 297, 487 ], [ 53, 108, 133 ] ]
        },
        msa64: {
            name: "Chattanooga - TN, GA",
            data: [ [ 6643, 6166, 8665 ], [ 3064, 2191, 2564 ], [ 340, 502, 720 ], [ 213, 334, 376 ] ]
        },
        msa65: {
            name: "Cheyenne - WY",
            data: [ [ 1856, 1650, 2467 ], [ 814, 635, 622 ], [ 522, 606, 939 ], [ 3, 10, 18 ] ]
        },
        msa66: {
            name: "Chicago, Joliet, Naperville - IL",
            data: [ [ 177479, 151448, 204005 ], [ 32486, 24046, 30763 ], [ 2384, 2690, 4279 ], [ 151, 190, 225 ] ]
        },
        msa67: {
            name: "Chico - CA",
            data: [ [ 3110, 2597, 4184 ], [ 822, 736, 895 ], [ 130, 145, 254 ], [ 22, 23, 31 ] ]
        },
        msa68: {
            name: "Cincinnati - OH, KY, IN",
            data: [ [ 57355, 47297, 65741 ], [ 12207, 8651, 11402 ], [ 1525, 1836, 2876 ], [ 429, 752, 971 ] ]
        },
        msa69: {
            name: "Clarksville - TN, KY",
            data: [ [ 2345, 2216, 2786 ], [ 1043, 752, 876 ], [ 2694, 3921, 4684 ], [ 50, 61, 102 ] ]
        },
        msa70: {
            name: "Cleveland - TN",
            data: [ [ 1477, 1334, 1801 ], [ 737, 533, 598 ], [ 54, 96, 128 ], [ 59, 83, 95 ] ]
        },
        msa71: {
            name: "Cleveland, Elyria - OH",
            data: [ [ 31229, 28051, 39527 ], [ 9377, 6946, 9381 ], [ 904, 1136, 1805 ], [ 103, 145, 169 ] ]
        },
        msa72: {
            name: "Coeur d&apos;Alene - ID",
            data: [ [ 3076, 2387, 3283 ], [ 862, 626, 658 ], [ 239, 322, 435 ], [ 173, 220, 221 ] ]
        },
        msa73: {
            name: "College Station, Bryan - TX",
            data: [ [ 2369, 2175, 2645 ], [ 898, 680, 692 ], [ 142, 153, 254 ], [ 17, 28, 46 ] ]
        },
        msa74: {
            name: "Colorado Springs - CO",
            data: [ [ 13637, 11368, 16180 ], [ 4272, 2913, 3739 ], [ 6075, 7103, 10979 ], [ 12, 26, 33 ] ]
        },
        msa75: {
            name: "Columbia - MO",
            data: [ [ 4118, 3475, 5027 ], [ 873, 545, 766 ], [ 202, 192, 338 ], [ 135, 174, 189 ] ]
        },
        msa76: {
            name: "Columbia - SC",
            data: [ [ 10498, 9506, 13235 ], [ 4120, 2772, 3246 ], [ 1838, 1994, 2928 ], [ 336, 396, 504 ] ]
        },
        msa77: {
            name: "Columbus - GA, AL",
            data: [ [ 2181, 2072, 2854 ], [ 1353, 851, 1034 ], [ 1428, 1742, 2196 ], [ 26, 38, 55 ] ]
        },
        msa78: {
            name: "Columbus - IN",
            data: [ [ 2062, 1833, 2435 ], [ 371, 309, 399 ], [ 62, 75, 106 ], [ 15, 58, 38 ] ]
        },
        msa79: {
            name: "Columbus - OH",
            data: [ [ 39671, 34305, 48358 ], [ 12227, 8260, 11747 ], [ 1612, 1911, 2879 ], [ 251, 392, 466 ] ]
        },
        msa80: {
            name: "Corpus Christi - TX",
            data: [ [ 3418, 3464, 4315 ], [ 1563, 1282, 1383 ], [ 627, 695, 981 ], [ 40, 34, 33 ] ]
        },
        msa81: {
            name: "Corvallis - OR",
            data: [ [ 1916, 1555, 2190 ], [ 252, 165, 188 ], [ 50, 75, 112 ], [ 9, 18, 20 ] ]
        },
        msa82: {
            name: "Crestview, Fort Walton Beach, Destin - FL",
            data: [ [ 2049, 1914, 2866 ], [ 469, 376, 377 ], [ 1431, 1939, 2678 ], [ 105, 145, 164 ] ]
        },
        msa83: {
            name: "Cumberland - MD, WV",
            data: [ [ 1216, 1053, 1322 ], [ 237, 171, 209 ], [ 40, 65, 93 ], [ 35, 39, 128 ] ]
        },
        msa84: {
            name: "Dallas, Plano, Irving - TX",
            data: [ [ 61962, 60043, 81955 ], [ 20704, 16831, 21550 ], [ 3547, 4177, 6591 ], [ 931, 1096, 1451 ] ]
        },
        msa85: {
            name: "Dalton - GA",
            data: [ [ 918, 972, 1333 ], [ 598, 432, 495 ], [ 52, 34, 42 ], [ 74, 77, 77 ] ]
        },
        msa86: {
            name: "Danville - IL",
            data: [ [ 813, 716, 884 ], [ 152, 140, 113 ], [ 55, 47, 52 ], [ 19, 34, 66 ] ]
        },
        msa87: {
            name: "Davenport, Moline, Rock Island - IA, IL",
            data: [ [ 10304, 7886, 11318 ], [ 2293, 1492, 1533 ], [ 389, 500, 691 ], [ 74, 164, 184 ] ]
        },
        msa88: {
            name: "Dayton - OH",
            data: [ [ 15178, 13367, 18081 ], [ 4172, 3016, 3865 ], [ 1446, 1609, 2445 ], [ 63, 165, 238 ] ]
        },
        msa89: {
            name: "Decatur - AL",
            data: [ [ 1943, 1864, 2252 ], [ 872, 617, 727 ], [ 141, 194, 285 ], [ 32, 53, 91 ] ]
        },
        msa90: {
            name: "Decatur - IL",
            data: [ [ 1919, 1546, 2444 ], [ 477, 401, 461 ], [ 91, 100, 115 ], [ 17, 34, 39 ] ]
        },
        msa91: {
            name: "Deltona, Daytona Beach, Ormond Beach - FL",
            data: [ [ 3289, 3403, 7360 ], [ 1963, 1501, 1703 ], [ 389, 468, 723 ], [ 132, 122, 106 ] ]
        },
        msa92: {
            name: "Denver, Aurora, Lakewood - CO",
            data: [ [ 71859, 60781, 93030 ], [ 25170, 16379, 23659 ], [ 3809, 5055, 7989 ], [ 42, 59, 82 ] ]
        },
        msa93: {
            name: "Des Moines, West Des Moines - IA",
            data: [ [ 15446, 14556, 20468 ], [ 5089, 3468, 3850 ], [ 485, 674, 981 ], [ 105, 147, 181 ] ]
        },
        msa94: {
            name: "Detroit, Livonia, Dearborn - MI",
            data: [ [ 11878, 12329, 28117 ], [ 5893, 5060, 6203 ], [ 392, 562, 678 ], [ 12, 12, 20 ] ]
        },
        msa95: {
            name: "Dothan - AL",
            data: [ [ 1699, 1648, 2077 ], [ 657, 491, 513 ], [ 294, 322, 467 ], [ 50, 67, 90 ] ]
        },
        msa96: {
            name: "Dover - DE",
            data: [ [ 1975, 1773, 2559 ], [ 984, 628, 720 ], [ 596, 643, 1124 ], [ 96, 179, 299 ] ]
        },
        msa97: {
            name: "Dubuque - IA",
            data: [ [ 4062, 3378, 4577 ], [ 529, 276, 279 ], [ 73, 77, 102 ], [ 24, 25, 44 ] ]
        },
        msa98: {
            name: "Duluth - MN, WI",
            data: [ [ 5817, 4996, 6520 ], [ 1160, 806, 936 ], [ 206, 248, 381 ], [ 51, 79, 89 ] ]
        },
        msa99: {
            name: "Durham, Chapel Hill - NC",
            data: [ [ 10647, 9870, 12177 ], [ 2107, 1455, 1602 ], [ 359, 470, 672 ], [ 69, 103, 143 ] ]
        },
        msa100: {
            name: "Eau Claire - WI",
            data: [ [ 4985, 4272, 5779 ], [ 486, 291, 348 ], [ 105, 121, 165 ], [ 71, 52, 80 ] ]
        },
        msa101: {
            name: "Edison, New Brunswick - NJ",
            data: [ [ 53104, 49719, 63353 ], [ 10029, 7341, 9043 ], [ 646, 921, 1366 ], [ 100, 194, 227 ] ]
        },
        msa102: {
            name: "El Centro - CA",
            data: [ [ 478, 583, 1147 ], [ 915, 728, 810 ], [ 168, 163, 246 ], [ 130, 217, 229 ] ]
        },
        msa103: {
            name: "El Paso - TX",
            data: [ [ 4851, 4643, 5551 ], [ 3393, 2854, 3523 ], [ 1963, 2402, 2770 ], [ 140, 124, 177 ] ]
        },
        msa104: {
            name: "Elizabethtown, Fort Knox - KY",
            data: [ [ 1743, 1512, 1880 ], [ 533, 358, 361 ], [ 1015, 787, 1297 ], [ 41, 89, 139 ] ]
        },
        msa105: {
            name: "Elkhart, Goshen - IN",
            data: [ [ 3023, 2962, 3988 ], [ 921, 741, 851 ], [ 74, 83, 126 ], [ 48, 125, 137 ] ]
        },
        msa106: {
            name: "Elmira - NY",
            data: [ [ 1206, 1119, 1348 ], [ 245, 255, 235 ], [ 43, 56, 69 ], [ 25, 30, 32 ] ]
        },
        msa107: {
            name: "Erie - PA",
            data: [ [ 4049, 3720, 4891 ], [ 987, 845, 891 ], [ 182, 185, 293 ], [ 24, 29, 22 ] ]
        },
        msa108: {
            name: "Eugene - OR",
            data: [ [ 6721, 5277, 7674 ], [ 1823, 1217, 1535 ], [ 426, 538, 779 ], [ 92, 140, 185 ] ]
        },
        msa109: {
            name: "Evansville - IN, KY",
            data: [ [ 7528, 6703, 8602 ], [ 1897, 1294, 1255 ], [ 251, 292, 374 ], [ 270, 296, 239 ] ]
        },
        msa110: {
            name: "Fairbanks - AK",
            data: [ [ 1329, 1235, 1748 ], [ 423, 332, 358 ], [ 556, 649, 868 ], [ 30, 38, 33 ] ]
        },
        msa111: {
            name: "Fargo - ND, MN",
            data: [ [ 4869, 4547, 6232 ], [ 1674, 1140, 1395 ], [ 265, 309, 510 ], [ 27, 33, 53 ] ]
        },
        msa112: {
            name: "Farmington - NM",
            data: [ [ 857, 855, 1126 ], [ 619, 385, 550 ], [ 123, 129, 198 ], [ 62, 46, 68 ] ]
        },
        msa113: {
            name: "Fayetteville - NC",
            data: [ [ 2638, 2500, 2722 ], [ 1248, 827, 784 ], [ 4709, 4955, 5881 ], [ 142, 178, 171 ] ]
        },
        msa114: {
            name: "Fayetteville, Springdale, Rogers - AR, MO",
            data: [ [ 7664, 6766, 10700 ], [ 3006, 2233, 2809 ], [ 499, 544, 898 ], [ 523, 606, 764 ] ]
        },
        msa115: {
            name: "Flagstaff - AZ",
            data: [ [ 1793, 1518, 2222 ], [ 497, 375, 453 ], [ 88, 116, 185 ], [ 14, 22, 42 ] ]
        },
        msa116: {
            name: "Flint - MI",
            data: [ [ 3606, 3519, 6979 ], [ 1471, 1260, 1675 ], [ 121, 219, 247 ], [ 369, 361, 520 ] ]
        },
        msa117: {
            name: "Florence - SC",
            data: [ [ 1852, 1860, 2327 ], [ 771, 511, 559 ], [ 149, 170, 202 ], [ 68, 40, 76 ] ]
        },
        msa118: {
            name: "Florence, Muscle Shoals - AL",
            data: [ [ 2210, 2207, 2809 ], [ 537, 386, 453 ], [ 100, 111, 165 ], [ 47, 85, 88 ] ]
        },
        msa119: {
            name: "Fond du Lac - WI",
            data: [ [ 3806, 2914, 4218 ], [ 365, 224, 281 ], [ 82, 75, 135 ], [ 29, 28, 36 ] ]
        },
        msa120: {
            name: "Fort Collins - CO",
            data: [ [ 9381, 8027, 12094 ], [ 2254, 1534, 1897 ], [ 382, 515, 857 ], [ 51, 64, 105 ] ]
        },
        msa121: {
            name: "Fort Lauderdale, Pompano Beach, Deerfield Beach - FL",
            data: [ [ 13729, 13911, 25548 ], [ 7428, 6372, 6472 ], [ 705, 880, 1285 ], [ 1, 0, 0 ] ]
        },
        msa122: {
            name: "Fort Smith - AR, OK",
            data: [ [ 3241, 2812, 3454 ], [ 1372, 1023, 1066 ], [ 287, 349, 481 ], [ 403, 437, 394 ] ]
        },
        msa123: {
            name: "Fort Wayne - IN",
            data: [ [ 9002, 7666, 10736 ], [ 2988, 2303, 2970 ], [ 346, 466, 610 ], [ 170, 278, 282 ] ]
        },
        msa124: {
            name: "Fort Worth, Arlington - TX",
            data: [ [ 24849, 24910, 33220 ], [ 12419, 10539, 13307 ], [ 2710, 3127, 4701 ], [ 355, 341, 281 ] ]
        },
        msa125: {
            name: "Fresno - CA",
            data: [ [ 7696, 6842, 12396 ], [ 5022, 4416, 4891 ], [ 466, 595, 906 ], [ 207, 245, 262 ] ]
        },
        msa126: {
            name: "Gadsden - AL",
            data: [ [ 1005, 934, 1278 ], [ 427, 326, 320 ], [ 77, 74, 113 ], [ 30, 59, 67 ] ]
        },
        msa127: {
            name: "Gainesville - FL",
            data: [ [ 2797, 2424, 3485 ], [ 811, 595, 722 ], [ 174, 243, 297 ], [ 50, 78, 105 ] ]
        },
        msa128: {
            name: "Gainesville - GA",
            data: [ [ 1936, 2184, 3018 ], [ 816, 714, 758 ], [ 102, 131, 211 ], [ 20, 73, 35 ] ]
        },
        msa129: {
            name: "Gary - IN",
            data: [ [ 11923, 10757, 14734 ], [ 4142, 3636, 4294 ], [ 428, 584, 846 ], [ 112, 146, 143 ] ]
        },
        msa130: {
            name: "Glens Falls - NY",
            data: [ [ 1292, 1285, 1645 ], [ 470, 341, 389 ], [ 64, 76, 100 ], [ 75, 73, 96 ] ]
        },
        msa131: {
            name: "Goldsboro - NC",
            data: [ [ 938, 1018, 1172 ], [ 318, 240, 289 ], [ 646, 636, 821 ], [ 36, 40, 77 ] ]
        },
        msa132: {
            name: "Grand Forks - ND, MN",
            data: [ [ 1663, 1541, 2299 ], [ 526, 382, 357 ], [ 129, 162, 230 ], [ 22, 32, 23 ] ]
        },
        msa133: {
            name: "Grand Junction - CO",
            data: [ [ 3226, 2168, 3486 ], [ 1587, 1090, 1856 ], [ 256, 331, 532 ], [ 87, 96, 143 ] ]
        },
        msa134: {
            name: "Grand Rapids, Wyoming - MI",
            data: [ [ 16107, 14107, 20446 ], [ 3490, 2862, 3814 ], [ 227, 411, 553 ], [ 370, 468, 509 ] ]
        },
        msa135: {
            name: "Great Falls - MT",
            data: [ [ 1633, 1370, 2039 ], [ 619, 447, 491 ], [ 395, 425, 670 ], [ 12, 15, 22 ] ]
        },
        msa136: {
            name: "Greeley - CO",
            data: [ [ 5018, 4315, 6714 ], [ 2547, 1870, 2541 ], [ 420, 529, 891 ], [ 114, 245, 371 ] ]
        },
        msa137: {
            name: "Green Bay - WI",
            data: [ [ 12504, 9040, 12719 ], [ 2193, 1176, 1472 ], [ 253, 286, 438 ], [ 52, 86, 92 ] ]
        },
        msa138: {
            name: "Greensboro, High Point - NC",
            data: [ [ 10683, 9874, 12149 ], [ 3316, 2566, 2779 ], [ 593, 767, 993 ], [ 279, 403, 459 ] ]
        },
        msa139: {
            name: "Greenville - NC",
            data: [ [ 2282, 2140, 2536 ], [ 788, 501, 503 ], [ 215, 248, 294 ], [ 114, 108, 149 ] ]
        },
        msa140: {
            name: "Greenville, Anderson, Mauldin - SC",
            data: [ [ 9579, 9462, 13046 ], [ 3244, 2280, 2564 ], [ 503, 712, 994 ], [ 357, 459, 534 ] ]
        },
        msa141: {
            name: "Guayama - PR",
            data: [ [ 180, 187, 199 ], [ 184, 171, 244 ], [ 8, 21, 22 ], [ 76, 73, 99 ] ]
        },
        msa142: {
            name: "Gulfport, Biloxi, Pascagoula - MS",
            data: [ [ 2283, 1938, 2312 ], [ 735, 580, 521 ], [ 516, 515, 802 ], [ 93, 120, 173 ] ]
        },
        msa143: {
            name: "Hagerstown, Martinsburg - MD, WV",
            data: [ [ 3602, 3071, 4415 ], [ 1388, 876, 1078 ], [ 465, 553, 815 ], [ 433, 617, 777 ] ]
        },
        msa144: {
            name: "Hanford, Corcoran - CA",
            data: [ [ 745, 658, 1265 ], [ 558, 457, 584 ], [ 331, 307, 483 ], [ 79, 81, 115 ] ]
        },
        msa145: {
            name: "Harrisburg, Carlisle - PA",
            data: [ [ 11583, 10026, 12640 ], [ 3111, 2228, 2472 ], [ 643, 762, 1171 ], [ 90, 162, 182 ] ]
        },
        msa146: {
            name: "Harrisonburg - VA",
            data: [ [ 2090, 1800, 2309 ], [ 397, 225, 309 ], [ 74, 74, 127 ], [ 44, 66, 80 ] ]
        },
        msa147: {
            name: "Hartford, West Hartford, East Hartford - CT",
            data: [ [ 25990, 21905, 30234 ], [ 6650, 4438, 5893 ], [ 428, 602, 922 ], [ 40, 96, 172 ] ]
        },
        msa148: {
            name: "Hattiesburg - MS",
            data: [ [ 1829, 1584, 1983 ], [ 551, 357, 408 ], [ 129, 135, 217 ], [ 137, 116, 133 ] ]
        },
        msa149: {
            name: "Hickory, Lenoir, Morganton - NC",
            data: [ [ 4624, 4484, 5334 ], [ 1125, 781, 787 ], [ 195, 264, 377 ], [ 351, 418, 465 ] ]
        },
        msa150: {
            name: "Hinesville - GA",
            data: [ [ 336, 278, 320 ], [ 198, 155, 145 ], [ 570, 935, 1009 ], [ 14, 12, 22 ] ]
        },
        msa151: {
            name: "Hot Springs - AR",
            data: [ [ 1473, 1228, 1701 ], [ 442, 294, 327 ], [ 99, 107, 176 ], [ 69, 114, 136 ] ]
        },
        msa152: {
            name: "Houma, Thibodaux - LA",
            data: [ [ 3092, 2905, 3383 ], [ 932, 616, 773 ], [ 72, 102, 185 ], [ 214, 206, 297 ] ]
        },
        msa153: {
            name: "Houston, The Woodlands, Sugar Land - TX",
            data: [ [ 68788, 72571, 92702 ], [ 27590, 22226, 26681 ], [ 3908, 4625, 7118 ], [ 384, 590, 734 ] ]
        },
        msa154: {
            name: "Huntington, Ashland - WV, KY, OH",
            data: [ [ 4002, 3880, 4373 ], [ 940, 716, 602 ], [ 185, 204, 237 ], [ 91, 138, 133 ] ]
        },
        msa155: {
            name: "Huntsville - AL",
            data: [ [ 8863, 7810, 10066 ], [ 2937, 1851, 2132 ], [ 1572, 1735, 2713 ], [ 454, 572, 635 ] ]
        },
        msa156: {
            name: "Idaho Falls - ID",
            data: [ [ 2294, 1804, 2666 ], [ 1083, 730, 787 ], [ 146, 132, 241 ], [ 98, 104, 109 ] ]
        },
        msa157: {
            name: "Indianapolis, Carmel, Anderson - IN",
            data: [ [ 41369, 36105, 49135 ], [ 14102, 10840, 13937 ], [ 2128, 2500, 3686 ], [ 433, 701, 694 ] ]
        },
        msa158: {
            name: "Iowa City - IA",
            data: [ [ 4989, 4179, 5419 ], [ 354, 177, 179 ], [ 84, 102, 137 ], [ 76, 93, 138 ] ]
        },
        msa159: {
            name: "Ithaca - NY",
            data: [ [ 1357, 1203, 1501 ], [ 162, 111, 140 ], [ 21, 24, 30 ], [ 6, 6, 24 ] ]
        },
        msa160: {
            name: "Jackson - MI",
            data: [ [ 1887, 1723, 3094 ], [ 554, 398, 580 ], [ 55, 107, 131 ], [ 95, 105, 119 ] ]
        },
        msa161: {
            name: "Jackson - MS",
            data: [ [ 6912, 5592, 7566 ], [ 2331, 1794, 2049 ], [ 331, 372, 627 ], [ 303, 319, 361 ] ]
        },
        msa162: {
            name: "Jackson - TN",
            data: [ [ 1301, 1099, 1520 ], [ 601, 422, 493 ], [ 74, 121, 144 ], [ 93, 120, 110 ] ]
        },
        msa163: {
            name: "Jacksonville - FL",
            data: [ [ 14630, 13183, 22788 ], [ 6988, 5127, 5830 ], [ 3600, 4134, 5931 ], [ 288, 510, 518 ] ]
        },
        msa164: {
            name: "Jacksonville - NC",
            data: [ [ 1195, 1065, 1200 ], [ 452, 259, 250 ], [ 3664, 3432, 4254 ], [ 62, 68, 103 ] ]
        },
        msa165: {
            name: "Janesville, Beloit - WI",
            data: [ [ 4048, 3369, 4635 ], [ 600, 423, 538 ], [ 85, 113, 169 ], [ 33, 42, 50 ] ]
        },
        msa166: {
            name: "Jefferson City - MO",
            data: [ [ 3624, 3012, 4198 ], [ 420, 288, 316 ], [ 119, 135, 214 ], [ 177, 183, 179 ] ]
        },
        msa167: {
            name: "Johnson City - TN",
            data: [ [ 2841, 2556, 3284 ], [ 758, 506, 536 ], [ 160, 294, 365 ], [ 69, 116, 165 ] ]
        },
        msa168: {
            name: "Johnstown - PA",
            data: [ [ 2045, 1901, 2374 ], [ 401, 318, 291 ], [ 84, 91, 126 ], [ 28, 54, 49 ] ]
        },
        msa169: {
            name: "Jonesboro - AR",
            data: [ [ 1515, 1571, 2059 ], [ 670, 518, 539 ], [ 93, 108, 135 ], [ 151, 128, 140 ] ]
        },
        msa170: {
            name: "Joplin - MO",
            data: [ [ 2392, 2295, 2939 ], [ 878, 676, 537 ], [ 145, 182, 233 ], [ 187, 215, 435 ] ]
        },
        msa171: {
            name: "Kalamazoo, Portage - MI",
            data: [ [ 5509, 5015, 7710 ], [ 1302, 1105, 1552 ], [ 165, 238, 336 ], [ 193, 251, 308 ] ]
        },
        msa172: {
            name: "Kankakee - IL",
            data: [ [ 1995, 1435, 2223 ], [ 352, 321, 350 ], [ 69, 87, 100 ], [ 27, 29, 30 ] ]
        },
        msa173: {
            name: "Kansas City - MO, KS",
            data: [ [ 43088, 35854, 50595 ], [ 15441, 11064, 14302 ], [ 2542, 3026, 4392 ], [ 550, 796, 892 ] ]
        },
        msa174: {
            name: "Kennewick, Richland - WA",
            data: [ [ 5456, 5136, 6539 ], [ 2608, 1697, 1756 ], [ 580, 631, 858 ], [ 63, 223, 190 ] ]
        },
        msa175: {
            name: "Killeen, Temple - TX",
            data: [ [ 2414, 2351, 2643 ], [ 1237, 1075, 1078 ], [ 4454, 3896, 5221 ], [ 62, 88, 130 ] ]
        },
        msa176: {
            name: "Kingsport, Bristol, Bristol - TN, VA",
            data: [ [ 4030, 3729, 4693 ], [ 1062, 727, 800 ], [ 195, 239, 362 ], [ 107, 127, 117 ] ]
        },
        msa177: {
            name: "Kingston - NY",
            data: [ [ 1967, 1664, 2130 ], [ 372, 357, 312 ], [ 46, 55, 78 ], [ 31, 23, 45 ] ]
        },
        msa178: {
            name: "Knoxville - TN",
            data: [ [ 13056, 10864, 14965 ], [ 4270, 2845, 3270 ], [ 724, 954, 1503 ], [ 286, 359, 520 ] ]
        },
        msa179: {
            name: "Kokomo - IN",
            data: [ [ 1359, 1258, 2206 ], [ 419, 314, 408 ], [ 71, 83, 140 ], [ 58, 67, 53 ] ]
        },
        msa180: {
            name: "La Crosse, Onalaska - WI, MN",
            data: [ [ 4762, 4151, 5591 ], [ 344, 214, 296 ], [ 79, 115, 169 ], [ 33, 48, 59 ] ]
        },
        msa181: {
            name: "Lafayette - LA",
            data: [ [ 4223, 3651, 4794 ], [ 1098, 791, 986 ], [ 175, 274, 410 ], [ 530, 448, 519 ] ]
        },
        msa182: {
            name: "Lake Charles - LA",
            data: [ [ 2341, 2268, 2747 ], [ 873, 638, 777 ], [ 103, 164, 228 ], [ 166, 158, 204 ] ]
        },
        msa183: {
            name: "Lake County, Kenosha County - IL",
            data: [ [ 26137, 21244, 29251 ], [ 3302, 2501, 3522 ], [ 529, 632, 1001 ], [ 18, 34, 46 ] ]
        },
        msa184: {
            name: "Lake Havasu City, Kingman - AZ",
            data: [ [ 1775, 1638, 3016 ], [ 709, 511, 607 ], [ 271, 299, 486 ], [ 143, 138, 176 ] ]
        },
        msa185: {
            name: "Lakeland, Winter Haven - FL",
            data: [ [ 3473, 3221, 6359 ], [ 2407, 1602, 1758 ], [ 528, 569, 798 ], [ 326, 474, 548 ] ]
        },
        msa186: {
            name: "Lancaster - PA",
            data: [ [ 9360, 7724, 10564 ], [ 2794, 1774, 2051 ], [ 335, 411, 618 ], [ 203, 394, 499 ] ]
        },
        msa187: {
            name: "Lansing, East Lansing - MI",
            data: [ [ 7353, 6229, 9854 ], [ 1813, 1398, 1800 ], [ 192, 260, 403 ], [ 272, 384, 437 ] ]
        },
        msa188: {
            name: "Laredo - TX",
            data: [ [ 641, 724, 875 ], [ 968, 793, 1024 ], [ 118, 160, 218 ], [ 2, 1, 0 ] ]
        },
        msa189: {
            name: "Las Cruces - NM",
            data: [ [ 2264, 1984, 2460 ], [ 1060, 783, 919 ], [ 397, 473, 655 ], [ 5, 3, 5 ] ]
        },
        msa190: {
            name: "Las Vegas, Henderson, Paradise - NV",
            data: [ [ 12902, 12012, 28364 ], [ 16711, 11726, 13560 ], [ 3776, 3982, 5733 ], [ 33, 48, 40 ] ]
        },
        msa191: {
            name: "Lawrence - KS",
            data: [ [ 2358, 2020, 2730 ], [ 591, 347, 434 ], [ 93, 86, 139 ], [ 21, 27, 31 ] ]
        },
        msa192: {
            name: "Lawton - OK",
            data: [ [ 840, 674, 780 ], [ 556, 388, 417 ], [ 1122, 1125, 1305 ], [ 18, 27, 30 ] ]
        },
        msa193: {
            name: "Lebanon - PA",
            data: [ [ 2330, 2150, 2738 ], [ 618, 419, 476 ], [ 189, 194, 284 ], [ 29, 91, 121 ] ]
        },
        msa194: {
            name: "Lewiston - ID, WA",
            data: [ [ 1283, 1088, 1484 ], [ 434, 261, 334 ], [ 103, 96, 160 ], [ 0, 0, 2 ] ]
        },
        msa195: {
            name: "Lewiston, Auburn - ME",
            data: [ [ 1518, 1321, 1756 ], [ 445, 398, 481 ], [ 92, 121, 198 ], [ 123, 96, 114 ] ]
        },
        msa196: {
            name: "Lexington, Fayette - KY",
            data: [ [ 9909, 8873, 12598 ], [ 2826, 2066, 2455 ], [ 440, 537, 826 ], [ 183, 302, 383 ] ]
        },
        msa197: {
            name: "Lima - OH",
            data: [ [ 1923, 1630, 2320 ], [ 248, 207, 219 ], [ 52, 50, 88 ], [ 35, 59, 44 ] ]
        },
        msa198: {
            name: "Lincoln - NE",
            data: [ [ 8592, 7125, 9797 ], [ 2174, 1561, 1802 ], [ 364, 523, 771 ], [ 21, 53, 48 ] ]
        },
        msa199: {
            name: "Little Rock, North Little Rock, Conway - AR",
            data: [ [ 10979, 8868, 12911 ], [ 4901, 3455, 3706 ], [ 1589, 1779, 2573 ], [ 797, 806, 939 ] ]
        },
        msa200: {
            name: "Logan - UT, ID",
            data: [ [ 2639, 2087, 2970 ], [ 906, 499, 693 ], [ 72, 69, 155 ], [ 187, 271, 291 ] ]
        },
        msa201: {
            name: "Longview - TX",
            data: [ [ 2148, 2157, 2238 ], [ 617, 578, 608 ], [ 106, 128, 175 ], [ 139, 137, 145 ] ]
        },
        msa202: {
            name: "Longview - WA",
            data: [ [ 1790, 1446, 2031 ], [ 556, 328, 526 ], [ 143, 182, 275 ], [ 45, 70, 90 ] ]
        },
        msa203: {
            name: "Los Angeles, Long Beach, Glendale - CA",
            data: [ [ 147431, 141982, 208917 ], [ 32904, 26046, 32664 ], [ 1948, 2683, 4445 ], [ 18, 27, 32 ] ]
        },
        msa204: {
            name: "Louisville/Jefferson County - KY, IN",
            data: [ [ 26597, 23421, 32018 ], [ 8645, 6174, 7283 ], [ 1506, 1711, 2605 ], [ 279, 621, 859 ] ]
        },
        msa205: {
            name: "Lubbock - TX",
            data: [ [ 2833, 2718, 3618 ], [ 1872, 1336, 1554 ], [ 204, 220, 305 ], [ 19, 31, 28 ] ]
        },
        msa206: {
            name: "Lynchburg - VA",
            data: [ [ 4037, 3444, 3999 ], [ 1167, 800, 906 ], [ 239, 296, 455 ], [ 226, 303, 292 ] ]
        },
        msa207: {
            name: "Macon - GA",
            data: [ [ 1840, 1997, 2524 ], [ 770, 601, 683 ], [ 191, 223, 309 ], [ 37, 41, 46 ] ]
        },
        msa208: {
            name: "Madera - CA",
            data: [ [ 928, 936, 1841 ], [ 802, 668, 721 ], [ 92, 115, 163 ], [ 78, 84, 87 ] ]
        },
        msa209: {
            name: "Madison - WI",
            data: [ [ 24753, 21419, 29392 ], [ 1885, 1274, 1451 ], [ 372, 422, 642 ], [ 211, 236, 356 ] ]
        },
        msa210: {
            name: "Manchester, Nashua - NH",
            data: [ [ 9301, 8102, 11486 ], [ 2403, 1682, 2220 ], [ 365, 439, 721 ], [ 104, 132, 147 ] ]
        },
        msa211: {
            name: "Manhattan - KS",
            data: [ [ 1675, 1596, 2130 ], [ 332, 199, 235 ], [ 602, 678, 956 ], [ 66, 56, 75 ] ]
        },
        msa212: {
            name: "Mankato, North Mankato - MN",
            data: [ [ 2256, 1959, 2594 ], [ 430, 322, 494 ], [ 65, 87, 133 ], [ 21, 41, 62 ] ]
        },
        msa213: {
            name: "Mansfield - OH",
            data: [ [ 1412, 1336, 1999 ], [ 366, 292, 342 ], [ 63, 92, 149 ], [ 38, 63, 61 ] ]
        },
        msa214: {
            name: "Mayagez - PR",
            data: [ [ 198, 247, 318 ], [ 196, 210, 183 ], [ 25, 16, 26 ], [ 7, 6, 7 ] ]
        },
        msa215: {
            name: "McAllen, Edinburg, Mission - TX",
            data: [ [ 2431, 2711, 2754 ], [ 1794, 1378, 1598 ], [ 180, 213, 325 ], [ 21, 8, 11 ] ]
        },
        msa216: {
            name: "Medford - OR",
            data: [ [ 3078, 2497, 4494 ], [ 814, 564, 820 ], [ 220, 339, 512 ], [ 105, 179, 179 ] ]
        },
        msa217: {
            name: "Memphis - TN, MS, AR",
            data: [ [ 13996, 11378, 16861 ], [ 7209, 5159, 6412 ], [ 1335, 1795, 2458 ], [ 472, 637, 751 ] ]
        },
        msa218: {
            name: "Merced - CA",
            data: [ [ 1137, 1097, 2491 ], [ 1621, 1284, 1481 ], [ 143, 161, 225 ], [ 100, 106, 134 ] ]
        },
        msa219: {
            name: "Miami, Miami Beach, Kendall - FL",
            data: [ [ 11203, 12450, 22549 ], [ 6130, 5203, 5529 ], [ 435, 461, 600 ], [ 1, 0, 0 ] ]
        },
        msa220: {
            name: "Michigan City, La Porte - IN",
            data: [ [ 1553, 1467, 1973 ], [ 538, 496, 562 ], [ 77, 87, 137 ], [ 18, 22, 15 ] ]
        },
        msa221: {
            name: "Midland - TX",
            data: [ [ 1616, 1960, 2433 ], [ 830, 998, 1166 ], [ 122, 125, 196 ], [ 2, 3, 4 ] ]
        },
        msa222: {
            name: "Milwaukee, Waukesha, West Allis - WI",
            data: [ [ 45721, 36091, 51306 ], [ 6179, 4032, 5594 ], [ 802, 968, 1463 ], [ 74, 97, 129 ] ]
        },
        msa223: {
            name: "Minneapolis, St. Paul, Bloomington - MN, WI",
            data: [ [ 87576, 72303, 114944 ], [ 22310, 17189, 22744 ], [ 2308, 2662, 4682 ], [ 561, 928, 1183 ] ]
        },
        msa224: {
            name: "Missoula - MT",
            data: [ [ 2536, 2054, 3038 ], [ 515, 301, 266 ], [ 103, 128, 199 ], [ 38, 61, 97 ] ]
        },
        msa225: {
            name: "Mobile - AL",
            data: [ [ 3807, 3136, 3858 ], [ 2265, 1607, 1812 ], [ 413, 494, 733 ], [ 250, 336, 333 ] ]
        },
        msa226: {
            name: "Modesto - CA",
            data: [ [ 4334, 3653, 8146 ], [ 4053, 3109, 3685 ], [ 287, 389, 558 ], [ 75, 131, 164 ] ]
        },
        msa227: {
            name: "Monroe - LA",
            data: [ [ 2047, 1961, 2356 ], [ 677, 483, 525 ], [ 84, 136, 161 ], [ 290, 272, 258 ] ]
        },
        msa228: {
            name: "Monroe - MI",
            data: [ [ 2142, 2110, 3999 ], [ 596, 550, 678 ], [ 60, 91, 132 ], [ 21, 53, 51 ] ]
        },
        msa229: {
            name: "Montgomery - AL",
            data: [ [ 3993, 3390, 4697 ], [ 1937, 1325, 1707 ], [ 938, 985, 1570 ], [ 51, 119, 187 ] ]
        },
        msa230: {
            name: "Morgantown - WV",
            data: [ [ 2164, 2050, 2369 ], [ 408, 298, 281 ], [ 61, 91, 131 ], [ 54, 76, 76 ] ]
        },
        msa231: {
            name: "Morristown - TN",
            data: [ [ 1709, 1518, 1915 ], [ 601, 411, 389 ], [ 64, 125, 156 ], [ 68, 124, 152 ] ]
        },
        msa232: {
            name: "Mount Vernon, Anacortes - WA",
            data: [ [ 2575, 2106, 2797 ], [ 601, 334, 494 ], [ 266, 293, 458 ], [ 42, 74, 83 ] ]
        },
        msa233: {
            name: "Muncie - IN",
            data: [ [ 1236, 1110, 1460 ], [ 501, 377, 420 ], [ 64, 50, 106 ], [ 30, 33, 49 ] ]
        },
        msa234: {
            name: "Muskegon - MI",
            data: [ [ 2021, 1988, 2927 ], [ 694, 646, 768 ], [ 78, 128, 179 ], [ 73, 132, 131 ] ]
        },
        msa235: {
            name: "Myrtle Beach, Conway, North Myrtle Beach - SC, NC",
            data: [ [ 4211, 3887, 5433 ], [ 1e3, 746, 940 ], [ 255, 339, 525 ], [ 84, 108, 159 ] ]
        },
        msa236: {
            name: "Napa - CA",
            data: [ [ 2535, 2233, 3397 ], [ 630, 497, 643 ], [ 35, 57, 116 ], [ 0, 0, 0 ] ]
        },
        msa237: {
            name: "Naples, Immokalee, Marco Island - FL",
            data: [ [ 3410, 3298, 5460 ], [ 936, 727, 731 ], [ 94, 128, 197 ], [ 187, 238, 183 ] ]
        },
        msa238: {
            name: "Nashville, Davidson--Murfreesboro--Franklin - TN",
            data: [ [ 28428, 26225, 36745 ], [ 13e3, 9995, 13317 ], [ 1781, 2331, 3668 ], [ 746, 903, 1256 ] ]
        },
        msa239: {
            name: "Nassau, Suffolk - NY",
            data: [ [ 34856, 31065, 39718 ], [ 8719, 7345, 8330 ], [ 399, 539, 819 ], [ 3, 3, 1 ] ]
        },
        msa240: {
            name: "New Haven, Milford - CT",
            data: [ [ 14708, 12961, 17071 ], [ 4072, 2800, 3565 ], [ 209, 285, 423 ], [ 13, 8, 30 ] ]
        },
        msa241: {
            name: "New Orleans, Metairie - LA",
            data: [ [ 14569, 14441, 17300 ], [ 5037, 4152, 4589 ], [ 740, 948, 1440 ], [ 441, 645, 749 ] ]
        },
        msa242: {
            name: "New York, White Plains, Wayne - NJ, NY",
            data: [ [ 95454, 90292, 109750 ], [ 16157, 13716, 14588 ], [ 422, 621, 986 ], [ 8, 13, 34 ] ]
        },
        msa243: {
            name: "Newark, Union - NJ, PA",
            data: [ [ 41599, 38780, 50582 ], [ 8149, 5953, 7214 ], [ 412, 510, 793 ], [ 45, 134, 130 ] ]
        },
        msa244: {
            name: "Niles, Benton Harbor - MI",
            data: [ [ 2716, 2523, 3339 ], [ 509, 382, 424 ], [ 70, 104, 114 ], [ 39, 66, 69 ] ]
        },
        msa245: {
            name: "North Port, Sarasota, Bradenton - FL",
            data: [ [ 7546, 7468, 13528 ], [ 2332, 1909, 2177 ], [ 441, 648, 979 ], [ 114, 152, 205 ] ]
        },
        msa246: {
            name: "Norwich, New London - CT",
            data: [ [ 5260, 4403, 6191 ], [ 990, 734, 893 ], [ 354, 345, 570 ], [ 52, 77, 117 ] ]
        },
        msa247: {
            name: "Oakland, Fremont, Hayward - CA",
            data: [ [ 78196, 67944, 103755 ], [ 11119, 8725, 10881 ], [ 789, 1150, 1899 ], [ 13, 17, 16 ] ]
        },
        msa248: {
            name: "Ocala - FL",
            data: [ [ 2403, 2216, 4125 ], [ 861, 665, 745 ], [ 264, 324, 511 ], [ 267, 433, 401 ] ]
        },
        msa249: {
            name: "Ocean City - NJ",
            data: [ [ 1941, 1698, 2097 ], [ 321, 195, 217 ], [ 56, 57, 95 ], [ 34, 69, 79 ] ]
        },
        msa250: {
            name: "Odessa - TX",
            data: [ [ 812, 886, 1192 ], [ 693, 624, 864 ], [ 73, 66, 108 ], [ 1, 0, 0 ] ]
        },
        msa251: {
            name: "Ogden, Clearfield - UT",
            data: [ [ 13127, 9994, 16704 ], [ 7044, 3745, 6349 ], [ 1403, 1395, 2662 ], [ 16, 25, 21 ] ]
        },
        msa252: {
            name: "Oklahoma City - OK",
            data: [ [ 17457, 16718, 22063 ], [ 9423, 7498, 8255 ], [ 2729, 3298, 4456 ], [ 215, 266, 331 ] ]
        },
        msa253: {
            name: "Olympia, Tumwater - WA",
            data: [ [ 5881, 4595, 6423 ], [ 1408, 896, 1290 ], [ 1730, 1737, 2581 ], [ 100, 129, 140 ] ]
        },
        msa254: {
            name: "Omaha, Council Bluffs - NE, IA",
            data: [ [ 22635, 17886, 25705 ], [ 7840, 5163, 6070 ], [ 2343, 2733, 3860 ], [ 88, 167, 186 ] ]
        },
        msa255: {
            name: "Orlando, Kissimmee, Sanford - FL",
            data: [ [ 16120, 16652, 36069 ], [ 10898, 8306, 9372 ], [ 1833, 2217, 3262 ], [ 633, 800, 802 ] ]
        },
        msa256: {
            name: "Oshkosh, Neenah - WI",
            data: [ [ 5249, 4561, 5985 ], [ 766, 466, 668 ], [ 138, 160, 246 ], [ 17, 21, 34 ] ]
        },
        msa257: {
            name: "Owensboro - KY",
            data: [ [ 2142, 2082, 2533 ], [ 497, 441, 527 ], [ 73, 103, 155 ], [ 37, 43, 102 ] ]
        },
        msa258: {
            name: "Oxnard, Thousand Oaks, Ventura - CA",
            data: [ [ 19651, 17552, 26326 ], [ 3483, 2620, 3595 ], [ 582, 764, 1359 ], [ 12, 6, 13 ] ]
        },
        msa259: {
            name: "Palm Bay, Melbourne, Titusville - FL",
            data: [ [ 5080, 5079, 10416 ], [ 2231, 1773, 2059 ], [ 952, 1212, 1884 ], [ 23, 21, 29 ] ]
        },
        msa260: {
            name: "Panama City - FL",
            data: [ [ 1570, 1392, 2255 ], [ 487, 442, 422 ], [ 497, 568, 820 ], [ 132, 158, 155 ] ]
        },
        msa261: {
            name: "Parkersburg, Vienna - WV",
            data: [ [ 2140, 2134, 2707 ], [ 458, 401, 379 ], [ 91, 139, 175 ], [ 53, 64, 60 ] ]
        },
        msa262: {
            name: "Pensacola, Ferry Pass, Brent - FL",
            data: [ [ 4080, 3919, 5914 ], [ 1484, 1142, 1274 ], [ 1997, 2173, 3300 ], [ 267, 325, 332 ] ]
        },
        msa263: {
            name: "Peoria - IL",
            data: [ [ 9242, 7708, 10518 ], [ 1661, 1383, 1400 ], [ 311, 348, 534 ], [ 164, 273, 280 ] ]
        },
        msa264: {
            name: "Philadelphia - PA",
            data: [ [ 81757, 73296, 94758 ], [ 19564, 14258, 16022 ], [ 1363, 1676, 2585 ], [ 149, 344, 535 ] ]
        },
        msa265: {
            name: "Phoenix, Mesa, Scottsdale - AZ",
            data: [ [ 53341, 49054, 106237 ], [ 33552, 24470, 28053 ], [ 5720, 6544, 10466 ], [ 1274, 992, 1394 ] ]
        },
        msa266: {
            name: "Pine Bluff - AR",
            data: [ [ 753, 550, 683 ], [ 329, 242, 240 ], [ 69, 57, 101 ], [ 42, 33, 31 ] ]
        },
        msa267: {
            name: "Pittsburgh - PA",
            data: [ [ 38997, 37509, 48329 ], [ 11014, 8728, 9887 ], [ 1001, 1340, 1957 ], [ 382, 527, 497 ] ]
        },
        msa268: {
            name: "Pittsfield - MA",
            data: [ [ 3046, 2129, 3239 ], [ 161, 142, 162 ], [ 40, 65, 63 ], [ 4, 36, 64 ] ]
        },
        msa269: {
            name: "Pocatello - ID",
            data: [ [ 1567, 1482, 1917 ], [ 769, 435, 426 ], [ 73, 101, 124 ], [ 18, 25, 17 ] ]
        },
        msa270: {
            name: "Ponce - PR",
            data: [ [ 558, 572, 746 ], [ 689, 706, 717 ], [ 72, 71, 84 ], [ 170, 247, 150 ] ]
        },
        msa271: {
            name: "Port St. Lucie - FL",
            data: [ [ 3142, 3289, 6832 ], [ 1900, 1463, 1816 ], [ 308, 394, 583 ], [ 40, 44, 45 ] ]
        },
        msa272: {
            name: "Portland, South Portland - ME",
            data: [ [ 14377, 11423, 15748 ], [ 2276, 1516, 1963 ], [ 482, 521, 864 ], [ 502, 559, 639 ] ]
        },
        msa273: {
            name: "Portland, Vancouver, Hillsboro - OR, WA",
            data: [ [ 58446, 45859, 68191 ], [ 13033, 8527, 12029 ], [ 2429, 3040, 5105 ], [ 617, 753, 1041 ] ]
        },
        msa274: {
            name: "Prescott - AZ",
            data: [ [ 3253, 3064, 5269 ], [ 790, 633, 673 ], [ 283, 395, 579 ], [ 180, 169, 225 ] ]
        },
        msa275: {
            name: "Providence, Warwick - RI, MA",
            data: [ [ 30807, 26424, 38378 ], [ 7673, 5361, 6499 ], [ 672, 807, 1468 ], [ 105, 202, 246 ] ]
        },
        msa276: {
            name: "Provo, Orem - UT",
            data: [ [ 10089, 8088, 13464 ], [ 5683, 3075, 5025 ], [ 405, 522, 903 ], [ 425, 639, 804 ] ]
        },
        msa277: {
            name: "Pueblo - CO",
            data: [ [ 2136, 1835, 2428 ], [ 1447, 921, 914 ], [ 328, 488, 622 ], [ 2, 3, 0 ] ]
        },
        msa278: {
            name: "Punta Gorda - FL",
            data: [ [ 1515, 1487, 2914 ], [ 444, 326, 401 ], [ 115, 172, 248 ], [ 9, 15, 7 ] ]
        },
        msa279: {
            name: "Racine - WI",
            data: [ [ 5348, 4407, 6129 ], [ 784, 586, 799 ], [ 137, 159, 242 ], [ 40, 56, 50 ] ]
        },
        msa280: {
            name: "Raleigh - NC",
            data: [ [ 31650, 27429, 37504 ], [ 6448, 4185, 5106 ], [ 1769, 2146, 3261 ], [ 811, 991, 1219 ] ]
        },
        msa281: {
            name: "Rapid City - SD",
            data: [ [ 2347, 2159, 2879 ], [ 522, 416, 485 ], [ 484, 619, 1009 ], [ 59, 175, 225 ] ]
        },
        msa282: {
            name: "Reading - PA",
            data: [ [ 6349, 5835, 7419 ], [ 2285, 1680, 1824 ], [ 198, 265, 388 ], [ 69, 165, 230 ] ]
        },
        msa283: {
            name: "Redding - CA",
            data: [ [ 2408, 1967, 3524 ], [ 772, 502, 660 ], [ 161, 230, 386 ], [ 97, 108, 170 ] ]
        },
        msa284: {
            name: "Reno - NV",
            data: [ [ 5219, 4680, 9200 ], [ 3052, 2387, 2610 ], [ 519, 583, 1008 ], [ 45, 58, 101 ] ]
        },
        msa285: {
            name: "Richmond - VA",
            data: [ [ 23131, 19986, 27854 ], [ 8346, 6281, 7931 ], [ 2046, 2361, 3712 ], [ 205, 407, 433 ] ]
        },
        msa286: {
            name: "Riverside, San Bernardino, Ontario - CA",
            data: [ [ 41802, 38697, 69479 ], [ 31255, 24528, 31599 ], [ 5349, 6390, 9747 ], [ 500, 637, 814 ] ]
        },
        msa287: {
            name: "Roanoke - VA",
            data: [ [ 5188, 4377, 5650 ], [ 1734, 1146, 1332 ], [ 294, 426, 595 ], [ 168, 228, 242 ] ]
        },
        msa288: {
            name: "Rochester - MN",
            data: [ [ 5620, 4670, 6693 ], [ 1033, 778, 986 ], [ 138, 175, 288 ], [ 89, 155, 174 ] ]
        },
        msa289: {
            name: "Rochester - NY",
            data: [ [ 11545, 11377, 14438 ], [ 4702, 4183, 4024 ], [ 423, 497, 681 ], [ 210, 381, 425 ] ]
        },
        msa290: {
            name: "Rockford - IL",
            data: [ [ 7974, 6151, 8352 ], [ 1756, 1128, 1564 ], [ 227, 234, 341 ], [ 10, 18, 17 ] ]
        },
        msa291: {
            name: "Rocky Mount - NC",
            data: [ [ 1334, 1219, 1509 ], [ 404, 259, 287 ], [ 120, 127, 200 ], [ 67, 84, 103 ] ]
        },
        msa292: {
            name: "Rome - GA",
            data: [ [ 674, 795, 1094 ], [ 335, 253, 353 ], [ 38, 42, 73 ], [ 4, 10, 18 ] ]
        },
        msa293: {
            name: "Sacramento--Roseville--Arden, Arcade - CA",
            data: [ [ 40306, 32677, 60054 ], [ 14215, 11242, 15143 ], [ 1823, 2454, 4018 ], [ 195, 373, 458 ] ]
        },
        msa294: {
            name: "Saginaw - MI",
            data: [ [ 2466, 2410, 3732 ], [ 627, 553, 642 ], [ 43, 106, 128 ], [ 95, 116, 150 ] ]
        },
        msa295: {
            name: "Salem - OR",
            data: [ [ 6810, 5077, 6834 ], [ 2029, 1353, 1939 ], [ 479, 641, 931 ], [ 168, 166, 286 ] ]
        },
        msa296: {
            name: "Salinas - CA",
            data: [ [ 4737, 4374, 6414 ], [ 1449, 1134, 1291 ], [ 139, 241, 334 ], [ 229, 256, 323 ] ]
        },
        msa297: {
            name: "Salisbury - MD, DE",
            data: [ [ 1355, 1240, 1486 ], [ 558, 357, 422 ], [ 91, 114, 170 ], [ 96, 136, 154 ] ]
        },
        msa298: {
            name: "Salt Lake City - UT",
            data: [ [ 24640, 19421, 31861 ], [ 12884, 7204, 12002 ], [ 953, 1115, 2081 ], [ 199, 313, 329 ] ]
        },
        msa299: {
            name: "San Angelo - TX",
            data: [ [ 971, 1033, 1198 ], [ 418, 424, 488 ], [ 289, 295, 342 ], [ 5, 3, 3 ] ]
        },
        msa300: {
            name: "San Antonio, New Braunfels - TX",
            data: [ [ 20998, 21727, 25945 ], [ 10428, 7827, 9724 ], [ 6878, 7402, 11137 ], [ 371, 551, 941 ] ]
        },
        msa301: {
            name: "San Diego, Carlsbad - CA",
            data: [ [ 65925, 58976, 89694 ], [ 12646, 8996, 12135 ], [ 5378, 7462, 13019 ], [ 24, 63, 80 ] ]
        },
        msa302: {
            name: "San Francisco, San Mateo, Redwood City - CA",
            data: [ [ 52831, 51259, 74110 ], [ 2451, 1831, 2042 ], [ 121, 184, 350 ], [ 1, 1, 2 ] ]
        },
        msa303: {
            name: "San Germn - PR",
            data: [ [ 331, 435, 512 ], [ 253, 235, 221 ], [ 37, 55, 45 ], [ 145, 191, 179 ] ]
        },
        msa304: {
            name: "San Jose, Sunnyvale, Santa Clara - CA",
            data: [ [ 71139, 62701, 91735 ], [ 4294, 3225, 3814 ], [ 245, 404, 663 ], [ 37, 81, 96 ] ]
        },
        msa305: {
            name: "San Juan, Carolina, Caguas - PR",
            data: [ [ 8078, 8184, 11197 ], [ 8888, 8318, 9750 ], [ 763, 907, 1012 ], [ 1340, 1573, 1424 ] ]
        },
        msa306: {
            name: "San Luis Obispo, Paso Robles, Arroyo Grande - CA",
            data: [ [ 6246, 5350, 8162 ], [ 821, 564, 759 ], [ 119, 246, 409 ], [ 114, 264, 279 ] ]
        },
        msa307: {
            name: "Santa Ana, Anaheim, Irvine - CA",
            data: [ [ 75979, 69948, 109043 ], [ 10135, 7278, 9769 ], [ 690, 1114, 2071 ], [ 2, 0, 0 ] ]
        },
        msa308: {
            name: "Santa Cruz, Watsonville - CA",
            data: [ [ 5876, 5447, 8288 ], [ 631, 503, 637 ], [ 35, 62, 95 ], [ 21, 29, 55 ] ]
        },
        msa309: {
            name: "Santa Fe - NM",
            data: [ [ 2917, 2528, 3471 ], [ 431, 336, 341 ], [ 90, 142, 218 ], [ 2, 8, 10 ] ]
        },
        msa310: {
            name: "Santa Rosa - CA",
            data: [ [ 11200, 9539, 14746 ], [ 1948, 1532, 2008 ], [ 115, 214, 345 ], [ 9, 30, 38 ] ]
        },
        msa311: {
            name: "Savannah - GA",
            data: [ [ 3808, 3746, 4818 ], [ 1677, 1192, 1350 ], [ 1350, 1723, 2172 ], [ 311, 290, 295 ] ]
        },
        msa312: {
            name: "Scranton--Wilkes, Barre--Hazleton - PA",
            data: [ [ 7011, 6606, 8519 ], [ 1861, 1460, 1554 ], [ 265, 318, 439 ], [ 28, 74, 54 ] ]
        },
        msa313: {
            name: "Seattle, Bellevue, Everett - WA",
            data: [ [ 82857, 68264, 97856 ], [ 14495, 9847, 13431 ], [ 2501, 3222, 5157 ], [ 425, 793, 687 ] ]
        },
        msa314: {
            name: "Sebastian, Vero Beach - FL",
            data: [ [ 1373, 1323, 2437 ], [ 422, 322, 385 ], [ 71, 115, 194 ], [ 22, 13, 7 ] ]
        },
        msa315: {
            name: "Sheboygan - WI",
            data: [ [ 3650, 2993, 4023 ], [ 409, 214, 317 ], [ 57, 81, 113 ], [ 26, 35, 61 ] ]
        },
        msa316: {
            name: "Sherman, Denison - TX",
            data: [ [ 1008, 1084, 1273 ], [ 485, 370, 396 ], [ 57, 105, 166 ], [ 36, 57, 48 ] ]
        },
        msa317: {
            name: "Shreveport, Bossier City - LA",
            data: [ [ 4610, 4149, 5634 ], [ 2089, 1533, 1640 ], [ 975, 959, 1457 ], [ 243, 318, 383 ] ]
        },
        msa318: {
            name: "Sioux City - IA, NE, SD",
            data: [ [ 2356, 2277, 3067 ], [ 788, 491, 603 ], [ 89, 137, 157 ], [ 19, 21, 38 ] ]
        },
        msa319: {
            name: "Sioux Falls - SD",
            data: [ [ 6513, 5419, 8324 ], [ 2047, 1483, 1770 ], [ 394, 366, 626 ], [ 144, 221, 258 ] ]
        },
        msa320: {
            name: "South Bend, Mishawaka - IN, MI",
            data: [ [ 4924, 4513, 6269 ], [ 1500, 1150, 1266 ], [ 125, 194, 258 ], [ 31, 56, 65 ] ]
        },
        msa321: {
            name: "Spartanburg - SC",
            data: [ [ 3250, 3138, 4283 ], [ 1188, 793, 971 ], [ 181, 264, 392 ], [ 356, 409, 545 ] ]
        },
        msa322: {
            name: "Spokane, Spokane Valley - WA",
            data: [ [ 9763, 7836, 10774 ], [ 3181, 2100, 2618 ], [ 1082, 1148, 1668 ], [ 40, 66, 81 ] ]
        },
        msa323: {
            name: "Springfield - IL",
            data: [ [ 9216, 6585, 9463 ], [ 858, 762, 835 ], [ 260, 320, 450 ], [ 101, 137, 185 ] ]
        },
        msa324: {
            name: "Springfield - MA",
            data: [ [ 11914, 10294, 13524 ], [ 2513, 1667, 1891 ], [ 381, 465, 705 ], [ 71, 116, 163 ] ]
        },
        msa325: {
            name: "Springfield - MO",
            data: [ [ 8770, 7129, 9672 ], [ 2918, 1855, 2322 ], [ 565, 600, 898 ], [ 385, 433, 523 ] ]
        },
        msa326: {
            name: "Springfield - OH",
            data: [ [ 1737, 1484, 2041 ], [ 592, 413, 526 ], [ 125, 170, 256 ], [ 50, 99, 97 ] ]
        },
        msa327: {
            name: "St. Cloud - MN",
            data: [ [ 4248, 3304, 4929 ], [ 865, 626, 793 ], [ 175, 196, 298 ], [ 110, 185, 214 ] ]
        },
        msa328: {
            name: "St. George - UT",
            data: [ [ 2246, 2012, 3367 ], [ 1095, 822, 1022 ], [ 116, 158, 333 ], [ 85, 117, 91 ] ]
        },
        msa329: {
            name: "St. Joseph - MO, KS",
            data: [ [ 1642, 1444, 1937 ], [ 594, 410, 472 ], [ 97, 121, 158 ], [ 27, 59, 64 ] ]
        },
        msa330: {
            name: "St. Louis - MO, IL",
            data: [ [ 77394, 60588, 82653 ], [ 19836, 13795, 17830 ], [ 3685, 3944, 5950 ], [ 699, 1094, 1249 ] ]
        },
        msa331: {
            name: "State College - PA",
            data: [ [ 3027, 2558, 3458 ], [ 298, 275, 245 ], [ 92, 108, 148 ], [ 88, 124, 124 ] ]
        },
        msa332: {
            name: "Stockton, Lodi - CA",
            data: [ [ 5961, 5519, 11024 ], [ 5357, 4130, 5177 ], [ 478, 649, 905 ], [ 61, 77, 110 ] ]
        },
        msa333: {
            name: "Sumter - SC",
            data: [ [ 708, 689, 799 ], [ 335, 236, 203 ], [ 438, 525, 618 ], [ 15, 15, 17 ] ]
        },
        msa334: {
            name: "Syracuse - NY",
            data: [ [ 7586, 7450, 9295 ], [ 2848, 2357, 2411 ], [ 314, 364, 582 ], [ 66, 119, 167 ] ]
        },
        msa335: {
            name: "Tacoma - WA",
            data: [ [ 14277, 11833, 17196 ], [ 5269, 3467, 5071 ], [ 3158, 3789, 5585 ], [ 244, 513, 472 ] ]
        },
        msa336: {
            name: "Tallahassee - FL",
            data: [ [ 3903, 3391, 5181 ], [ 1453, 989, 1161 ], [ 279, 351, 425 ], [ 148, 170, 183 ] ]
        },
        msa337: {
            name: "Tampa, St. Petersburg, Clearwater - FL",
            data: [ [ 24391, 23485, 42984 ], [ 11136, 9043, 10499 ], [ 3440, 4227, 6445 ], [ 535, 746, 866 ] ]
        },
        msa338: {
            name: "Terre Haute - IN",
            data: [ [ 2521, 2265, 2939 ], [ 575, 477, 448 ], [ 135, 132, 197 ], [ 87, 108, 70 ] ]
        },
        msa339: {
            name: "Texarkana - TX, AR",
            data: [ [ 1193, 1289, 1501 ], [ 416, 337, 315 ], [ 111, 122, 170 ], [ 63, 46, 62 ] ]
        },
        msa340: {
            name: "Toledo - OH",
            data: [ [ 9548, 8775, 12572 ], [ 2309, 1789, 2208 ], [ 293, 346, 556 ], [ 80, 80, 103 ] ]
        },
        msa341: {
            name: "Topeka - KS",
            data: [ [ 4062, 3910, 4617 ], [ 1346, 949, 911 ], [ 303, 325, 442 ], [ 42, 65, 62 ] ]
        },
        msa342: {
            name: "Trenton - NJ",
            data: [ [ 7104, 6763, 8676 ], [ 1426, 974, 1271 ], [ 82, 118, 158 ], [ 1, 8, 11 ] ]
        },
        msa343: {
            name: "Tucson - AZ",
            data: [ [ 14544, 12049, 19626 ], [ 5111, 4223, 5492 ], [ 2079, 2343, 3543 ], [ 206, 301, 456 ] ]
        },
        msa344: {
            name: "Tulsa - OK",
            data: [ [ 12969, 11405, 15451 ], [ 6645, 4833, 5523 ], [ 963, 1221, 1672 ], [ 679, 712, 848 ] ]
        },
        msa345: {
            name: "Tuscaloosa - AL",
            data: [ [ 2815, 2530, 3661 ], [ 1278, 899, 890 ], [ 223, 223, 336 ], [ 100, 113, 266 ] ]
        },
        msa346: {
            name: "Tyler - TX",
            data: [ [ 2697, 2500, 3006 ], [ 690, 639, 694 ], [ 158, 168, 244 ], [ 112, 152, 156 ] ]
        },
        msa347: {
            name: "Utica, Rome - NY",
            data: [ [ 3054, 2806, 3631 ], [ 949, 934, 896 ], [ 106, 122, 215 ], [ 33, 61, 75 ] ]
        },
        msa348: {
            name: "Valdosta - GA",
            data: [ [ 1432, 1437, 1569 ], [ 486, 326, 311 ], [ 458, 527, 647 ], [ 34, 42, 71 ] ]
        },
        msa349: {
            name: "Vallejo, Fairfield - CA",
            data: [ [ 5268, 4549, 8599 ], [ 2994, 2279, 2934 ], [ 1007, 1055, 1722 ], [ 23, 45, 63 ] ]
        },
        msa350: {
            name: "Victoria - TX",
            data: [ [ 995, 1053, 1279 ], [ 388, 291, 344 ], [ 81, 77, 102 ], [ 13, 6, 7 ] ]
        },
        msa351: {
            name: "Vineland, Bridgeton - NJ",
            data: [ [ 1316, 1088, 1289 ], [ 768, 546, 646 ], [ 63, 74, 103 ], [ 11, 34, 34 ] ]
        },
        msa352: {
            name: "Virginia Beach, Norfolk, Newport News - VA, NC",
            data: [ [ 24900, 21422, 27189 ], [ 9590, 7123, 8821 ], [ 10768, 13248, 20030 ], [ 64, 98, 145 ] ]
        },
        msa353: {
            name: "Visalia, Porterville - CA",
            data: [ [ 2348, 2261, 4733 ], [ 2011, 1646, 2053 ], [ 257, 317, 430 ], [ 119, 126, 127 ] ]
        },
        msa354: {
            name: "Waco - TX",
            data: [ [ 2206, 2097, 2558 ], [ 931, 813, 739 ], [ 250, 322, 360 ], [ 59, 80, 98 ] ]
        },
        msa355: {
            name: "Warner Robins - GA",
            data: [ [ 1583, 1575, 1942 ], [ 813, 523, 597 ], [ 1048, 1118, 1480 ], [ 50, 51, 90 ] ]
        },
        msa356: {
            name: "Warren, Farmington Hills, Troy - MI",
            data: [ [ 39329, 41857, 82455 ], [ 12430, 10893, 13847 ], [ 947, 1372, 2097 ], [ 488, 685, 853 ] ]
        },
        msa357: {
            name: "Washington, Arlington, Alexandria - DC, VA, MD",
            data: [ [ 103719, 95749, 143289 ], [ 30661, 21505, 25238 ], [ 12703, 16462, 27701 ], [ 530, 777, 981 ] ]
        },
        msa358: {
            name: "Waterloo, Cedar Falls - IA",
            data: [ [ 4516, 3956, 5051 ], [ 1058, 534, 397 ], [ 90, 106, 152 ], [ 27, 34, 64 ] ]
        },
        msa359: {
            name: "Wausau - WI",
            data: [ [ 4455, 3397, 5123 ], [ 302, 200, 254 ], [ 66, 83, 92 ], [ 39, 62, 75 ] ]
        },
        msa360: {
            name: "Wenatchee - WA",
            data: [ [ 2274, 1854, 2531 ], [ 523, 376, 454 ], [ 95, 115, 176 ], [ 27, 65, 96 ] ]
        },
        msa361: {
            name: "West Palm Beach, Boca Raton, Boynton Beach - FL",
            data: [ [ 12879, 12957, 22154 ], [ 4889, 4305, 4687 ], [ 446, 653, 888 ], [ 3, 1, 1 ] ]
        },
        msa362: {
            name: "Wheeling - WV, OH",
            data: [ [ 1648, 1533, 1968 ], [ 358, 297, 350 ], [ 40, 56, 71 ], [ 113, 83, 107 ] ]
        },
        msa363: {
            name: "Wichita - KS",
            data: [ [ 10833, 8793, 11376 ], [ 4223, 2921, 3093 ], [ 1009, 1049, 1381 ], [ 127, 229, 259 ] ]
        },
        msa364: {
            name: "Wichita Falls - TX",
            data: [ [ 1528, 1368, 1562 ], [ 600, 431, 484 ], [ 443, 337, 517 ], [ 17, 20, 9 ] ]
        },
        msa365: {
            name: "Williamsport - PA",
            data: [ [ 1709, 1616, 2205 ], [ 346, 334, 285 ], [ 48, 88, 116 ], [ 10, 20, 31 ] ]
        },
        msa366: {
            name: "Wilmington - DE",
            data: [ [ 12694, 11132, 14833 ], [ 4621, 3233, 3824 ], [ 620, 725, 1233 ], [ 133, 288, 450 ] ]
        },
        msa367: {
            name: "Wilmington - NC",
            data: [ [ 7205, 6073, 8340 ], [ 1233, 869, 954 ], [ 503, 668, 966 ], [ 237, 297, 361 ] ]
        },
        msa368: {
            name: "Winchester - VA, WV",
            data: [ [ 2203, 1958, 3022 ], [ 744, 519, 659 ], [ 200, 261, 420 ], [ 92, 131, 143 ] ]
        },
        msa369: {
            name: "Winston, Salem - NC",
            data: [ [ 7852, 7362, 8577 ], [ 2182, 1675, 1800 ], [ 437, 549, 718 ], [ 144, 225, 179 ] ]
        },
        msa370: {
            name: "Worcester - MA, CT",
            data: [ [ 19599, 16327, 24179 ], [ 3414, 2289, 2773 ], [ 368, 474, 730 ], [ 113, 183, 313 ] ]
        },
        msa371: {
            name: "Yakima - WA",
            data: [ [ 2762, 2722, 3605 ], [ 1176, 763, 894 ], [ 186, 203, 351 ], [ 60, 125, 126 ] ]
        },
        msa372: {
            name: "York, Hanover - PA",
            data: [ [ 8262, 7029, 9042 ], [ 3053, 1944, 2349 ], [ 520, 582, 895 ], [ 200, 418, 469 ] ]
        },
        msa373: {
            name: "Youngstown, Warren, Boardman - OH, PA",
            data: [ [ 7324, 6308, 8046 ], [ 1775, 1432, 1533 ], [ 198, 263, 397 ], [ 58, 87, 93 ] ]
        },
        msa374: {
            name: "Yuba City - CA",
            data: [ [ 1384, 1194, 2457 ], [ 975, 756, 964 ], [ 393, 453, 637 ], [ 50, 103, 94 ] ]
        },
        msa375: {
            name: "Yuma - AZ",
            data: [ [ 1296, 1013, 1908 ], [ 971, 735, 949 ], [ 482, 470, 733 ], [ 94, 141, 195 ] ]
        }
    };
    var $conventional_checkbox = $("#conventional_checkbox");
    $conventional_checkbox.click(function() {
        var series = originationsByTypeChart.series[0];
        if (series.visible) {
            series.hide();
            $conventional_checkbox.removeAttr("checked");
        } else {
            series.show();
            $conventional_checkbox.attr("checked");
        }
    });
    var $fha_checkbox = $("#fha_checkbox");
    $fha_checkbox.click(function() {
        var series = originationsByTypeChart.series[1];
        if (series.visible) {
            series.hide();
            $fha_checkbox.removeAttr("checked");
        } else {
            series.show();
            $fha_checkbox.attr("checked");
        }
    });
    var $va_checkbox = $("#va_checkbox");
    $va_checkbox.click(function() {
        var series = originationsByTypeChart.series[2];
        if (series.visible) {
            series.hide();
            $va_checkbox.removeAttr("checked");
        } else {
            series.show();
            $va_checkbox.attr("checked");
        }
    });
    var $rhs_checkbox = $("#rhs_checkbox");
    $rhs_checkbox.click(function() {
        var series = originationsByTypeChart.series[3];
        if (series.visible) {
            series.hide();
            $rhs_checkbox.removeAttr("checked");
        } else {
            series.show();
            $rhs_checkbox.attr("checked");
        }
    });
    var $msa = $("#hmda_chart_2_msa");
    $msa.change(function() {
        var msaID = $msa.val();
        var msaName = chart2DataObj[msaID].name.replace("&apos;", "").toUpperCase();
        originationsByTypeChart.setTitle({
            text: msaName
        });
        for (var i = 0; i < 4; i++) {
            originationsByTypeChart.series[i].setData(chart2DataObj[msaID].data[i]);
        }
    });
});
