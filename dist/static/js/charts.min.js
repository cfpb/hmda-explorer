/*!                                      
            /$$$$$$          /$$        
           /$$__  $$        | $$        
  /$$$$$$$| $$  \__//$$$$$$ | $$$$$$$  
 /$$_____/| $$$$   /$$__  $$| $$__  $$  
| $$      | $$_/  | $$  \ $$| $$  \ $$
| $$      | $$    | $$  | $$| $$  | $$  
|  $$$$$$$| $$    | $$$$$$$/| $$$$$$$/  
 \_______/|__/    | $$____/ |_______/  
                  | $$                  
                  | $$                  
                  |__/                  

* public-data-platform-static - v0.12.1 - 2013-09-02
* http://consumerfinance.gov
* Copyright (c) 2013 Consumer Financial Protection Bureau; Licensed Public, Domain */

 /* ===========================================================
 * bootstrap-tooltip.js v2.3.2
 * http://twitter.github.com/bootstrap/javascript.html#tooltips
 * Inspired by the original jQuery.tipsy by Jason Frame
 * ===========================================================
 * Copyright 2012 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================== */

/*!
 * jQuery JavaScript Library v1.10.2
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2013 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2013-07-03T13:48Z
 */

/**
 * @license
 * Lo-Dash 1.3.1 <http://lodash.com/>
 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.4.4 <http://underscorejs.org/>
 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.
 * Available under MIT license <http://lodash.com/license>
 */

/**
Copyright (c) Nicolas Gallagher and Jonathan Neal

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


Copyright (c) 2012-2013 Kit Cambridge.
http://kitcambridge.be/

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

Chosen
- by Patrick Filler for [Harvest](http://getharvest.com)
- Copyright (c) 2011-2013 by Harvest

Available for use under the [MIT License](http://en.wikipedia.org/wiki/MIT_License)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

 */(function() {
    var UNDEFINED, doc = document, win = window, math = Math, mathRound = math.round, mathFloor = math.floor, mathCeil = math.ceil, mathMax = math.max, mathMin = math.min, mathAbs = math.abs, mathCos = math.cos, mathSin = math.sin, mathPI = math.PI, deg2rad = mathPI * 2 / 360, userAgent = navigator.userAgent, isOpera = win.opera, isIE = /msie/i.test(userAgent) && !isOpera, docMode8 = doc.documentMode === 8, isWebKit = /AppleWebKit/.test(userAgent), isFirefox = /Firefox/.test(userAgent), isTouchDevice = /(Mobile|Android|Windows Phone)/.test(userAgent), SVG_NS = "http://www.w3.org/2000/svg", hasSVG = !!doc.createElementNS && !!doc.createElementNS(SVG_NS, "svg").createSVGRect, hasBidiBug = isFirefox && parseInt(userAgent.split("Firefox/")[1], 10) < 4, useCanVG = !hasSVG && !isIE && !!doc.createElement("canvas").getContext, Renderer, hasTouch = doc.documentElement.ontouchstart !== UNDEFINED, symbolSizes = {}, idCounter = 0, garbageBin, defaultOptions, dateFormat, globalAnimation, pathAnim, timeUnits, noop = function() {}, charts = [], PRODUCT = "Highcharts", VERSION = "3.0.5", DIV = "div", ABSOLUTE = "absolute", RELATIVE = "relative", HIDDEN = "hidden", PREFIX = "highcharts-", VISIBLE = "visible", PX = "px", NONE = "none", M = "M", L = "L", TRACKER_FILL = "rgba(192,192,192," + (hasSVG ? 1e-4 : .002) + ")", NORMAL_STATE = "", HOVER_STATE = "hover", SELECT_STATE = "select", MILLISECOND = "millisecond", SECOND = "second", MINUTE = "minute", HOUR = "hour", DAY = "day", WEEK = "week", MONTH = "month", YEAR = "year", LINEAR_GRADIENT = "linearGradient", STOPS = "stops", STROKE_WIDTH = "stroke-width", makeTime, getMinutes, getHours, getDay, getDate, getMonth, getFullYear, setMinutes, setHours, setDate, setMonth, setFullYear, seriesTypes = {};
    win.Highcharts = win.Highcharts ? error(16, true) : {};
    function extend(a, b) {
        var n;
        if (!a) {
            a = {};
        }
        for (n in b) {
            a[n] = b[n];
        }
        return a;
    }
    function merge() {
        var i, len = arguments.length, ret = {}, doCopy = function(copy, original) {
            var value, key;
            if (typeof copy !== "object") {
                copy = {};
            }
            for (key in original) {
                if (original.hasOwnProperty(key)) {
                    value = original[key];
                    if (value && typeof value === "object" && Object.prototype.toString.call(value) !== "[object Array]" && typeof value.nodeType !== "number") {
                        copy[key] = doCopy(copy[key] || {}, value);
                    } else {
                        copy[key] = original[key];
                    }
                }
            }
            return copy;
        };
        for (i = 0; i < len; i++) {
            ret = doCopy(ret, arguments[i]);
        }
        return ret;
    }
    function hash() {
        var i = 0, args = arguments, length = args.length, obj = {};
        for (;i < length; i++) {
            obj[args[i++]] = args[i];
        }
        return obj;
    }
    function pInt(s, mag) {
        return parseInt(s, mag || 10);
    }
    function isString(s) {
        return typeof s === "string";
    }
    function isObject(obj) {
        return typeof obj === "object";
    }
    function isArray(obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
    }
    function isNumber(n) {
        return typeof n === "number";
    }
    function log2lin(num) {
        return math.log(num) / math.LN10;
    }
    function lin2log(num) {
        return math.pow(10, num);
    }
    function erase(arr, item) {
        var i = arr.length;
        while (i--) {
            if (arr[i] === item) {
                arr.splice(i, 1);
                break;
            }
        }
    }
    function defined(obj) {
        return obj !== UNDEFINED && obj !== null;
    }
    function attr(elem, prop, value) {
        var key, setAttribute = "setAttribute", ret;
        if (isString(prop)) {
            if (defined(value)) {
                elem[setAttribute](prop, value);
            } else if (elem && elem.getAttribute) {
                ret = elem.getAttribute(prop);
            }
        } else if (defined(prop) && isObject(prop)) {
            for (key in prop) {
                elem[setAttribute](key, prop[key]);
            }
        }
        return ret;
    }
    function splat(obj) {
        return isArray(obj) ? obj : [ obj ];
    }
    function pick() {
        var args = arguments, i, arg, length = args.length;
        for (i = 0; i < length; i++) {
            arg = args[i];
            if (typeof arg !== "undefined" && arg !== null) {
                return arg;
            }
        }
    }
    function css(el, styles) {
        if (isIE) {
            if (styles && styles.opacity !== UNDEFINED) {
                styles.filter = "alpha(opacity=" + styles.opacity * 100 + ")";
            }
        }
        extend(el.style, styles);
    }
    function createElement(tag, attribs, styles, parent, nopad) {
        var el = doc.createElement(tag);
        if (attribs) {
            extend(el, attribs);
        }
        if (nopad) {
            css(el, {
                padding: 0,
                border: NONE,
                margin: 0
            });
        }
        if (styles) {
            css(el, styles);
        }
        if (parent) {
            parent.appendChild(el);
        }
        return el;
    }
    function extendClass(parent, members) {
        var object = function() {};
        object.prototype = new parent();
        extend(object.prototype, members);
        return object;
    }
    function numberFormat(number, decimals, decPoint, thousandsSep) {
        var lang = defaultOptions.lang, n = +number || 0, c = decimals === -1 ? (n.toString().split(".")[1] || "").length : isNaN(decimals = mathAbs(decimals)) ? 2 : decimals, d = decPoint === undefined ? lang.decimalPoint : decPoint, t = thousandsSep === undefined ? lang.thousandsSep : thousandsSep, s = n < 0 ? "-" : "", i = String(pInt(n = mathAbs(n).toFixed(c))), j = i.length > 3 ? i.length % 3 : 0;
        return s + (j ? i.substr(0, j) + t : "") + i.substr(j).replace(/(\d{3})(?=\d)/g, "$1" + t) + (c ? d + mathAbs(n - i).toFixed(c).slice(2) : "");
    }
    function pad(number, length) {
        return new Array((length || 2) + 1 - String(number).length).join(0) + number;
    }
    function wrap(obj, method, func) {
        var proceed = obj[method];
        obj[method] = function() {
            var args = Array.prototype.slice.call(arguments);
            args.unshift(proceed);
            return func.apply(this, args);
        };
    }
    dateFormat = function(format, timestamp, capitalize) {
        if (!defined(timestamp) || isNaN(timestamp)) {
            return "Invalid date";
        }
        format = pick(format, "%Y-%m-%d %H:%M:%S");
        var date = new Date(timestamp), key, hours = date[getHours](), day = date[getDay](), dayOfMonth = date[getDate](), month = date[getMonth](), fullYear = date[getFullYear](), lang = defaultOptions.lang, langWeekdays = lang.weekdays, replacements = extend({
            a: langWeekdays[day].substr(0, 3),
            A: langWeekdays[day],
            d: pad(dayOfMonth),
            e: dayOfMonth,
            b: lang.shortMonths[month],
            B: lang.months[month],
            m: pad(month + 1),
            y: fullYear.toString().substr(2, 2),
            Y: fullYear,
            H: pad(hours),
            I: pad(hours % 12 || 12),
            l: hours % 12 || 12,
            M: pad(date[getMinutes]()),
            p: hours < 12 ? "AM" : "PM",
            P: hours < 12 ? "am" : "pm",
            S: pad(date.getSeconds()),
            L: pad(mathRound(timestamp % 1e3), 3)
        }, Highcharts.dateFormats);
        for (key in replacements) {
            while (format.indexOf("%" + key) !== -1) {
                format = format.replace("%" + key, typeof replacements[key] === "function" ? replacements[key](timestamp) : replacements[key]);
            }
        }
        return capitalize ? format.substr(0, 1).toUpperCase() + format.substr(1) : format;
    };
    function formatSingle(format, val) {
        var floatRegex = /f$/, decRegex = /\.([0-9])/, lang = defaultOptions.lang, decimals;
        if (floatRegex.test(format)) {
            decimals = format.match(decRegex);
            decimals = decimals ? decimals[1] : -1;
            val = numberFormat(val, decimals, lang.decimalPoint, format.indexOf(",") > -1 ? lang.thousandsSep : "");
        } else {
            val = dateFormat(format, val);
        }
        return val;
    }
    function format(str, ctx) {
        var splitter = "{", isInside = false, segment, valueAndFormat, path, i, len, ret = [], val, index;
        while ((index = str.indexOf(splitter)) !== -1) {
            segment = str.slice(0, index);
            if (isInside) {
                valueAndFormat = segment.split(":");
                path = valueAndFormat.shift().split(".");
                len = path.length;
                val = ctx;
                for (i = 0; i < len; i++) {
                    val = val[path[i]];
                }
                if (valueAndFormat.length) {
                    val = formatSingle(valueAndFormat.join(":"), val);
                }
                ret.push(val);
            } else {
                ret.push(segment);
            }
            str = str.slice(index + 1);
            isInside = !isInside;
            splitter = isInside ? "}" : "{";
        }
        ret.push(str);
        return ret.join("");
    }
    function getMagnitude(num) {
        return math.pow(10, mathFloor(math.log(num) / math.LN10));
    }
    function normalizeTickInterval(interval, multiples, magnitude, options) {
        var normalized, i;
        magnitude = pick(magnitude, 1);
        normalized = interval / magnitude;
        if (!multiples) {
            multiples = [ 1, 2, 2.5, 5, 10 ];
            if (options && options.allowDecimals === false) {
                if (magnitude === 1) {
                    multiples = [ 1, 2, 5, 10 ];
                } else if (magnitude <= .1) {
                    multiples = [ 1 / magnitude ];
                }
            }
        }
        for (i = 0; i < multiples.length; i++) {
            interval = multiples[i];
            if (normalized <= (multiples[i] + (multiples[i + 1] || multiples[i])) / 2) {
                break;
            }
        }
        interval *= magnitude;
        return interval;
    }
    function normalizeTimeTickInterval(tickInterval, unitsOption) {
        var units = unitsOption || [ [ MILLISECOND, [ 1, 2, 5, 10, 20, 25, 50, 100, 200, 500 ] ], [ SECOND, [ 1, 2, 5, 10, 15, 30 ] ], [ MINUTE, [ 1, 2, 5, 10, 15, 30 ] ], [ HOUR, [ 1, 2, 3, 4, 6, 8, 12 ] ], [ DAY, [ 1, 2 ] ], [ WEEK, [ 1, 2 ] ], [ MONTH, [ 1, 2, 3, 4, 6 ] ], [ YEAR, null ] ], unit = units[units.length - 1], interval = timeUnits[unit[0]], multiples = unit[1], count, i;
        for (i = 0; i < units.length; i++) {
            unit = units[i];
            interval = timeUnits[unit[0]];
            multiples = unit[1];
            if (units[i + 1]) {
                var lessThan = (interval * multiples[multiples.length - 1] + timeUnits[units[i + 1][0]]) / 2;
                if (tickInterval <= lessThan) {
                    break;
                }
            }
        }
        if (interval === timeUnits[YEAR] && tickInterval < 5 * interval) {
            multiples = [ 1, 2, 5 ];
        }
        if (interval === timeUnits[YEAR] && tickInterval < 5 * interval) {
            multiples = [ 1, 2, 5 ];
        }
        count = normalizeTickInterval(tickInterval / interval, multiples, unit[0] === YEAR ? getMagnitude(tickInterval / interval) : 1);
        return {
            unitRange: interval,
            count: count,
            unitName: unit[0]
        };
    }
    function getTimeTicks(normalizedInterval, min, max, startOfWeek) {
        var tickPositions = [], i, higherRanks = {}, useUTC = defaultOptions.global.useUTC, minYear, minDate = new Date(min), interval = normalizedInterval.unitRange, count = normalizedInterval.count;
        if (defined(min)) {
            if (interval >= timeUnits[SECOND]) {
                minDate.setMilliseconds(0);
                minDate.setSeconds(interval >= timeUnits[MINUTE] ? 0 : count * mathFloor(minDate.getSeconds() / count));
            }
            if (interval >= timeUnits[MINUTE]) {
                minDate[setMinutes](interval >= timeUnits[HOUR] ? 0 : count * mathFloor(minDate[getMinutes]() / count));
            }
            if (interval >= timeUnits[HOUR]) {
                minDate[setHours](interval >= timeUnits[DAY] ? 0 : count * mathFloor(minDate[getHours]() / count));
            }
            if (interval >= timeUnits[DAY]) {
                minDate[setDate](interval >= timeUnits[MONTH] ? 1 : count * mathFloor(minDate[getDate]() / count));
            }
            if (interval >= timeUnits[MONTH]) {
                minDate[setMonth](interval >= timeUnits[YEAR] ? 0 : count * mathFloor(minDate[getMonth]() / count));
                minYear = minDate[getFullYear]();
            }
            if (interval >= timeUnits[YEAR]) {
                minYear -= minYear % count;
                minDate[setFullYear](minYear);
            }
            if (interval === timeUnits[WEEK]) {
                minDate[setDate](minDate[getDate]() - minDate[getDay]() + pick(startOfWeek, 1));
            }
            i = 1;
            minYear = minDate[getFullYear]();
            var time = minDate.getTime(), minMonth = minDate[getMonth](), minDateDate = minDate[getDate](), timezoneOffset = useUTC ? 0 : (24 * 3600 * 1e3 + minDate.getTimezoneOffset() * 60 * 1e3) % (24 * 3600 * 1e3);
            while (time < max) {
                tickPositions.push(time);
                if (interval === timeUnits[YEAR]) {
                    time = makeTime(minYear + i * count, 0);
                } else if (interval === timeUnits[MONTH]) {
                    time = makeTime(minYear, minMonth + i * count);
                } else if (!useUTC && (interval === timeUnits[DAY] || interval === timeUnits[WEEK])) {
                    time = makeTime(minYear, minMonth, minDateDate + i * count * (interval === timeUnits[DAY] ? 1 : 7));
                } else {
                    time += interval * count;
                }
                i++;
            }
            tickPositions.push(time);
            each(grep(tickPositions, function(time) {
                return interval <= timeUnits[HOUR] && time % timeUnits[DAY] === timezoneOffset;
            }), function(time) {
                higherRanks[time] = DAY;
            });
        }
        tickPositions.info = extend(normalizedInterval, {
            higherRanks: higherRanks,
            totalRange: interval * count
        });
        return tickPositions;
    }
    function ChartCounters() {
        this.color = 0;
        this.symbol = 0;
    }
    ChartCounters.prototype = {
        wrapColor: function(length) {
            if (this.color >= length) {
                this.color = 0;
            }
        },
        wrapSymbol: function(length) {
            if (this.symbol >= length) {
                this.symbol = 0;
            }
        }
    };
    function stableSort(arr, sortFunction) {
        var length = arr.length, sortValue, i;
        for (i = 0; i < length; i++) {
            arr[i].ss_i = i;
        }
        arr.sort(function(a, b) {
            sortValue = sortFunction(a, b);
            return sortValue === 0 ? a.ss_i - b.ss_i : sortValue;
        });
        for (i = 0; i < length; i++) {
            delete arr[i].ss_i;
        }
    }
    function arrayMin(data) {
        var i = data.length, min = data[0];
        while (i--) {
            if (data[i] < min) {
                min = data[i];
            }
        }
        return min;
    }
    function arrayMax(data) {
        var i = data.length, max = data[0];
        while (i--) {
            if (data[i] > max) {
                max = data[i];
            }
        }
        return max;
    }
    function destroyObjectProperties(obj, except) {
        var n;
        for (n in obj) {
            if (obj[n] && obj[n] !== except && obj[n].destroy) {
                obj[n].destroy();
            }
            delete obj[n];
        }
    }
    function discardElement(element) {
        if (!garbageBin) {
            garbageBin = createElement(DIV);
        }
        if (element) {
            garbageBin.appendChild(element);
        }
        garbageBin.innerHTML = "";
    }
    function error(code, stop) {
        var msg = "Highcharts error #" + code + ": www.highcharts.com/errors/" + code;
        if (stop) {
            throw msg;
        } else if (win.console) {
            console.log(msg);
        }
    }
    function correctFloat(num) {
        return parseFloat(num.toPrecision(14));
    }
    function setAnimation(animation, chart) {
        globalAnimation = pick(animation, chart.animation);
    }
    timeUnits = hash(MILLISECOND, 1, SECOND, 1e3, MINUTE, 6e4, HOUR, 36e5, DAY, 24 * 36e5, WEEK, 7 * 24 * 36e5, MONTH, 31 * 24 * 36e5, YEAR, 31556952e3);
    pathAnim = {
        init: function(elem, fromD, toD) {
            fromD = fromD || "";
            var shift = elem.shift, bezier = fromD.indexOf("C") > -1, numParams = bezier ? 7 : 3, endLength, slice, i, start = fromD.split(" "), end = [].concat(toD), startBaseLine, endBaseLine, sixify = function(arr) {
                i = arr.length;
                while (i--) {
                    if (arr[i] === M) {
                        arr.splice(i + 1, 0, arr[i + 1], arr[i + 2], arr[i + 1], arr[i + 2]);
                    }
                }
            };
            if (bezier) {
                sixify(start);
                sixify(end);
            }
            if (elem.isArea) {
                startBaseLine = start.splice(start.length - 6, 6);
                endBaseLine = end.splice(end.length - 6, 6);
            }
            if (shift <= end.length / numParams) {
                while (shift--) {
                    end = [].concat(end).splice(0, numParams).concat(end);
                }
            }
            elem.shift = 0;
            if (start.length) {
                endLength = end.length;
                while (start.length < endLength) {
                    slice = [].concat(start).splice(start.length - numParams, numParams);
                    if (bezier) {
                        slice[numParams - 6] = slice[numParams - 2];
                        slice[numParams - 5] = slice[numParams - 1];
                    }
                    start = start.concat(slice);
                }
            }
            if (startBaseLine) {
                start = start.concat(startBaseLine);
                end = end.concat(endBaseLine);
            }
            return [ start, end ];
        },
        step: function(start, end, pos, complete) {
            var ret = [], i = start.length, startVal;
            if (pos === 1) {
                ret = complete;
            } else if (i === end.length && pos < 1) {
                while (i--) {
                    startVal = parseFloat(start[i]);
                    ret[i] = isNaN(startVal) ? start[i] : pos * parseFloat(end[i] - startVal) + startVal;
                }
            } else {
                ret = end;
            }
            return ret;
        }
    };
    (function($) {
        win.HighchartsAdapter = win.HighchartsAdapter || $ && {
            init: function(pathAnim) {
                var Fx = $.fx, Step = Fx.step, dSetter, Tween = $.Tween, propHooks = Tween && Tween.propHooks, opacityHook = $.cssHooks.opacity;
                $.extend($.easing, {
                    easeOutQuad: function(x, t, b, c, d) {
                        return -c * (t /= d) * (t - 2) + b;
                    }
                });
                $.each([ "cur", "_default", "width", "height", "opacity" ], function(i, fn) {
                    var obj = Step, base, elem;
                    if (fn === "cur") {
                        obj = Fx.prototype;
                    } else if (fn === "_default" && Tween) {
                        obj = propHooks[fn];
                        fn = "set";
                    }
                    base = obj[fn];
                    if (base) {
                        obj[fn] = function(fx) {
                            fx = i ? fx : this;
                            elem = fx.elem;
                            return elem.attr ? elem.attr(fx.prop, fn === "cur" ? UNDEFINED : fx.now) : base.apply(this, arguments);
                        };
                    }
                });
                wrap(opacityHook, "get", function(proceed, elem, computed) {
                    return elem.attr ? elem.opacity || 0 : proceed.call(this, elem, computed);
                });
                dSetter = function(fx) {
                    var elem = fx.elem, ends;
                    if (!fx.started) {
                        ends = pathAnim.init(elem, elem.d, elem.toD);
                        fx.start = ends[0];
                        fx.end = ends[1];
                        fx.started = true;
                    }
                    elem.attr("d", pathAnim.step(fx.start, fx.end, fx.pos, elem.toD));
                };
                if (Tween) {
                    propHooks.d = {
                        set: dSetter
                    };
                } else {
                    Step.d = dSetter;
                }
                this.each = Array.prototype.forEach ? function(arr, fn) {
                    return Array.prototype.forEach.call(arr, fn);
                } : function(arr, fn) {
                    var i = 0, len = arr.length;
                    for (;i < len; i++) {
                        if (fn.call(arr[i], arr[i], i, arr) === false) {
                            return i;
                        }
                    }
                };
                $.fn.highcharts = function() {
                    var constr = "Chart", args = arguments, options, ret, chart;
                    if (isString(args[0])) {
                        constr = args[0];
                        args = Array.prototype.slice.call(args, 1);
                    }
                    options = args[0];
                    if (options !== UNDEFINED) {
                        options.chart = options.chart || {};
                        options.chart.renderTo = this[0];
                        chart = new Highcharts[constr](options, args[1]);
                        ret = this;
                    }
                    if (options === UNDEFINED) {
                        ret = charts[attr(this[0], "data-highcharts-chart")];
                    }
                    return ret;
                };
            },
            getScript: $.getScript,
            inArray: $.inArray,
            adapterRun: function(elem, method) {
                return $(elem)[method]();
            },
            grep: $.grep,
            map: function(arr, fn) {
                var results = [], i = 0, len = arr.length;
                for (;i < len; i++) {
                    results[i] = fn.call(arr[i], arr[i], i, arr);
                }
                return results;
            },
            offset: function(el) {
                return $(el).offset();
            },
            addEvent: function(el, event, fn) {
                $(el).bind(event, fn);
            },
            removeEvent: function(el, eventType, handler) {
                var func = doc.removeEventListener ? "removeEventListener" : "detachEvent";
                if (doc[func] && el && !el[func]) {
                    el[func] = function() {};
                }
                $(el).unbind(eventType, handler);
            },
            fireEvent: function(el, type, eventArguments, defaultFunction) {
                var event = $.Event(type), detachedType = "detached" + type, defaultPrevented;
                if (!isIE && eventArguments) {
                    delete eventArguments.layerX;
                    delete eventArguments.layerY;
                }
                extend(event, eventArguments);
                if (el[type]) {
                    el[detachedType] = el[type];
                    el[type] = null;
                }
                $.each([ "preventDefault", "stopPropagation" ], function(i, fn) {
                    var base = event[fn];
                    event[fn] = function() {
                        try {
                            base.call(event);
                        } catch (e) {
                            if (fn === "preventDefault") {
                                defaultPrevented = true;
                            }
                        }
                    };
                });
                $(el).trigger(event);
                if (el[detachedType]) {
                    el[type] = el[detachedType];
                    el[detachedType] = null;
                }
                if (defaultFunction && !event.isDefaultPrevented() && !defaultPrevented) {
                    defaultFunction(event);
                }
            },
            washMouseEvent: function(e) {
                var ret = e.originalEvent || e;
                if (ret.pageX === UNDEFINED) {
                    ret.pageX = e.pageX;
                    ret.pageY = e.pageY;
                }
                return ret;
            },
            animate: function(el, params, options) {
                var $el = $(el);
                if (!el.style) {
                    el.style = {};
                }
                if (params.d) {
                    el.toD = params.d;
                    params.d = 1;
                }
                $el.stop();
                if (params.opacity !== UNDEFINED && el.attr) {
                    params.opacity += "px";
                }
                $el.animate(params, options);
            },
            stop: function(el) {
                $(el).stop();
            }
        };
    })(win.jQuery);
    var globalAdapter = win.HighchartsAdapter, adapter = globalAdapter || {};
    if (globalAdapter) {
        globalAdapter.init.call(globalAdapter, pathAnim);
    }
    var adapterRun = adapter.adapterRun, getScript = adapter.getScript, inArray = adapter.inArray, each = adapter.each, grep = adapter.grep, offset = adapter.offset, map = adapter.map, addEvent = adapter.addEvent, removeEvent = adapter.removeEvent, fireEvent = adapter.fireEvent, washMouseEvent = adapter.washMouseEvent, animate = adapter.animate, stop = adapter.stop;
    var defaultLabelOptions = {
        enabled: true,
        x: 0,
        y: 15,
        style: {
            color: "#666",
            cursor: "default",
            fontSize: "11px",
            lineHeight: "14px"
        }
    };
    defaultOptions = {
        colors: [ "#2f7ed8", "#0d233a", "#8bbc21", "#910000", "#1aadce", "#492970", "#f28f43", "#77a1e5", "#c42525", "#a6c96a" ],
        symbols: [ "circle", "diamond", "square", "triangle", "triangle-down" ],
        lang: {
            loading: "Loading...",
            months: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
            shortMonths: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ],
            weekdays: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
            decimalPoint: ".",
            numericSymbols: [ "k", "M", "G", "T", "P", "E" ],
            resetZoom: "Reset zoom",
            resetZoomTitle: "Reset zoom level 1:1",
            thousandsSep: ","
        },
        global: {
            useUTC: true,
            canvasToolsURL: "http://code.highcharts.com/3.0.5/modules/canvas-tools.js",
            VMLRadialGradientURL: "http://code.highcharts.com/3.0.5/gfx/vml-radial-gradient.png"
        },
        chart: {
            borderColor: "#4572A7",
            borderRadius: 5,
            defaultSeriesType: "line",
            ignoreHiddenSeries: true,
            spacingTop: 10,
            spacingRight: 10,
            spacingBottom: 15,
            spacingLeft: 10,
            style: {
                fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Verdana, Arial, Helvetica, sans-serif',
                fontSize: "12px"
            },
            backgroundColor: "#FFFFFF",
            plotBorderColor: "#C0C0C0",
            resetZoomButton: {
                theme: {
                    zIndex: 20
                },
                position: {
                    align: "right",
                    x: -10,
                    y: 10
                }
            }
        },
        title: {
            text: "Chart title",
            align: "center",
            margin: 15,
            style: {
                color: "#274b6d",
                fontSize: "16px"
            }
        },
        subtitle: {
            text: "",
            align: "center",
            style: {
                color: "#4d759e"
            }
        },
        plotOptions: {
            line: {
                allowPointSelect: false,
                showCheckbox: false,
                animation: {
                    duration: 1e3
                },
                events: {},
                lineWidth: 2,
                marker: {
                    enabled: true,
                    lineWidth: 0,
                    radius: 4,
                    lineColor: "#FFFFFF",
                    states: {
                        hover: {
                            enabled: true
                        },
                        select: {
                            fillColor: "#FFFFFF",
                            lineColor: "#000000",
                            lineWidth: 2
                        }
                    }
                },
                point: {
                    events: {}
                },
                dataLabels: merge(defaultLabelOptions, {
                    align: "center",
                    enabled: false,
                    formatter: function() {
                        return this.y === null ? "" : numberFormat(this.y, -1);
                    },
                    verticalAlign: "bottom",
                    y: 0
                }),
                cropThreshold: 300,
                pointRange: 0,
                showInLegend: true,
                states: {
                    hover: {
                        marker: {}
                    },
                    select: {
                        marker: {}
                    }
                },
                stickyTracking: true
            }
        },
        labels: {
            style: {
                position: ABSOLUTE,
                color: "#3E576F"
            }
        },
        legend: {
            enabled: true,
            align: "center",
            layout: "horizontal",
            labelFormatter: function() {
                return this.name;
            },
            borderWidth: 1,
            borderColor: "#909090",
            borderRadius: 5,
            navigation: {
                activeColor: "#274b6d",
                inactiveColor: "#CCC"
            },
            shadow: false,
            itemStyle: {
                cursor: "pointer",
                color: "#274b6d",
                fontSize: "12px"
            },
            itemHoverStyle: {
                color: "#000"
            },
            itemHiddenStyle: {
                color: "#CCC"
            },
            itemCheckboxStyle: {
                position: ABSOLUTE,
                width: "13px",
                height: "13px"
            },
            symbolWidth: 16,
            symbolPadding: 5,
            verticalAlign: "bottom",
            x: 0,
            y: 0,
            title: {
                style: {
                    fontWeight: "bold"
                }
            }
        },
        loading: {
            labelStyle: {
                fontWeight: "bold",
                position: RELATIVE,
                top: "1em"
            },
            style: {
                position: ABSOLUTE,
                backgroundColor: "white",
                opacity: .5,
                textAlign: "center"
            }
        },
        tooltip: {
            enabled: true,
            animation: hasSVG,
            backgroundColor: "rgba(255, 255, 255, .85)",
            borderWidth: 1,
            borderRadius: 3,
            dateTimeLabelFormats: {
                millisecond: "%A, %b %e, %H:%M:%S.%L",
                second: "%A, %b %e, %H:%M:%S",
                minute: "%A, %b %e, %H:%M",
                hour: "%A, %b %e, %H:%M",
                day: "%A, %b %e, %Y",
                week: "Week from %A, %b %e, %Y",
                month: "%B %Y",
                year: "%Y"
            },
            headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>',
            pointFormat: '<span style="color:{series.color}">{series.name}</span>: <b>{point.y}</b><br/>',
            shadow: true,
            snap: isTouchDevice ? 25 : 10,
            style: {
                color: "#333333",
                cursor: "default",
                fontSize: "12px",
                padding: "8px",
                whiteSpace: "nowrap"
            }
        },
        credits: {
            enabled: true,
            text: "Highcharts.com",
            href: "http://www.highcharts.com",
            position: {
                align: "right",
                x: -10,
                verticalAlign: "bottom",
                y: -5
            },
            style: {
                cursor: "pointer",
                color: "#909090",
                fontSize: "9px"
            }
        }
    };
    var defaultPlotOptions = defaultOptions.plotOptions, defaultSeriesOptions = defaultPlotOptions.line;
    setTimeMethods();
    function setTimeMethods() {
        var useUTC = defaultOptions.global.useUTC, GET = useUTC ? "getUTC" : "get", SET = useUTC ? "setUTC" : "set";
        makeTime = useUTC ? Date.UTC : function(year, month, date, hours, minutes, seconds) {
            return new Date(year, month, pick(date, 1), pick(hours, 0), pick(minutes, 0), pick(seconds, 0)).getTime();
        };
        getMinutes = GET + "Minutes";
        getHours = GET + "Hours";
        getDay = GET + "Day";
        getDate = GET + "Date";
        getMonth = GET + "Month";
        getFullYear = GET + "FullYear";
        setMinutes = SET + "Minutes";
        setHours = SET + "Hours";
        setDate = SET + "Date";
        setMonth = SET + "Month";
        setFullYear = SET + "FullYear";
    }
    function setOptions(options) {
        defaultOptions = merge(defaultOptions, options);
        setTimeMethods();
        return defaultOptions;
    }
    function getOptions() {
        return defaultOptions;
    }
    var Color = function(input) {
        var rgba = [], result, stops;
        function init(input) {
            if (input && input.stops) {
                stops = map(input.stops, function(stop) {
                    return Color(stop[1]);
                });
            } else {
                result = /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/.exec(input);
                if (result) {
                    rgba = [ pInt(result[1]), pInt(result[2]), pInt(result[3]), parseFloat(result[4], 10) ];
                } else {
                    result = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(input);
                    if (result) {
                        rgba = [ pInt(result[1], 16), pInt(result[2], 16), pInt(result[3], 16), 1 ];
                    } else {
                        result = /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/.exec(input);
                        if (result) {
                            rgba = [ pInt(result[1]), pInt(result[2]), pInt(result[3]), 1 ];
                        }
                    }
                }
            }
        }
        function get(format) {
            var ret;
            if (stops) {
                ret = merge(input);
                ret.stops = [].concat(ret.stops);
                each(stops, function(stop, i) {
                    ret.stops[i] = [ ret.stops[i][0], stop.get(format) ];
                });
            } else if (rgba && !isNaN(rgba[0])) {
                if (format === "rgb") {
                    ret = "rgb(" + rgba[0] + "," + rgba[1] + "," + rgba[2] + ")";
                } else if (format === "a") {
                    ret = rgba[3];
                } else {
                    ret = "rgba(" + rgba.join(",") + ")";
                }
            } else {
                ret = input;
            }
            return ret;
        }
        function brighten(alpha) {
            if (stops) {
                each(stops, function(stop) {
                    stop.brighten(alpha);
                });
            } else if (isNumber(alpha) && alpha !== 0) {
                var i;
                for (i = 0; i < 3; i++) {
                    rgba[i] += pInt(alpha * 255);
                    if (rgba[i] < 0) {
                        rgba[i] = 0;
                    }
                    if (rgba[i] > 255) {
                        rgba[i] = 255;
                    }
                }
            }
            return this;
        }
        function setOpacity(alpha) {
            rgba[3] = alpha;
            return this;
        }
        init(input);
        return {
            get: get,
            brighten: brighten,
            rgba: rgba,
            setOpacity: setOpacity
        };
    };
    function SVGElement() {}
    SVGElement.prototype = {
        init: function(renderer, nodeName) {
            var wrapper = this;
            wrapper.element = nodeName === "span" ? createElement(nodeName) : doc.createElementNS(SVG_NS, nodeName);
            wrapper.renderer = renderer;
            wrapper.attrSetters = {};
        },
        opacity: 1,
        animate: function(params, options, complete) {
            var animOptions = pick(options, globalAnimation, true);
            stop(this);
            if (animOptions) {
                animOptions = merge(animOptions);
                if (complete) {
                    animOptions.complete = complete;
                }
                animate(this, params, animOptions);
            } else {
                this.attr(params);
                if (complete) {
                    complete();
                }
            }
        },
        attr: function(hash, val) {
            var wrapper = this, key, value, result, i, child, element = wrapper.element, nodeName = element.nodeName.toLowerCase(), renderer = wrapper.renderer, skipAttr, titleNode, attrSetters = wrapper.attrSetters, shadows = wrapper.shadows, hasSetSymbolSize, doTransform, ret = wrapper;
            if (isString(hash) && defined(val)) {
                key = hash;
                hash = {};
                hash[key] = val;
            }
            if (isString(hash)) {
                key = hash;
                if (nodeName === "circle") {
                    key = {
                        x: "cx",
                        y: "cy"
                    }[key] || key;
                } else if (key === "strokeWidth") {
                    key = "stroke-width";
                }
                ret = attr(element, key) || wrapper[key] || 0;
                if (key !== "d" && key !== "visibility") {
                    ret = parseFloat(ret);
                }
            } else {
                for (key in hash) {
                    skipAttr = false;
                    value = hash[key];
                    result = attrSetters[key] && attrSetters[key].call(wrapper, value, key);
                    if (result !== false) {
                        if (result !== UNDEFINED) {
                            value = result;
                        }
                        if (key === "d") {
                            if (value && value.join) {
                                value = value.join(" ");
                            }
                            if (/(NaN| {2}|^$)/.test(value)) {
                                value = "M 0 0";
                            }
                        } else if (key === "x" && nodeName === "text") {
                            for (i = 0; i < element.childNodes.length; i++) {
                                child = element.childNodes[i];
                                if (attr(child, "x") === attr(element, "x")) {
                                    attr(child, "x", value);
                                }
                            }
                        } else if (wrapper.rotation && (key === "x" || key === "y")) {
                            doTransform = true;
                        } else if (key === "fill") {
                            value = renderer.color(value, element, key);
                        } else if (nodeName === "circle" && (key === "x" || key === "y")) {
                            key = {
                                x: "cx",
                                y: "cy"
                            }[key] || key;
                        } else if (nodeName === "rect" && key === "r") {
                            attr(element, {
                                rx: value,
                                ry: value
                            });
                            skipAttr = true;
                        } else if (key === "translateX" || key === "translateY" || key === "rotation" || key === "verticalAlign" || key === "scaleX" || key === "scaleY") {
                            doTransform = true;
                            skipAttr = true;
                        } else if (key === "stroke") {
                            value = renderer.color(value, element, key);
                        } else if (key === "dashstyle") {
                            key = "stroke-dasharray";
                            value = value && value.toLowerCase();
                            if (value === "solid") {
                                value = NONE;
                            } else if (value) {
                                value = value.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(",");
                                i = value.length;
                                while (i--) {
                                    value[i] = pInt(value[i]) * pick(hash["stroke-width"], wrapper["stroke-width"]);
                                }
                                value = value.join(",");
                            }
                        } else if (key === "width") {
                            value = pInt(value);
                        } else if (key === "align") {
                            key = "text-anchor";
                            value = {
                                left: "start",
                                center: "middle",
                                right: "end"
                            }[value];
                        } else if (key === "title") {
                            titleNode = element.getElementsByTagName("title")[0];
                            if (!titleNode) {
                                titleNode = doc.createElementNS(SVG_NS, "title");
                                element.appendChild(titleNode);
                            }
                            titleNode.textContent = value;
                        }
                        if (key === "strokeWidth") {
                            key = "stroke-width";
                        }
                        if (key === "stroke-width" || key === "stroke") {
                            wrapper[key] = value;
                            if (wrapper.stroke && wrapper["stroke-width"]) {
                                attr(element, "stroke", wrapper.stroke);
                                attr(element, "stroke-width", wrapper["stroke-width"]);
                                wrapper.hasStroke = true;
                            } else if (key === "stroke-width" && value === 0 && wrapper.hasStroke) {
                                element.removeAttribute("stroke");
                                wrapper.hasStroke = false;
                            }
                            skipAttr = true;
                        }
                        if (wrapper.symbolName && /^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)/.test(key)) {
                            if (!hasSetSymbolSize) {
                                wrapper.symbolAttr(hash);
                                hasSetSymbolSize = true;
                            }
                            skipAttr = true;
                        }
                        if (shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(key)) {
                            i = shadows.length;
                            while (i--) {
                                attr(shadows[i], key, key === "height" ? mathMax(value - (shadows[i].cutHeight || 0), 0) : value);
                            }
                        }
                        if ((key === "width" || key === "height") && nodeName === "rect" && value < 0) {
                            value = 0;
                        }
                        wrapper[key] = value;
                        if (key === "text") {
                            if (value !== wrapper.textStr) {
                                delete wrapper.bBox;
                            }
                            wrapper.textStr = value;
                            if (wrapper.added) {
                                renderer.buildText(wrapper);
                            }
                        } else if (!skipAttr) {
                            attr(element, key, value);
                        }
                    }
                }
                if (doTransform) {
                    wrapper.updateTransform();
                }
            }
            return ret;
        },
        addClass: function(className) {
            var element = this.element, currentClassName = attr(element, "class") || "";
            if (currentClassName.indexOf(className) === -1) {
                attr(element, "class", currentClassName + " " + className);
            }
            return this;
        },
        symbolAttr: function(hash) {
            var wrapper = this;
            each([ "x", "y", "r", "start", "end", "width", "height", "innerR", "anchorX", "anchorY" ], function(key) {
                wrapper[key] = pick(hash[key], wrapper[key]);
            });
            wrapper.attr({
                d: wrapper.renderer.symbols[wrapper.symbolName](wrapper.x, wrapper.y, wrapper.width, wrapper.height, wrapper)
            });
        },
        clip: function(clipRect) {
            return this.attr("clip-path", clipRect ? "url(" + this.renderer.url + "#" + clipRect.id + ")" : NONE);
        },
        crisp: function(strokeWidth, x, y, width, height) {
            var wrapper = this, key, attribs = {}, values = {}, normalizer;
            strokeWidth = strokeWidth || wrapper.strokeWidth || wrapper.attr && wrapper.attr("stroke-width") || 0;
            normalizer = mathRound(strokeWidth) % 2 / 2;
            values.x = mathFloor(x || wrapper.x || 0) + normalizer;
            values.y = mathFloor(y || wrapper.y || 0) + normalizer;
            values.width = mathFloor((width || wrapper.width || 0) - 2 * normalizer);
            values.height = mathFloor((height || wrapper.height || 0) - 2 * normalizer);
            values.strokeWidth = strokeWidth;
            for (key in values) {
                if (wrapper[key] !== values[key]) {
                    wrapper[key] = attribs[key] = values[key];
                }
            }
            return attribs;
        },
        css: function(styles) {
            var elemWrapper = this, elem = elemWrapper.element, textWidth = styles && styles.width && elem.nodeName.toLowerCase() === "text", n, serializedCss = "", hyphenate = function(a, b) {
                return "-" + b.toLowerCase();
            };
            if (styles && styles.color) {
                styles.fill = styles.color;
            }
            styles = extend(elemWrapper.styles, styles);
            elemWrapper.styles = styles;
            if (useCanVG && textWidth) {
                delete styles.width;
            }
            if (isIE && !hasSVG) {
                if (textWidth) {
                    delete styles.width;
                }
                css(elemWrapper.element, styles);
            } else {
                for (n in styles) {
                    serializedCss += n.replace(/([A-Z])/g, hyphenate) + ":" + styles[n] + ";";
                }
                attr(elem, "style", serializedCss);
            }
            if (textWidth && elemWrapper.added) {
                elemWrapper.renderer.buildText(elemWrapper);
            }
            return elemWrapper;
        },
        on: function(eventType, handler) {
            var element = this.element;
            if (hasTouch && eventType === "click") {
                element.ontouchstart = function(e) {
                    e.preventDefault();
                    handler.call(element, e);
                };
            }
            element["on" + eventType] = handler;
            return this;
        },
        setRadialReference: function(coordinates) {
            this.element.radialReference = coordinates;
            return this;
        },
        translate: function(x, y) {
            return this.attr({
                translateX: x,
                translateY: y
            });
        },
        invert: function() {
            var wrapper = this;
            wrapper.inverted = true;
            wrapper.updateTransform();
            return wrapper;
        },
        htmlCss: function(styles) {
            var wrapper = this, element = wrapper.element, textWidth = styles && element.tagName === "SPAN" && styles.width;
            if (textWidth) {
                delete styles.width;
                wrapper.textWidth = textWidth;
                wrapper.updateTransform();
            }
            wrapper.styles = extend(wrapper.styles, styles);
            css(wrapper.element, styles);
            return wrapper;
        },
        htmlGetBBox: function() {
            var wrapper = this, element = wrapper.element, bBox = wrapper.bBox;
            if (!bBox) {
                if (element.nodeName === "text") {
                    element.style.position = ABSOLUTE;
                }
                bBox = wrapper.bBox = {
                    x: element.offsetLeft,
                    y: element.offsetTop,
                    width: element.offsetWidth,
                    height: element.offsetHeight
                };
            }
            return bBox;
        },
        htmlUpdateTransform: function() {
            if (!this.added) {
                this.alignOnAdd = true;
                return;
            }
            var wrapper = this, renderer = wrapper.renderer, elem = wrapper.element, translateX = wrapper.translateX || 0, translateY = wrapper.translateY || 0, x = wrapper.x || 0, y = wrapper.y || 0, align = wrapper.textAlign || "left", alignCorrection = {
                left: 0,
                center: .5,
                right: 1
            }[align], nonLeft = align && align !== "left", shadows = wrapper.shadows;
            css(elem, {
                marginLeft: translateX,
                marginTop: translateY
            });
            if (shadows) {
                each(shadows, function(shadow) {
                    css(shadow, {
                        marginLeft: translateX + 1,
                        marginTop: translateY + 1
                    });
                });
            }
            if (wrapper.inverted) {
                each(elem.childNodes, function(child) {
                    renderer.invertChild(child, elem);
                });
            }
            if (elem.tagName === "SPAN") {
                var width, height, rotation = wrapper.rotation, baseline, radians = 0, costheta = 1, sintheta = 0, quad, textWidth = pInt(wrapper.textWidth), xCorr = wrapper.xCorr || 0, yCorr = wrapper.yCorr || 0, currentTextTransform = [ rotation, align, elem.innerHTML, wrapper.textWidth ].join(",");
                if (currentTextTransform !== wrapper.cTT) {
                    if (defined(rotation)) {
                        radians = rotation * deg2rad;
                        costheta = mathCos(radians);
                        sintheta = mathSin(radians);
                        wrapper.setSpanRotation(rotation, sintheta, costheta);
                    }
                    width = pick(wrapper.elemWidth, elem.offsetWidth);
                    height = pick(wrapper.elemHeight, elem.offsetHeight);
                    if (width > textWidth && /[ \-]/.test(elem.textContent || elem.innerText)) {
                        css(elem, {
                            width: textWidth + PX,
                            display: "block",
                            whiteSpace: "normal"
                        });
                        width = textWidth;
                    }
                    baseline = renderer.fontMetrics(elem.style.fontSize).b;
                    xCorr = costheta < 0 && -width;
                    yCorr = sintheta < 0 && -height;
                    quad = costheta * sintheta < 0;
                    xCorr += sintheta * baseline * (quad ? 1 - alignCorrection : alignCorrection);
                    yCorr -= costheta * baseline * (rotation ? quad ? alignCorrection : 1 - alignCorrection : 1);
                    if (nonLeft) {
                        xCorr -= width * alignCorrection * (costheta < 0 ? -1 : 1);
                        if (rotation) {
                            yCorr -= height * alignCorrection * (sintheta < 0 ? -1 : 1);
                        }
                        css(elem, {
                            textAlign: align
                        });
                    }
                    wrapper.xCorr = xCorr;
                    wrapper.yCorr = yCorr;
                }
                css(elem, {
                    left: x + xCorr + PX,
                    top: y + yCorr + PX
                });
                if (isWebKit) {
                    height = elem.offsetHeight;
                }
                wrapper.cTT = currentTextTransform;
            }
        },
        setSpanRotation: function(rotation) {
            var rotationStyle = {}, cssTransformKey = isIE ? "-ms-transform" : isWebKit ? "-webkit-transform" : isFirefox ? "MozTransform" : isOpera ? "-o-transform" : "";
            rotationStyle[cssTransformKey] = rotationStyle.transform = "rotate(" + rotation + "deg)";
            css(this.element, rotationStyle);
        },
        updateTransform: function() {
            var wrapper = this, translateX = wrapper.translateX || 0, translateY = wrapper.translateY || 0, scaleX = wrapper.scaleX, scaleY = wrapper.scaleY, inverted = wrapper.inverted, rotation = wrapper.rotation, transform;
            if (inverted) {
                translateX += wrapper.attr("width");
                translateY += wrapper.attr("height");
            }
            transform = [ "translate(" + translateX + "," + translateY + ")" ];
            if (inverted) {
                transform.push("rotate(90) scale(-1,1)");
            } else if (rotation) {
                transform.push("rotate(" + rotation + " " + (wrapper.x || 0) + " " + (wrapper.y || 0) + ")");
            }
            if (defined(scaleX) || defined(scaleY)) {
                transform.push("scale(" + pick(scaleX, 1) + " " + pick(scaleY, 1) + ")");
            }
            if (transform.length) {
                attr(wrapper.element, "transform", transform.join(" "));
            }
        },
        toFront: function() {
            var element = this.element;
            element.parentNode.appendChild(element);
            return this;
        },
        align: function(alignOptions, alignByTranslate, box) {
            var align, vAlign, x, y, attribs = {}, alignTo, renderer = this.renderer, alignedObjects = renderer.alignedObjects;
            if (alignOptions) {
                this.alignOptions = alignOptions;
                this.alignByTranslate = alignByTranslate;
                if (!box || isString(box)) {
                    this.alignTo = alignTo = box || "renderer";
                    erase(alignedObjects, this);
                    alignedObjects.push(this);
                    box = null;
                }
            } else {
                alignOptions = this.alignOptions;
                alignByTranslate = this.alignByTranslate;
                alignTo = this.alignTo;
            }
            box = pick(box, renderer[alignTo], renderer);
            align = alignOptions.align;
            vAlign = alignOptions.verticalAlign;
            x = (box.x || 0) + (alignOptions.x || 0);
            y = (box.y || 0) + (alignOptions.y || 0);
            if (align === "right" || align === "center") {
                x += (box.width - (alignOptions.width || 0)) / {
                    right: 1,
                    center: 2
                }[align];
            }
            attribs[alignByTranslate ? "translateX" : "x"] = mathRound(x);
            if (vAlign === "bottom" || vAlign === "middle") {
                y += (box.height - (alignOptions.height || 0)) / ({
                    bottom: 1,
                    middle: 2
                }[vAlign] || 1);
            }
            attribs[alignByTranslate ? "translateY" : "y"] = mathRound(y);
            this[this.placed ? "animate" : "attr"](attribs);
            this.placed = true;
            this.alignAttr = attribs;
            return this;
        },
        getBBox: function() {
            var wrapper = this, bBox = wrapper.bBox, renderer = wrapper.renderer, width, height, rotation = wrapper.rotation, element = wrapper.element, styles = wrapper.styles, rad = rotation * deg2rad;
            if (!bBox) {
                if (element.namespaceURI === SVG_NS || renderer.forExport) {
                    try {
                        bBox = element.getBBox ? extend({}, element.getBBox()) : {
                            width: element.offsetWidth,
                            height: element.offsetHeight
                        };
                    } catch (e) {}
                    if (!bBox || bBox.width < 0) {
                        bBox = {
                            width: 0,
                            height: 0
                        };
                    }
                } else {
                    bBox = wrapper.htmlGetBBox();
                }
                if (renderer.isSVG) {
                    width = bBox.width;
                    height = bBox.height;
                    if (isIE && styles && styles.fontSize === "11px" && height.toPrecision(3) === "22.7") {
                        bBox.height = height = 14;
                    }
                    if (rotation) {
                        bBox.width = mathAbs(height * mathSin(rad)) + mathAbs(width * mathCos(rad));
                        bBox.height = mathAbs(height * mathCos(rad)) + mathAbs(width * mathSin(rad));
                    }
                }
                wrapper.bBox = bBox;
            }
            return bBox;
        },
        show: function() {
            return this.attr({
                visibility: VISIBLE
            });
        },
        hide: function() {
            return this.attr({
                visibility: HIDDEN
            });
        },
        fadeOut: function(duration) {
            var elemWrapper = this;
            elemWrapper.animate({
                opacity: 0
            }, {
                duration: duration || 150,
                complete: function() {
                    elemWrapper.hide();
                }
            });
        },
        add: function(parent) {
            var renderer = this.renderer, parentWrapper = parent || renderer, parentNode = parentWrapper.element || renderer.box, childNodes = parentNode.childNodes, element = this.element, zIndex = attr(element, "zIndex"), otherElement, otherZIndex, i, inserted;
            if (parent) {
                this.parentGroup = parent;
            }
            this.parentInverted = parent && parent.inverted;
            if (this.textStr !== undefined) {
                renderer.buildText(this);
            }
            if (zIndex) {
                parentWrapper.handleZ = true;
                zIndex = pInt(zIndex);
            }
            if (parentWrapper.handleZ) {
                for (i = 0; i < childNodes.length; i++) {
                    otherElement = childNodes[i];
                    otherZIndex = attr(otherElement, "zIndex");
                    if (otherElement !== element && (pInt(otherZIndex) > zIndex || !defined(zIndex) && defined(otherZIndex))) {
                        parentNode.insertBefore(element, otherElement);
                        inserted = true;
                        break;
                    }
                }
            }
            if (!inserted) {
                parentNode.appendChild(element);
            }
            this.added = true;
            fireEvent(this, "add");
            return this;
        },
        safeRemoveChild: function(element) {
            var parentNode = element.parentNode;
            if (parentNode) {
                parentNode.removeChild(element);
            }
        },
        destroy: function() {
            var wrapper = this, element = wrapper.element || {}, shadows = wrapper.shadows, parentToClean = wrapper.renderer.isSVG && element.nodeName === "SPAN" && element.parentNode, grandParent, key, i;
            element.onclick = element.onmouseout = element.onmouseover = element.onmousemove = element.point = null;
            stop(wrapper);
            if (wrapper.clipPath) {
                wrapper.clipPath = wrapper.clipPath.destroy();
            }
            if (wrapper.stops) {
                for (i = 0; i < wrapper.stops.length; i++) {
                    wrapper.stops[i] = wrapper.stops[i].destroy();
                }
                wrapper.stops = null;
            }
            wrapper.safeRemoveChild(element);
            if (shadows) {
                each(shadows, function(shadow) {
                    wrapper.safeRemoveChild(shadow);
                });
            }
            while (parentToClean && parentToClean.childNodes.length === 0) {
                grandParent = parentToClean.parentNode;
                wrapper.safeRemoveChild(parentToClean);
                parentToClean = grandParent;
            }
            if (wrapper.alignTo) {
                erase(wrapper.renderer.alignedObjects, wrapper);
            }
            for (key in wrapper) {
                delete wrapper[key];
            }
            return null;
        },
        shadow: function(shadowOptions, group, cutOff) {
            var shadows = [], i, shadow, element = this.element, strokeWidth, shadowWidth, shadowElementOpacity, transform;
            if (shadowOptions) {
                shadowWidth = pick(shadowOptions.width, 3);
                shadowElementOpacity = (shadowOptions.opacity || .15) / shadowWidth;
                transform = this.parentInverted ? "(-1,-1)" : "(" + pick(shadowOptions.offsetX, 1) + ", " + pick(shadowOptions.offsetY, 1) + ")";
                for (i = 1; i <= shadowWidth; i++) {
                    shadow = element.cloneNode(0);
                    strokeWidth = shadowWidth * 2 + 1 - 2 * i;
                    attr(shadow, {
                        isShadow: "true",
                        stroke: shadowOptions.color || "black",
                        "stroke-opacity": shadowElementOpacity * i,
                        "stroke-width": strokeWidth,
                        transform: "translate" + transform,
                        fill: NONE
                    });
                    if (cutOff) {
                        attr(shadow, "height", mathMax(attr(shadow, "height") - strokeWidth, 0));
                        shadow.cutHeight = strokeWidth;
                    }
                    if (group) {
                        group.element.appendChild(shadow);
                    } else {
                        element.parentNode.insertBefore(shadow, element);
                    }
                    shadows.push(shadow);
                }
                this.shadows = shadows;
            }
            return this;
        }
    };
    var SVGRenderer = function() {
        this.init.apply(this, arguments);
    };
    SVGRenderer.prototype = {
        Element: SVGElement,
        init: function(container, width, height, forExport) {
            var renderer = this, loc = location, boxWrapper, element, desc;
            boxWrapper = renderer.createElement("svg").attr({
                version: "1.1"
            });
            element = boxWrapper.element;
            container.appendChild(element);
            if (container.innerHTML.indexOf("xmlns") === -1) {
                attr(element, "xmlns", SVG_NS);
            }
            renderer.isSVG = true;
            renderer.box = element;
            renderer.boxWrapper = boxWrapper;
            renderer.alignedObjects = [];
            renderer.url = (isFirefox || isWebKit) && doc.getElementsByTagName("base").length ? loc.href.replace(/#.*?$/, "").replace(/([\('\)])/g, "\\$1").replace(/ /g, "%20") : "";
            desc = this.createElement("desc").add();
            desc.element.appendChild(doc.createTextNode("Created with " + PRODUCT + " " + VERSION));
            renderer.defs = this.createElement("defs").add();
            renderer.forExport = forExport;
            renderer.gradients = {};
            renderer.setSize(width, height, false);
            var subPixelFix, rect;
            if (isFirefox && container.getBoundingClientRect) {
                renderer.subPixelFix = subPixelFix = function() {
                    css(container, {
                        left: 0,
                        top: 0
                    });
                    rect = container.getBoundingClientRect();
                    css(container, {
                        left: mathCeil(rect.left) - rect.left + PX,
                        top: mathCeil(rect.top) - rect.top + PX
                    });
                };
                subPixelFix();
                addEvent(win, "resize", subPixelFix);
            }
        },
        isHidden: function() {
            return !this.boxWrapper.getBBox().width;
        },
        destroy: function() {
            var renderer = this, rendererDefs = renderer.defs;
            renderer.box = null;
            renderer.boxWrapper = renderer.boxWrapper.destroy();
            destroyObjectProperties(renderer.gradients || {});
            renderer.gradients = null;
            if (rendererDefs) {
                renderer.defs = rendererDefs.destroy();
            }
            if (renderer.subPixelFix) {
                removeEvent(win, "resize", renderer.subPixelFix);
            }
            renderer.alignedObjects = null;
            return null;
        },
        createElement: function(nodeName) {
            var wrapper = new this.Element();
            wrapper.init(this, nodeName);
            return wrapper;
        },
        draw: function() {},
        buildText: function(wrapper) {
            var textNode = wrapper.element, renderer = this, forExport = renderer.forExport, lines = pick(wrapper.textStr, "").toString().replace(/<(b|strong)>/g, '<span style="font-weight:bold">').replace(/<(i|em)>/g, '<span style="font-style:italic">').replace(/<a/g, "<span").replace(/<\/(b|strong|i|em|a)>/g, "</span>").split(/<br.*?>/g), childNodes = textNode.childNodes, styleRegex = /style="([^"]+)"/, hrefRegex = /href="(http[^"]+)"/, parentX = attr(textNode, "x"), textStyles = wrapper.styles, width = textStyles && textStyles.width && pInt(textStyles.width), textLineHeight = textStyles && textStyles.lineHeight, i = childNodes.length;
            while (i--) {
                textNode.removeChild(childNodes[i]);
            }
            if (width && !wrapper.added) {
                this.box.appendChild(textNode);
            }
            if (lines[lines.length - 1] === "") {
                lines.pop();
            }
            each(lines, function(line, lineNo) {
                var spans, spanNo = 0;
                line = line.replace(/<span/g, "|||<span").replace(/<\/span>/g, "</span>|||");
                spans = line.split("|||");
                each(spans, function(span) {
                    if (span !== "" || spans.length === 1) {
                        var attributes = {}, tspan = doc.createElementNS(SVG_NS, "tspan"), spanStyle;
                        if (styleRegex.test(span)) {
                            spanStyle = span.match(styleRegex)[1].replace(/(;| |^)color([ :])/, "$1fill$2");
                            attr(tspan, "style", spanStyle);
                        }
                        if (hrefRegex.test(span) && !forExport) {
                            attr(tspan, "onclick", 'location.href="' + span.match(hrefRegex)[1] + '"');
                            css(tspan, {
                                cursor: "pointer"
                            });
                        }
                        span = (span.replace(/<(.|\n)*?>/g, "") || " ").replace(/&lt;/g, "<").replace(/&gt;/g, ">");
                        if (span !== " ") {
                            tspan.appendChild(doc.createTextNode(span));
                            if (!spanNo) {
                                attributes.x = parentX;
                            } else {
                                attributes.dx = 0;
                            }
                            attr(tspan, attributes);
                            if (!spanNo && lineNo) {
                                if (!hasSVG && forExport) {
                                    css(tspan, {
                                        display: "block"
                                    });
                                }
                                attr(tspan, "dy", textLineHeight || renderer.fontMetrics(/px$/.test(tspan.style.fontSize) ? tspan.style.fontSize : textStyles.fontSize).h, isWebKit && tspan.offsetHeight);
                            }
                            textNode.appendChild(tspan);
                            spanNo++;
                            if (width) {
                                var words = span.replace(/([^\^])-/g, "$1- ").split(" "), tooLong, actualWidth, rest = [];
                                while (words.length || rest.length) {
                                    delete wrapper.bBox;
                                    actualWidth = wrapper.getBBox().width;
                                    tooLong = actualWidth > width;
                                    if (!tooLong || words.length === 1) {
                                        words = rest;
                                        rest = [];
                                        if (words.length) {
                                            tspan = doc.createElementNS(SVG_NS, "tspan");
                                            attr(tspan, {
                                                dy: textLineHeight || 16,
                                                x: parentX
                                            });
                                            if (spanStyle) {
                                                attr(tspan, "style", spanStyle);
                                            }
                                            textNode.appendChild(tspan);
                                            if (actualWidth > width) {
                                                width = actualWidth;
                                            }
                                        }
                                    } else {
                                        tspan.removeChild(tspan.firstChild);
                                        rest.unshift(words.pop());
                                    }
                                    if (words.length) {
                                        tspan.appendChild(doc.createTextNode(words.join(" ").replace(/- /g, "-")));
                                    }
                                }
                            }
                        }
                    }
                });
            });
        },
        button: function(text, x, y, callback, normalState, hoverState, pressedState, disabledState) {
            var label = this.label(text, x, y, null, null, null, null, null, "button"), curState = 0, stateOptions, stateStyle, normalStyle, hoverStyle, pressedStyle, disabledStyle, STYLE = "style", verticalGradient = {
                x1: 0,
                y1: 0,
                x2: 0,
                y2: 1
            };
            normalState = merge({
                "stroke-width": 1,
                stroke: "#CCCCCC",
                fill: {
                    linearGradient: verticalGradient,
                    stops: [ [ 0, "#FEFEFE" ], [ 1, "#F6F6F6" ] ]
                },
                r: 2,
                padding: 5,
                style: {
                    color: "black"
                }
            }, normalState);
            normalStyle = normalState[STYLE];
            delete normalState[STYLE];
            hoverState = merge(normalState, {
                stroke: "#68A",
                fill: {
                    linearGradient: verticalGradient,
                    stops: [ [ 0, "#FFF" ], [ 1, "#ACF" ] ]
                }
            }, hoverState);
            hoverStyle = hoverState[STYLE];
            delete hoverState[STYLE];
            pressedState = merge(normalState, {
                stroke: "#68A",
                fill: {
                    linearGradient: verticalGradient,
                    stops: [ [ 0, "#9BD" ], [ 1, "#CDF" ] ]
                }
            }, pressedState);
            pressedStyle = pressedState[STYLE];
            delete pressedState[STYLE];
            disabledState = merge(normalState, {
                style: {
                    color: "#CCC"
                }
            }, disabledState);
            disabledStyle = disabledState[STYLE];
            delete disabledState[STYLE];
            addEvent(label.element, isIE ? "mouseover" : "mouseenter", function() {
                if (curState !== 3) {
                    label.attr(hoverState).css(hoverStyle);
                }
            });
            addEvent(label.element, isIE ? "mouseout" : "mouseleave", function() {
                if (curState !== 3) {
                    stateOptions = [ normalState, hoverState, pressedState ][curState];
                    stateStyle = [ normalStyle, hoverStyle, pressedStyle ][curState];
                    label.attr(stateOptions).css(stateStyle);
                }
            });
            label.setState = function(state) {
                label.state = curState = state;
                if (!state) {
                    label.attr(normalState).css(normalStyle);
                } else if (state === 2) {
                    label.attr(pressedState).css(pressedStyle);
                } else if (state === 3) {
                    label.attr(disabledState).css(disabledStyle);
                }
            };
            return label.on("click", function() {
                if (curState !== 3) {
                    callback.call(label);
                }
            }).attr(normalState).css(extend({
                cursor: "default"
            }, normalStyle));
        },
        crispLine: function(points, width) {
            if (points[1] === points[4]) {
                points[1] = points[4] = mathRound(points[1]) - width % 2 / 2;
            }
            if (points[2] === points[5]) {
                points[2] = points[5] = mathRound(points[2]) + width % 2 / 2;
            }
            return points;
        },
        path: function(path) {
            var attr = {
                fill: NONE
            };
            if (isArray(path)) {
                attr.d = path;
            } else if (isObject(path)) {
                extend(attr, path);
            }
            return this.createElement("path").attr(attr);
        },
        circle: function(x, y, r) {
            var attr = isObject(x) ? x : {
                x: x,
                y: y,
                r: r
            };
            return this.createElement("circle").attr(attr);
        },
        arc: function(x, y, r, innerR, start, end) {
            var arc;
            if (isObject(x)) {
                y = x.y;
                r = x.r;
                innerR = x.innerR;
                start = x.start;
                end = x.end;
                x = x.x;
            }
            arc = this.symbol("arc", x || 0, y || 0, r || 0, r || 0, {
                innerR: innerR || 0,
                start: start || 0,
                end: end || 0
            });
            arc.r = r;
            return arc;
        },
        rect: function(x, y, width, height, r, strokeWidth) {
            r = isObject(x) ? x.r : r;
            var wrapper = this.createElement("rect").attr({
                rx: r,
                ry: r,
                fill: NONE
            });
            return wrapper.attr(isObject(x) ? x : wrapper.crisp(strokeWidth, x, y, mathMax(width, 0), mathMax(height, 0)));
        },
        setSize: function(width, height, animate) {
            var renderer = this, alignedObjects = renderer.alignedObjects, i = alignedObjects.length;
            renderer.width = width;
            renderer.height = height;
            renderer.boxWrapper[pick(animate, true) ? "animate" : "attr"]({
                width: width,
                height: height
            });
            while (i--) {
                alignedObjects[i].align();
            }
        },
        g: function(name) {
            var elem = this.createElement("g");
            return defined(name) ? elem.attr({
                "class": PREFIX + name
            }) : elem;
        },
        image: function(src, x, y, width, height) {
            var attribs = {
                preserveAspectRatio: NONE
            }, elemWrapper;
            if (arguments.length > 1) {
                extend(attribs, {
                    x: x,
                    y: y,
                    width: width,
                    height: height
                });
            }
            elemWrapper = this.createElement("image").attr(attribs);
            if (elemWrapper.element.setAttributeNS) {
                elemWrapper.element.setAttributeNS("http://www.w3.org/1999/xlink", "href", src);
            } else {
                elemWrapper.element.setAttribute("hc-svg-href", src);
            }
            return elemWrapper;
        },
        symbol: function(symbol, x, y, width, height, options) {
            var obj, symbolFn = this.symbols[symbol], path = symbolFn && symbolFn(mathRound(x), mathRound(y), width, height, options), imageElement, imageRegex = /^url\((.*?)\)$/, imageSrc, imageSize, centerImage;
            if (path) {
                obj = this.path(path);
                extend(obj, {
                    symbolName: symbol,
                    x: x,
                    y: y,
                    width: width,
                    height: height
                });
                if (options) {
                    extend(obj, options);
                }
            } else if (imageRegex.test(symbol)) {
                centerImage = function(img, size) {
                    if (img.element) {
                        img.attr({
                            width: size[0],
                            height: size[1]
                        });
                        if (!img.alignByTranslate) {
                            img.translate(mathRound((width - size[0]) / 2), mathRound((height - size[1]) / 2));
                        }
                    }
                };
                imageSrc = symbol.match(imageRegex)[1];
                imageSize = symbolSizes[imageSrc];
                obj = this.image(imageSrc).attr({
                    x: x,
                    y: y
                });
                obj.isImg = true;
                if (imageSize) {
                    centerImage(obj, imageSize);
                } else {
                    obj.attr({
                        width: 0,
                        height: 0
                    });
                    imageElement = createElement("img", {
                        onload: function() {
                            centerImage(obj, symbolSizes[imageSrc] = [ this.width, this.height ]);
                        },
                        src: imageSrc
                    });
                }
            }
            return obj;
        },
        symbols: {
            circle: function(x, y, w, h) {
                var cpw = .166 * w;
                return [ M, x + w / 2, y, "C", x + w + cpw, y, x + w + cpw, y + h, x + w / 2, y + h, "C", x - cpw, y + h, x - cpw, y, x + w / 2, y, "Z" ];
            },
            square: function(x, y, w, h) {
                return [ M, x, y, L, x + w, y, x + w, y + h, x, y + h, "Z" ];
            },
            triangle: function(x, y, w, h) {
                return [ M, x + w / 2, y, L, x + w, y + h, x, y + h, "Z" ];
            },
            "triangle-down": function(x, y, w, h) {
                return [ M, x, y, L, x + w, y, x + w / 2, y + h, "Z" ];
            },
            diamond: function(x, y, w, h) {
                return [ M, x + w / 2, y, L, x + w, y + h / 2, x + w / 2, y + h, x, y + h / 2, "Z" ];
            },
            arc: function(x, y, w, h, options) {
                var start = options.start, radius = options.r || w || h, end = options.end - .001, innerRadius = options.innerR, open = options.open, cosStart = mathCos(start), sinStart = mathSin(start), cosEnd = mathCos(end), sinEnd = mathSin(end), longArc = options.end - start < mathPI ? 0 : 1;
                return [ M, x + radius * cosStart, y + radius * sinStart, "A", radius, radius, 0, longArc, 1, x + radius * cosEnd, y + radius * sinEnd, open ? M : L, x + innerRadius * cosEnd, y + innerRadius * sinEnd, "A", innerRadius, innerRadius, 0, longArc, 0, x + innerRadius * cosStart, y + innerRadius * sinStart, open ? "" : "Z" ];
            }
        },
        clipRect: function(x, y, width, height) {
            var wrapper, id = PREFIX + idCounter++, clipPath = this.createElement("clipPath").attr({
                id: id
            }).add(this.defs);
            wrapper = this.rect(x, y, width, height, 0).add(clipPath);
            wrapper.id = id;
            wrapper.clipPath = clipPath;
            return wrapper;
        },
        color: function(color, elem, prop) {
            var renderer = this, colorObject, regexRgba = /^rgba/, gradName, gradAttr, gradients, gradientObject, stops, stopColor, stopOpacity, radialReference, n, id, key = [];
            if (color && color.linearGradient) {
                gradName = "linearGradient";
            } else if (color && color.radialGradient) {
                gradName = "radialGradient";
            }
            if (gradName) {
                gradAttr = color[gradName];
                gradients = renderer.gradients;
                stops = color.stops;
                radialReference = elem.radialReference;
                if (isArray(gradAttr)) {
                    color[gradName] = gradAttr = {
                        x1: gradAttr[0],
                        y1: gradAttr[1],
                        x2: gradAttr[2],
                        y2: gradAttr[3],
                        gradientUnits: "userSpaceOnUse"
                    };
                }
                if (gradName === "radialGradient" && radialReference && !defined(gradAttr.gradientUnits)) {
                    gradAttr = merge(gradAttr, {
                        cx: radialReference[0] - radialReference[2] / 2 + gradAttr.cx * radialReference[2],
                        cy: radialReference[1] - radialReference[2] / 2 + gradAttr.cy * radialReference[2],
                        r: gradAttr.r * radialReference[2],
                        gradientUnits: "userSpaceOnUse"
                    });
                }
                for (n in gradAttr) {
                    if (n !== "id") {
                        key.push(n, gradAttr[n]);
                    }
                }
                for (n in stops) {
                    key.push(stops[n]);
                }
                key = key.join(",");
                if (gradients[key]) {
                    id = gradients[key].id;
                } else {
                    gradAttr.id = id = PREFIX + idCounter++;
                    gradients[key] = gradientObject = renderer.createElement(gradName).attr(gradAttr).add(renderer.defs);
                    gradientObject.stops = [];
                    each(stops, function(stop) {
                        var stopObject;
                        if (regexRgba.test(stop[1])) {
                            colorObject = Color(stop[1]);
                            stopColor = colorObject.get("rgb");
                            stopOpacity = colorObject.get("a");
                        } else {
                            stopColor = stop[1];
                            stopOpacity = 1;
                        }
                        stopObject = renderer.createElement("stop").attr({
                            offset: stop[0],
                            "stop-color": stopColor,
                            "stop-opacity": stopOpacity
                        }).add(gradientObject);
                        gradientObject.stops.push(stopObject);
                    });
                }
                return "url(" + renderer.url + "#" + id + ")";
            } else if (regexRgba.test(color)) {
                colorObject = Color(color);
                attr(elem, prop + "-opacity", colorObject.get("a"));
                return colorObject.get("rgb");
            } else {
                elem.removeAttribute(prop + "-opacity");
                return color;
            }
        },
        text: function(str, x, y, useHTML) {
            var renderer = this, defaultChartStyle = defaultOptions.chart.style, fakeSVG = useCanVG || !hasSVG && renderer.forExport, wrapper;
            if (useHTML && !renderer.forExport) {
                return renderer.html(str, x, y);
            }
            x = mathRound(pick(x, 0));
            y = mathRound(pick(y, 0));
            wrapper = renderer.createElement("text").attr({
                x: x,
                y: y,
                text: str
            }).css({
                fontFamily: defaultChartStyle.fontFamily,
                fontSize: defaultChartStyle.fontSize
            });
            if (fakeSVG) {
                wrapper.css({
                    position: ABSOLUTE
                });
            }
            wrapper.x = x;
            wrapper.y = y;
            return wrapper;
        },
        html: function(str, x, y) {
            var defaultChartStyle = defaultOptions.chart.style, wrapper = this.createElement("span"), attrSetters = wrapper.attrSetters, element = wrapper.element, renderer = wrapper.renderer;
            attrSetters.text = function(value) {
                if (value !== element.innerHTML) {
                    delete this.bBox;
                }
                element.innerHTML = value;
                return false;
            };
            attrSetters.x = attrSetters.y = attrSetters.align = function(value, key) {
                if (key === "align") {
                    key = "textAlign";
                }
                wrapper[key] = value;
                wrapper.htmlUpdateTransform();
                return false;
            };
            wrapper.attr({
                text: str,
                x: mathRound(x),
                y: mathRound(y)
            }).css({
                position: ABSOLUTE,
                whiteSpace: "nowrap",
                fontFamily: defaultChartStyle.fontFamily,
                fontSize: defaultChartStyle.fontSize
            });
            wrapper.css = wrapper.htmlCss;
            if (renderer.isSVG) {
                wrapper.add = function(svgGroupWrapper) {
                    var htmlGroup, container = renderer.box.parentNode, parentGroup, parents = [];
                    if (svgGroupWrapper) {
                        htmlGroup = svgGroupWrapper.div;
                        if (!htmlGroup) {
                            parentGroup = svgGroupWrapper;
                            while (parentGroup) {
                                parents.push(parentGroup);
                                parentGroup = parentGroup.parentGroup;
                            }
                            each(parents.reverse(), function(parentGroup) {
                                var htmlGroupStyle;
                                htmlGroup = parentGroup.div = parentGroup.div || createElement(DIV, {
                                    className: attr(parentGroup.element, "class")
                                }, {
                                    position: ABSOLUTE,
                                    left: (parentGroup.translateX || 0) + PX,
                                    top: (parentGroup.translateY || 0) + PX
                                }, htmlGroup || container);
                                htmlGroupStyle = htmlGroup.style;
                                extend(parentGroup.attrSetters, {
                                    translateX: function(value) {
                                        htmlGroupStyle.left = value + PX;
                                    },
                                    translateY: function(value) {
                                        htmlGroupStyle.top = value + PX;
                                    },
                                    visibility: function(value, key) {
                                        htmlGroupStyle[key] = value;
                                    }
                                });
                            });
                        }
                    } else {
                        htmlGroup = container;
                    }
                    htmlGroup.appendChild(element);
                    wrapper.added = true;
                    if (wrapper.alignOnAdd) {
                        wrapper.htmlUpdateTransform();
                    }
                    return wrapper;
                };
            }
            return wrapper;
        },
        fontMetrics: function(fontSize) {
            fontSize = pInt(fontSize || 11);
            var lineHeight = fontSize < 24 ? fontSize + 4 : mathRound(fontSize * 1.2), baseline = mathRound(lineHeight * .8);
            return {
                h: lineHeight,
                b: baseline
            };
        },
        label: function(str, x, y, shape, anchorX, anchorY, useHTML, baseline, className) {
            var renderer = this, wrapper = renderer.g(className), text = renderer.text("", 0, 0, useHTML).attr({
                zIndex: 1
            }), box, bBox, alignFactor = 0, padding = 3, paddingLeft = 0, width, height, wrapperX, wrapperY, crispAdjust = 0, deferredAttr = {}, baselineOffset, attrSetters = wrapper.attrSetters, needsBox;
            function updateBoxSize() {
                var boxX, boxY, style = text.element.style;
                bBox = (width === undefined || height === undefined || wrapper.styles.textAlign) && text.getBBox();
                wrapper.width = (width || bBox.width || 0) + 2 * padding + paddingLeft;
                wrapper.height = (height || bBox.height || 0) + 2 * padding;
                baselineOffset = padding + renderer.fontMetrics(style && style.fontSize).b;
                if (needsBox) {
                    if (!box) {
                        boxX = mathRound(-alignFactor * padding);
                        boxY = baseline ? -baselineOffset : 0;
                        wrapper.box = box = shape ? renderer.symbol(shape, boxX, boxY, wrapper.width, wrapper.height) : renderer.rect(boxX, boxY, wrapper.width, wrapper.height, 0, deferredAttr[STROKE_WIDTH]);
                        box.add(wrapper);
                    }
                    if (!box.isImg) {
                        box.attr(merge({
                            width: wrapper.width,
                            height: wrapper.height
                        }, deferredAttr));
                    }
                    deferredAttr = null;
                }
            }
            function updateTextPadding() {
                var styles = wrapper.styles, textAlign = styles && styles.textAlign, x = paddingLeft + padding * (1 - alignFactor), y;
                y = baseline ? 0 : baselineOffset;
                if (defined(width) && (textAlign === "center" || textAlign === "right")) {
                    x += {
                        center: .5,
                        right: 1
                    }[textAlign] * (width - bBox.width);
                }
                if (x !== text.x || y !== text.y) {
                    text.attr({
                        x: x,
                        y: y
                    });
                }
                text.x = x;
                text.y = y;
            }
            function boxAttr(key, value) {
                if (box) {
                    box.attr(key, value);
                } else {
                    deferredAttr[key] = value;
                }
            }
            function getSizeAfterAdd() {
                text.add(wrapper);
                wrapper.attr({
                    text: str,
                    x: x,
                    y: y
                });
                if (box && defined(anchorX)) {
                    wrapper.attr({
                        anchorX: anchorX,
                        anchorY: anchorY
                    });
                }
            }
            addEvent(wrapper, "add", getSizeAfterAdd);
            attrSetters.width = function(value) {
                width = value;
                return false;
            };
            attrSetters.height = function(value) {
                height = value;
                return false;
            };
            attrSetters.padding = function(value) {
                if (defined(value) && value !== padding) {
                    padding = value;
                    updateTextPadding();
                }
                return false;
            };
            attrSetters.paddingLeft = function(value) {
                if (defined(value) && value !== paddingLeft) {
                    paddingLeft = value;
                    updateTextPadding();
                }
                return false;
            };
            attrSetters.align = function(value) {
                alignFactor = {
                    left: 0,
                    center: .5,
                    right: 1
                }[value];
                return false;
            };
            attrSetters.text = function(value, key) {
                text.attr(key, value);
                updateBoxSize();
                updateTextPadding();
                return false;
            };
            attrSetters[STROKE_WIDTH] = function(value, key) {
                needsBox = true;
                crispAdjust = value % 2 / 2;
                boxAttr(key, value);
                return false;
            };
            attrSetters.stroke = attrSetters.fill = attrSetters.r = function(value, key) {
                if (key === "fill") {
                    needsBox = true;
                }
                boxAttr(key, value);
                return false;
            };
            attrSetters.anchorX = function(value, key) {
                anchorX = value;
                boxAttr(key, value + crispAdjust - wrapperX);
                return false;
            };
            attrSetters.anchorY = function(value, key) {
                anchorY = value;
                boxAttr(key, value - wrapperY);
                return false;
            };
            attrSetters.x = function(value) {
                wrapper.x = value;
                value -= alignFactor * ((width || bBox.width) + padding);
                wrapperX = mathRound(value);
                wrapper.attr("translateX", wrapperX);
                return false;
            };
            attrSetters.y = function(value) {
                wrapperY = wrapper.y = mathRound(value);
                wrapper.attr("translateY", wrapperY);
                return false;
            };
            var baseCss = wrapper.css;
            return extend(wrapper, {
                css: function(styles) {
                    if (styles) {
                        var textStyles = {};
                        styles = merge(styles);
                        each([ "fontSize", "fontWeight", "fontFamily", "color", "lineHeight", "width", "textDecoration", "textShadow" ], function(prop) {
                            if (styles[prop] !== UNDEFINED) {
                                textStyles[prop] = styles[prop];
                                delete styles[prop];
                            }
                        });
                        text.css(textStyles);
                    }
                    return baseCss.call(wrapper, styles);
                },
                getBBox: function() {
                    return {
                        width: bBox.width + 2 * padding,
                        height: bBox.height + 2 * padding,
                        x: bBox.x - padding,
                        y: bBox.y - padding
                    };
                },
                shadow: function(b) {
                    if (box) {
                        box.shadow(b);
                    }
                    return wrapper;
                },
                destroy: function() {
                    removeEvent(wrapper, "add", getSizeAfterAdd);
                    removeEvent(wrapper.element, "mouseenter");
                    removeEvent(wrapper.element, "mouseleave");
                    if (text) {
                        text = text.destroy();
                    }
                    if (box) {
                        box = box.destroy();
                    }
                    SVGElement.prototype.destroy.call(wrapper);
                    wrapper = renderer = updateBoxSize = updateTextPadding = boxAttr = getSizeAfterAdd = null;
                }
            });
        }
    };
    Renderer = SVGRenderer;
    var VMLRenderer, VMLElement;
    if (!hasSVG && !useCanVG) {
        Highcharts.VMLElement = VMLElement = {
            init: function(renderer, nodeName) {
                var wrapper = this, markup = [ "<", nodeName, ' filled="f" stroked="f"' ], style = [ "position: ", ABSOLUTE, ";" ], isDiv = nodeName === DIV;
                if (nodeName === "shape" || isDiv) {
                    style.push("left:0;top:0;width:1px;height:1px;");
                }
                style.push("visibility: ", isDiv ? HIDDEN : VISIBLE);
                markup.push(' style="', style.join(""), '"/>');
                if (nodeName) {
                    markup = isDiv || nodeName === "span" || nodeName === "img" ? markup.join("") : renderer.prepVML(markup);
                    wrapper.element = createElement(markup);
                }
                wrapper.renderer = renderer;
                wrapper.attrSetters = {};
            },
            add: function(parent) {
                var wrapper = this, renderer = wrapper.renderer, element = wrapper.element, box = renderer.box, inverted = parent && parent.inverted, parentNode = parent ? parent.element || parent : box;
                if (inverted) {
                    renderer.invertChild(element, parentNode);
                }
                parentNode.appendChild(element);
                wrapper.added = true;
                if (wrapper.alignOnAdd && !wrapper.deferUpdateTransform) {
                    wrapper.updateTransform();
                }
                fireEvent(wrapper, "add");
                return wrapper;
            },
            updateTransform: SVGElement.prototype.htmlUpdateTransform,
            setSpanRotation: function(rotation, sintheta, costheta) {
                css(this.element, {
                    filter: rotation ? [ "progid:DXImageTransform.Microsoft.Matrix(M11=", costheta, ", M12=", -sintheta, ", M21=", sintheta, ", M22=", costheta, ", sizingMethod='auto expand')" ].join("") : NONE
                });
            },
            pathToVML: function(value) {
                var i = value.length, path = [], clockwise;
                while (i--) {
                    if (isNumber(value[i])) {
                        path[i] = mathRound(value[i] * 10) - 5;
                    } else if (value[i] === "Z") {
                        path[i] = "x";
                    } else {
                        path[i] = value[i];
                        if (value.isArc && (value[i] === "wa" || value[i] === "at")) {
                            clockwise = value[i] === "wa" ? 1 : -1;
                            if (path[i + 5] === path[i + 7]) {
                                path[i + 7] -= clockwise;
                            }
                            if (path[i + 6] === path[i + 8]) {
                                path[i + 8] -= clockwise;
                            }
                        }
                    }
                }
                return path.join(" ") || "x";
            },
            attr: function(hash, val) {
                var wrapper = this, key, value, i, result, element = wrapper.element || {}, elemStyle = element.style, nodeName = element.nodeName, renderer = wrapper.renderer, symbolName = wrapper.symbolName, hasSetSymbolSize, shadows = wrapper.shadows, skipAttr, attrSetters = wrapper.attrSetters, ret = wrapper;
                if (isString(hash) && defined(val)) {
                    key = hash;
                    hash = {};
                    hash[key] = val;
                }
                if (isString(hash)) {
                    key = hash;
                    if (key === "strokeWidth" || key === "stroke-width") {
                        ret = wrapper.strokeweight;
                    } else {
                        ret = wrapper[key];
                    }
                } else {
                    for (key in hash) {
                        value = hash[key];
                        skipAttr = false;
                        result = attrSetters[key] && attrSetters[key].call(wrapper, value, key);
                        if (result !== false && value !== null) {
                            if (result !== UNDEFINED) {
                                value = result;
                            }
                            if (symbolName && /^(x|y|r|start|end|width|height|innerR|anchorX|anchorY)/.test(key)) {
                                if (!hasSetSymbolSize) {
                                    wrapper.symbolAttr(hash);
                                    hasSetSymbolSize = true;
                                }
                                skipAttr = true;
                            } else if (key === "d") {
                                value = value || [];
                                wrapper.d = value.join(" ");
                                element.path = value = wrapper.pathToVML(value);
                                if (shadows) {
                                    i = shadows.length;
                                    while (i--) {
                                        shadows[i].path = shadows[i].cutOff ? this.cutOffPath(value, shadows[i].cutOff) : value;
                                    }
                                }
                                skipAttr = true;
                            } else if (key === "visibility") {
                                if (shadows) {
                                    i = shadows.length;
                                    while (i--) {
                                        shadows[i].style[key] = value;
                                    }
                                }
                                if (nodeName === "DIV") {
                                    value = value === HIDDEN ? "-999em" : 0;
                                    if (!docMode8) {
                                        elemStyle[key] = value ? VISIBLE : HIDDEN;
                                    }
                                    key = "top";
                                }
                                elemStyle[key] = value;
                                skipAttr = true;
                            } else if (key === "zIndex") {
                                if (value) {
                                    elemStyle[key] = value;
                                }
                                skipAttr = true;
                            } else if (inArray(key, [ "x", "y", "width", "height" ]) !== -1) {
                                wrapper[key] = value;
                                if (key === "x" || key === "y") {
                                    key = {
                                        x: "left",
                                        y: "top"
                                    }[key];
                                } else {
                                    value = mathMax(0, value);
                                }
                                if (wrapper.updateClipping) {
                                    wrapper[key] = value;
                                    wrapper.updateClipping();
                                } else {
                                    elemStyle[key] = value;
                                }
                                skipAttr = true;
                            } else if (key === "class" && nodeName === "DIV") {
                                element.className = value;
                            } else if (key === "stroke") {
                                value = renderer.color(value, element, key);
                                key = "strokecolor";
                            } else if (key === "stroke-width" || key === "strokeWidth") {
                                element.stroked = value ? true : false;
                                key = "strokeweight";
                                wrapper[key] = value;
                                if (isNumber(value)) {
                                    value += PX;
                                }
                            } else if (key === "dashstyle") {
                                var strokeElem = element.getElementsByTagName("stroke")[0] || createElement(renderer.prepVML([ "<stroke/>" ]), null, null, element);
                                strokeElem[key] = value || "solid";
                                wrapper.dashstyle = value;
                                skipAttr = true;
                            } else if (key === "fill") {
                                if (nodeName === "SPAN") {
                                    elemStyle.color = value;
                                } else if (nodeName !== "IMG") {
                                    element.filled = value !== NONE ? true : false;
                                    value = renderer.color(value, element, key, wrapper);
                                    key = "fillcolor";
                                }
                            } else if (key === "opacity") {
                                skipAttr = true;
                            } else if (nodeName === "shape" && key === "rotation") {
                                wrapper[key] = element.style[key] = value;
                                element.style.left = -mathRound(mathSin(value * deg2rad) + 1) + PX;
                                element.style.top = mathRound(mathCos(value * deg2rad)) + PX;
                            } else if (key === "translateX" || key === "translateY" || key === "rotation") {
                                wrapper[key] = value;
                                wrapper.updateTransform();
                                skipAttr = true;
                            } else if (key === "text") {
                                this.bBox = null;
                                element.innerHTML = value;
                                skipAttr = true;
                            }
                            if (!skipAttr) {
                                if (docMode8) {
                                    element[key] = value;
                                } else {
                                    attr(element, key, value);
                                }
                            }
                        }
                    }
                }
                return ret;
            },
            clip: function(clipRect) {
                var wrapper = this, clipMembers, cssRet;
                if (clipRect) {
                    clipMembers = clipRect.members;
                    erase(clipMembers, wrapper);
                    clipMembers.push(wrapper);
                    wrapper.destroyClip = function() {
                        erase(clipMembers, wrapper);
                    };
                    cssRet = clipRect.getCSS(wrapper);
                } else {
                    if (wrapper.destroyClip) {
                        wrapper.destroyClip();
                    }
                    cssRet = {
                        clip: docMode8 ? "inherit" : "rect(auto)"
                    };
                }
                return wrapper.css(cssRet);
            },
            css: SVGElement.prototype.htmlCss,
            safeRemoveChild: function(element) {
                if (element.parentNode) {
                    discardElement(element);
                }
            },
            destroy: function() {
                if (this.destroyClip) {
                    this.destroyClip();
                }
                return SVGElement.prototype.destroy.apply(this);
            },
            on: function(eventType, handler) {
                this.element["on" + eventType] = function() {
                    var evt = win.event;
                    evt.target = evt.srcElement;
                    handler(evt);
                };
                return this;
            },
            cutOffPath: function(path, length) {
                var len;
                path = path.split(/[ ,]/);
                len = path.length;
                if (len === 9 || len === 11) {
                    path[len - 4] = path[len - 2] = pInt(path[len - 2]) - 10 * length;
                }
                return path.join(" ");
            },
            shadow: function(shadowOptions, group, cutOff) {
                var shadows = [], i, element = this.element, renderer = this.renderer, shadow, elemStyle = element.style, markup, path = element.path, strokeWidth, modifiedPath, shadowWidth, shadowElementOpacity;
                if (path && typeof path.value !== "string") {
                    path = "x";
                }
                modifiedPath = path;
                if (shadowOptions) {
                    shadowWidth = pick(shadowOptions.width, 3);
                    shadowElementOpacity = (shadowOptions.opacity || .15) / shadowWidth;
                    for (i = 1; i <= 3; i++) {
                        strokeWidth = shadowWidth * 2 + 1 - 2 * i;
                        if (cutOff) {
                            modifiedPath = this.cutOffPath(path.value, strokeWidth + .5);
                        }
                        markup = [ '<shape isShadow="true" strokeweight="', strokeWidth, '" filled="false" path="', modifiedPath, '" coordsize="10 10" style="', element.style.cssText, '" />' ];
                        shadow = createElement(renderer.prepVML(markup), null, {
                            left: pInt(elemStyle.left) + pick(shadowOptions.offsetX, 1),
                            top: pInt(elemStyle.top) + pick(shadowOptions.offsetY, 1)
                        });
                        if (cutOff) {
                            shadow.cutOff = strokeWidth + 1;
                        }
                        markup = [ '<stroke color="', shadowOptions.color || "black", '" opacity="', shadowElementOpacity * i, '"/>' ];
                        createElement(renderer.prepVML(markup), null, null, shadow);
                        if (group) {
                            group.element.appendChild(shadow);
                        } else {
                            element.parentNode.insertBefore(shadow, element);
                        }
                        shadows.push(shadow);
                    }
                    this.shadows = shadows;
                }
                return this;
            }
        };
        VMLElement = extendClass(SVGElement, VMLElement);
        var VMLRendererExtension = {
            Element: VMLElement,
            isIE8: userAgent.indexOf("MSIE 8.0") > -1,
            init: function(container, width, height) {
                var renderer = this, boxWrapper, box;
                renderer.alignedObjects = [];
                boxWrapper = renderer.createElement(DIV);
                box = boxWrapper.element;
                box.style.position = RELATIVE;
                container.appendChild(boxWrapper.element);
                renderer.isVML = true;
                renderer.box = box;
                renderer.boxWrapper = boxWrapper;
                renderer.setSize(width, height, false);
                if (!doc.namespaces.hcv) {
                    doc.namespaces.add("hcv", "urn:schemas-microsoft-com:vml");
                    doc.createStyleSheet().cssText = "hcv\\:fill, hcv\\:path, hcv\\:shape, hcv\\:stroke" + "{ behavior:url(#default#VML); display: inline-block; } ";
                }
            },
            isHidden: function() {
                return !this.box.offsetWidth;
            },
            clipRect: function(x, y, width, height) {
                var clipRect = this.createElement(), isObj = isObject(x);
                return extend(clipRect, {
                    members: [],
                    left: (isObj ? x.x : x) + 1,
                    top: (isObj ? x.y : y) + 1,
                    width: (isObj ? x.width : width) - 1,
                    height: (isObj ? x.height : height) - 1,
                    getCSS: function(wrapper) {
                        var element = wrapper.element, nodeName = element.nodeName, isShape = nodeName === "shape", inverted = wrapper.inverted, rect = this, top = rect.top - (isShape ? element.offsetTop : 0), left = rect.left, right = left + rect.width, bottom = top + rect.height, ret = {
                            clip: "rect(" + mathRound(inverted ? left : top) + "px," + mathRound(inverted ? bottom : right) + "px," + mathRound(inverted ? right : bottom) + "px," + mathRound(inverted ? top : left) + "px)"
                        };
                        if (!inverted && docMode8 && nodeName === "DIV") {
                            extend(ret, {
                                width: right + PX,
                                height: bottom + PX
                            });
                        }
                        return ret;
                    },
                    updateClipping: function() {
                        each(clipRect.members, function(member) {
                            member.css(clipRect.getCSS(member));
                        });
                    }
                });
            },
            color: function(color, elem, prop, wrapper) {
                var renderer = this, colorObject, regexRgba = /^rgba/, markup, fillType, ret = NONE;
                if (color && color.linearGradient) {
                    fillType = "gradient";
                } else if (color && color.radialGradient) {
                    fillType = "pattern";
                }
                if (fillType) {
                    var stopColor, stopOpacity, gradient = color.linearGradient || color.radialGradient, x1, y1, x2, y2, opacity1, opacity2, color1, color2, fillAttr = "", stops = color.stops, firstStop, lastStop, colors = [], addFillNode = function() {
                        markup = [ '<fill colors="' + colors.join(",") + '" opacity="', opacity2, '" o:opacity2="', opacity1, '" type="', fillType, '" ', fillAttr, 'focus="100%" method="any" />' ];
                        createElement(renderer.prepVML(markup), null, null, elem);
                    };
                    firstStop = stops[0];
                    lastStop = stops[stops.length - 1];
                    if (firstStop[0] > 0) {
                        stops.unshift([ 0, firstStop[1] ]);
                    }
                    if (lastStop[0] < 1) {
                        stops.push([ 1, lastStop[1] ]);
                    }
                    each(stops, function(stop, i) {
                        if (regexRgba.test(stop[1])) {
                            colorObject = Color(stop[1]);
                            stopColor = colorObject.get("rgb");
                            stopOpacity = colorObject.get("a");
                        } else {
                            stopColor = stop[1];
                            stopOpacity = 1;
                        }
                        colors.push(stop[0] * 100 + "% " + stopColor);
                        if (!i) {
                            opacity1 = stopOpacity;
                            color2 = stopColor;
                        } else {
                            opacity2 = stopOpacity;
                            color1 = stopColor;
                        }
                    });
                    if (prop === "fill") {
                        if (fillType === "gradient") {
                            x1 = gradient.x1 || gradient[0] || 0;
                            y1 = gradient.y1 || gradient[1] || 0;
                            x2 = gradient.x2 || gradient[2] || 0;
                            y2 = gradient.y2 || gradient[3] || 0;
                            fillAttr = 'angle="' + (90 - math.atan((y2 - y1) / (x2 - x1)) * 180 / mathPI) + '"';
                            addFillNode();
                        } else {
                            var r = gradient.r, sizex = r * 2, sizey = r * 2, cx = gradient.cx, cy = gradient.cy, radialReference = elem.radialReference, bBox, applyRadialGradient = function() {
                                if (radialReference) {
                                    bBox = wrapper.getBBox();
                                    cx += (radialReference[0] - bBox.x) / bBox.width - .5;
                                    cy += (radialReference[1] - bBox.y) / bBox.height - .5;
                                    sizex *= radialReference[2] / bBox.width;
                                    sizey *= radialReference[2] / bBox.height;
                                }
                                fillAttr = 'src="' + defaultOptions.global.VMLRadialGradientURL + '" ' + 'size="' + sizex + "," + sizey + '" ' + 'origin="0.5,0.5" ' + 'position="' + cx + "," + cy + '" ' + 'color2="' + color2 + '" ';
                                addFillNode();
                            };
                            if (wrapper.added) {
                                applyRadialGradient();
                            } else {
                                addEvent(wrapper, "add", applyRadialGradient);
                            }
                            ret = color1;
                        }
                    } else {
                        ret = stopColor;
                    }
                } else if (regexRgba.test(color) && elem.tagName !== "IMG") {
                    colorObject = Color(color);
                    markup = [ "<", prop, ' opacity="', colorObject.get("a"), '"/>' ];
                    createElement(this.prepVML(markup), null, null, elem);
                    ret = colorObject.get("rgb");
                } else {
                    var propNodes = elem.getElementsByTagName(prop);
                    if (propNodes.length) {
                        propNodes[0].opacity = 1;
                        propNodes[0].type = "solid";
                    }
                    ret = color;
                }
                return ret;
            },
            prepVML: function(markup) {
                var vmlStyle = "display:inline-block;behavior:url(#default#VML);", isIE8 = this.isIE8;
                markup = markup.join("");
                if (isIE8) {
                    markup = markup.replace("/>", ' xmlns="urn:schemas-microsoft-com:vml" />');
                    if (markup.indexOf('style="') === -1) {
                        markup = markup.replace("/>", ' style="' + vmlStyle + '" />');
                    } else {
                        markup = markup.replace('style="', 'style="' + vmlStyle);
                    }
                } else {
                    markup = markup.replace("<", "<hcv:");
                }
                return markup;
            },
            text: SVGRenderer.prototype.html,
            path: function(path) {
                var attr = {
                    coordsize: "10 10"
                };
                if (isArray(path)) {
                    attr.d = path;
                } else if (isObject(path)) {
                    extend(attr, path);
                }
                return this.createElement("shape").attr(attr);
            },
            circle: function(x, y, r) {
                var circle = this.symbol("circle");
                if (isObject(x)) {
                    r = x.r;
                    y = x.y;
                    x = x.x;
                }
                circle.isCircle = true;
                return circle.attr({
                    x: x,
                    y: y,
                    width: 2 * r,
                    height: 2 * r
                });
            },
            g: function(name) {
                var wrapper, attribs;
                if (name) {
                    attribs = {
                        className: PREFIX + name,
                        "class": PREFIX + name
                    };
                }
                wrapper = this.createElement(DIV).attr(attribs);
                return wrapper;
            },
            image: function(src, x, y, width, height) {
                var obj = this.createElement("img").attr({
                    src: src
                });
                if (arguments.length > 1) {
                    obj.attr({
                        x: x,
                        y: y,
                        width: width,
                        height: height
                    });
                }
                return obj;
            },
            rect: function(x, y, width, height, r, strokeWidth) {
                var wrapper = this.symbol("rect");
                wrapper.r = isObject(x) ? x.r : r;
                return wrapper.attr(isObject(x) ? x : wrapper.crisp(strokeWidth, x, y, mathMax(width, 0), mathMax(height, 0)));
            },
            invertChild: function(element, parentNode) {
                var parentStyle = parentNode.style;
                css(element, {
                    flip: "x",
                    left: pInt(parentStyle.width) - 1,
                    top: pInt(parentStyle.height) - 1,
                    rotation: -90
                });
            },
            symbols: {
                arc: function(x, y, w, h, options) {
                    var start = options.start, end = options.end, radius = options.r || w || h, innerRadius = options.innerR, cosStart = mathCos(start), sinStart = mathSin(start), cosEnd = mathCos(end), sinEnd = mathSin(end), ret;
                    if (end - start === 0) {
                        return [ "x" ];
                    }
                    ret = [ "wa", x - radius, y - radius, x + radius, y + radius, x + radius * cosStart, y + radius * sinStart, x + radius * cosEnd, y + radius * sinEnd ];
                    if (options.open && !innerRadius) {
                        ret.push("e", M, x, y);
                    }
                    ret.push("at", x - innerRadius, y - innerRadius, x + innerRadius, y + innerRadius, x + innerRadius * cosEnd, y + innerRadius * sinEnd, x + innerRadius * cosStart, y + innerRadius * sinStart, "x", "e");
                    ret.isArc = true;
                    return ret;
                },
                circle: function(x, y, w, h, wrapper) {
                    if (wrapper && wrapper.isCircle) {
                        x -= w / 2;
                        y -= h / 2;
                    }
                    return [ "wa", x, y, x + w, y + h, x + w, y + h / 2, x + w, y + h / 2, "e" ];
                },
                rect: function(left, top, width, height, options) {
                    var right = left + width, bottom = top + height, ret, r;
                    if (!defined(options) || !options.r) {
                        ret = SVGRenderer.prototype.symbols.square.apply(0, arguments);
                    } else {
                        r = mathMin(options.r, width, height);
                        ret = [ M, left + r, top, L, right - r, top, "wa", right - 2 * r, top, right, top + 2 * r, right - r, top, right, top + r, L, right, bottom - r, "wa", right - 2 * r, bottom - 2 * r, right, bottom, right, bottom - r, right - r, bottom, L, left + r, bottom, "wa", left, bottom - 2 * r, left + 2 * r, bottom, left + r, bottom, left, bottom - r, L, left, top + r, "wa", left, top, left + 2 * r, top + 2 * r, left, top + r, left + r, top, "x", "e" ];
                    }
                    return ret;
                }
            }
        };
        Highcharts.VMLRenderer = VMLRenderer = function() {
            this.init.apply(this, arguments);
        };
        VMLRenderer.prototype = merge(SVGRenderer.prototype, VMLRendererExtension);
        Renderer = VMLRenderer;
    }
    var CanVGRenderer, CanVGController;
    if (useCanVG) {
        Highcharts.CanVGRenderer = CanVGRenderer = function() {
            SVG_NS = "http://www.w3.org/1999/xhtml";
        };
        CanVGRenderer.prototype.symbols = {};
        CanVGController = function() {
            var deferredRenderCalls = [];
            function drawDeferred() {
                var callLength = deferredRenderCalls.length, callIndex;
                for (callIndex = 0; callIndex < callLength; callIndex++) {
                    deferredRenderCalls[callIndex]();
                }
                deferredRenderCalls = [];
            }
            return {
                push: function(func, scriptLocation) {
                    if (deferredRenderCalls.length === 0) {
                        getScript(scriptLocation, drawDeferred);
                    }
                    deferredRenderCalls.push(func);
                }
            };
        }();
        Renderer = CanVGRenderer;
    }
    function Tick(axis, pos, type, noLabel) {
        this.axis = axis;
        this.pos = pos;
        this.type = type || "";
        this.isNew = true;
        if (!type && !noLabel) {
            this.addLabel();
        }
    }
    Tick.prototype = {
        addLabel: function() {
            var tick = this, axis = tick.axis, options = axis.options, chart = axis.chart, horiz = axis.horiz, categories = axis.categories, names = axis.series[0] && axis.series[0].names, pos = tick.pos, labelOptions = options.labels, str, tickPositions = axis.tickPositions, width = horiz && categories && !labelOptions.step && !labelOptions.staggerLines && !labelOptions.rotation && chart.plotWidth / tickPositions.length || !horiz && (chart.optionsMarginLeft || chart.chartWidth * .33), isFirst = pos === tickPositions[0], isLast = pos === tickPositions[tickPositions.length - 1], css, attr, value = categories ? pick(categories[pos], names && names[pos], pos) : pos, label = tick.label, tickPositionInfo = tickPositions.info, dateTimeLabelFormat;
            if (axis.isDatetimeAxis && tickPositionInfo) {
                dateTimeLabelFormat = options.dateTimeLabelFormats[tickPositionInfo.higherRanks[pos] || tickPositionInfo.unitName];
            }
            tick.isFirst = isFirst;
            tick.isLast = isLast;
            str = axis.labelFormatter.call({
                axis: axis,
                chart: chart,
                isFirst: isFirst,
                isLast: isLast,
                dateTimeLabelFormat: dateTimeLabelFormat,
                value: axis.isLog ? correctFloat(lin2log(value)) : value
            });
            css = width && {
                width: mathMax(1, mathRound(width - 2 * (labelOptions.padding || 10))) + PX
            };
            css = extend(css, labelOptions.style);
            if (!defined(label)) {
                attr = {
                    align: axis.labelAlign
                };
                if (isNumber(labelOptions.rotation)) {
                    attr.rotation = labelOptions.rotation;
                }
                tick.label = defined(str) && labelOptions.enabled ? chart.renderer.text(str, 0, 0, labelOptions.useHTML).attr(attr).css(css).add(axis.labelGroup) : null;
            } else if (label) {
                label.attr({
                    text: str
                }).css(css);
            }
        },
        getLabelSize: function() {
            var label = this.label, axis = this.axis;
            return label ? (this.labelBBox = label.getBBox())[axis.horiz ? "height" : "width"] : 0;
        },
        getLabelSides: function() {
            var bBox = this.labelBBox, axis = this.axis, options = axis.options, labelOptions = options.labels, width = bBox.width, leftSide = width * {
                left: 0,
                center: .5,
                right: 1
            }[axis.labelAlign] - labelOptions.x;
            return [ -leftSide, width - leftSide ];
        },
        handleOverflow: function(index, xy) {
            var show = true, axis = this.axis, chart = axis.chart, isFirst = this.isFirst, isLast = this.isLast, x = xy.x, reversed = axis.reversed, tickPositions = axis.tickPositions;
            if (isFirst || isLast) {
                var sides = this.getLabelSides(), leftSide = sides[0], rightSide = sides[1], plotLeft = chart.plotLeft, plotRight = plotLeft + axis.len, neighbour = axis.ticks[tickPositions[index + (isFirst ? 1 : -1)]], neighbourEdge = neighbour && neighbour.label.xy && neighbour.label.xy.x + neighbour.getLabelSides()[isFirst ? 0 : 1];
                if (isFirst && !reversed || isLast && reversed) {
                    if (x + leftSide < plotLeft) {
                        x = plotLeft - leftSide;
                        if (neighbour && x + rightSide > neighbourEdge) {
                            show = false;
                        }
                    }
                } else {
                    if (x + rightSide > plotRight) {
                        x = plotRight - rightSide;
                        if (neighbour && x + leftSide < neighbourEdge) {
                            show = false;
                        }
                    }
                }
                xy.x = x;
            }
            return show;
        },
        getPosition: function(horiz, pos, tickmarkOffset, old) {
            var axis = this.axis, chart = axis.chart, cHeight = old && chart.oldChartHeight || chart.chartHeight;
            return {
                x: horiz ? axis.translate(pos + tickmarkOffset, null, null, old) + axis.transB : axis.left + axis.offset + (axis.opposite ? (old && chart.oldChartWidth || chart.chartWidth) - axis.right - axis.left : 0),
                y: horiz ? cHeight - axis.bottom + axis.offset - (axis.opposite ? axis.height : 0) : cHeight - axis.translate(pos + tickmarkOffset, null, null, old) - axis.transB
            };
        },
        getLabelPosition: function(x, y, label, horiz, labelOptions, tickmarkOffset, index, step) {
            var axis = this.axis, transA = axis.transA, reversed = axis.reversed, staggerLines = axis.staggerLines, baseline = axis.chart.renderer.fontMetrics(labelOptions.style.fontSize).b, rotation = labelOptions.rotation;
            x = x + labelOptions.x - (tickmarkOffset && horiz ? tickmarkOffset * transA * (reversed ? -1 : 1) : 0);
            y = y + labelOptions.y - (tickmarkOffset && !horiz ? tickmarkOffset * transA * (reversed ? 1 : -1) : 0);
            if (rotation && axis.side === 2) {
                y -= baseline - baseline * mathCos(rotation * deg2rad);
            }
            if (!defined(labelOptions.y) && !rotation) {
                y += baseline - label.getBBox().height / 2;
            }
            if (staggerLines) {
                y += index / (step || 1) % staggerLines * (axis.labelOffset / staggerLines);
            }
            return {
                x: x,
                y: y
            };
        },
        getMarkPath: function(x, y, tickLength, tickWidth, horiz, renderer) {
            return renderer.crispLine([ M, x, y, L, x + (horiz ? 0 : -tickLength), y + (horiz ? tickLength : 0) ], tickWidth);
        },
        render: function(index, old, opacity) {
            var tick = this, axis = tick.axis, options = axis.options, chart = axis.chart, renderer = chart.renderer, horiz = axis.horiz, type = tick.type, label = tick.label, pos = tick.pos, labelOptions = options.labels, gridLine = tick.gridLine, gridPrefix = type ? type + "Grid" : "grid", tickPrefix = type ? type + "Tick" : "tick", gridLineWidth = options[gridPrefix + "LineWidth"], gridLineColor = options[gridPrefix + "LineColor"], dashStyle = options[gridPrefix + "LineDashStyle"], tickLength = options[tickPrefix + "Length"], tickWidth = options[tickPrefix + "Width"] || 0, tickColor = options[tickPrefix + "Color"], tickPosition = options[tickPrefix + "Position"], gridLinePath, mark = tick.mark, markPath, step = labelOptions.step, attribs, show = true, tickmarkOffset = axis.tickmarkOffset, xy = tick.getPosition(horiz, pos, tickmarkOffset, old), x = xy.x, y = xy.y, reverseCrisp = horiz && x === axis.pos + axis.len || !horiz && y === axis.pos ? -1 : 1, staggerLines = axis.staggerLines;
            this.isActive = true;
            if (gridLineWidth) {
                gridLinePath = axis.getPlotLinePath(pos + tickmarkOffset, gridLineWidth * reverseCrisp, old, true);
                if (gridLine === UNDEFINED) {
                    attribs = {
                        stroke: gridLineColor,
                        "stroke-width": gridLineWidth
                    };
                    if (dashStyle) {
                        attribs.dashstyle = dashStyle;
                    }
                    if (!type) {
                        attribs.zIndex = 1;
                    }
                    if (old) {
                        attribs.opacity = 0;
                    }
                    tick.gridLine = gridLine = gridLineWidth ? renderer.path(gridLinePath).attr(attribs).add(axis.gridGroup) : null;
                }
                if (!old && gridLine && gridLinePath) {
                    gridLine[tick.isNew ? "attr" : "animate"]({
                        d: gridLinePath,
                        opacity: opacity
                    });
                }
            }
            if (tickWidth && tickLength) {
                if (tickPosition === "inside") {
                    tickLength = -tickLength;
                }
                if (axis.opposite) {
                    tickLength = -tickLength;
                }
                markPath = tick.getMarkPath(x, y, tickLength, tickWidth * reverseCrisp, horiz, renderer);
                if (mark) {
                    mark.animate({
                        d: markPath,
                        opacity: opacity
                    });
                } else {
                    tick.mark = renderer.path(markPath).attr({
                        stroke: tickColor,
                        "stroke-width": tickWidth,
                        opacity: opacity
                    }).add(axis.axisGroup);
                }
            }
            if (label && !isNaN(x)) {
                label.xy = xy = tick.getLabelPosition(x, y, label, horiz, labelOptions, tickmarkOffset, index, step);
                if (tick.isFirst && !tick.isLast && !pick(options.showFirstLabel, 1) || tick.isLast && !tick.isFirst && !pick(options.showLastLabel, 1)) {
                    show = false;
                } else if (!staggerLines && horiz && labelOptions.overflow === "justify" && !tick.handleOverflow(index, xy)) {
                    show = false;
                }
                if (step && index % step) {
                    show = false;
                }
                if (show && !isNaN(xy.y)) {
                    xy.opacity = opacity;
                    label[tick.isNew ? "attr" : "animate"](xy);
                    tick.isNew = false;
                } else {
                    label.attr("y", -9999);
                }
            }
        },
        destroy: function() {
            destroyObjectProperties(this, this.axis);
        }
    };
    function PlotLineOrBand(axis, options) {
        this.axis = axis;
        if (options) {
            this.options = options;
            this.id = options.id;
        }
    }
    PlotLineOrBand.prototype = {
        render: function() {
            var plotLine = this, axis = plotLine.axis, horiz = axis.horiz, halfPointRange = (axis.pointRange || 0) / 2, options = plotLine.options, optionsLabel = options.label, label = plotLine.label, width = options.width, to = options.to, from = options.from, isBand = defined(from) && defined(to), value = options.value, dashStyle = options.dashStyle, svgElem = plotLine.svgElem, path = [], addEvent, eventType, xs, ys, x, y, color = options.color, zIndex = options.zIndex, events = options.events, attribs, renderer = axis.chart.renderer;
            if (axis.isLog) {
                from = log2lin(from);
                to = log2lin(to);
                value = log2lin(value);
            }
            if (width) {
                path = axis.getPlotLinePath(value, width);
                attribs = {
                    stroke: color,
                    "stroke-width": width
                };
                if (dashStyle) {
                    attribs.dashstyle = dashStyle;
                }
            } else if (isBand) {
                from = mathMax(from, axis.min - halfPointRange);
                to = mathMin(to, axis.max + halfPointRange);
                path = axis.getPlotBandPath(from, to, options);
                attribs = {
                    fill: color
                };
                if (options.borderWidth) {
                    attribs.stroke = options.borderColor;
                    attribs["stroke-width"] = options.borderWidth;
                }
            } else {
                return;
            }
            if (defined(zIndex)) {
                attribs.zIndex = zIndex;
            }
            if (svgElem) {
                if (path) {
                    svgElem.animate({
                        d: path
                    }, null, svgElem.onGetPath);
                } else {
                    svgElem.hide();
                    svgElem.onGetPath = function() {
                        svgElem.show();
                    };
                }
            } else if (path && path.length) {
                plotLine.svgElem = svgElem = renderer.path(path).attr(attribs).add();
                if (events) {
                    addEvent = function(eventType) {
                        svgElem.on(eventType, function(e) {
                            events[eventType].apply(plotLine, [ e ]);
                        });
                    };
                    for (eventType in events) {
                        addEvent(eventType);
                    }
                }
            }
            if (optionsLabel && defined(optionsLabel.text) && path && path.length && axis.width > 0 && axis.height > 0) {
                optionsLabel = merge({
                    align: horiz && isBand && "center",
                    x: horiz ? !isBand && 4 : 10,
                    verticalAlign: !horiz && isBand && "middle",
                    y: horiz ? isBand ? 16 : 10 : isBand ? 6 : -4,
                    rotation: horiz && !isBand && 90
                }, optionsLabel);
                if (!label) {
                    plotLine.label = label = renderer.text(optionsLabel.text, 0, 0, optionsLabel.useHTML).attr({
                        align: optionsLabel.textAlign || optionsLabel.align,
                        rotation: optionsLabel.rotation,
                        zIndex: zIndex
                    }).css(optionsLabel.style).add();
                }
                xs = [ path[1], path[4], pick(path[6], path[1]) ];
                ys = [ path[2], path[5], pick(path[7], path[2]) ];
                x = arrayMin(xs);
                y = arrayMin(ys);
                label.align(optionsLabel, false, {
                    x: x,
                    y: y,
                    width: arrayMax(xs) - x,
                    height: arrayMax(ys) - y
                });
                label.show();
            } else if (label) {
                label.hide();
            }
            return plotLine;
        },
        destroy: function() {
            erase(this.axis.plotLinesAndBands, this);
            delete this.axis;
            destroyObjectProperties(this);
        }
    };
    function StackItem(axis, options, isNegative, x, stackOption, stacking) {
        var inverted = axis.chart.inverted;
        this.axis = axis;
        this.isNegative = isNegative;
        this.options = options;
        this.x = x;
        this.total = null;
        this.points = {};
        this.stack = stackOption;
        this.percent = stacking === "percent";
        this.alignOptions = {
            align: options.align || (inverted ? isNegative ? "left" : "right" : "center"),
            verticalAlign: options.verticalAlign || (inverted ? "middle" : isNegative ? "bottom" : "top"),
            y: pick(options.y, inverted ? 4 : isNegative ? 14 : -6),
            x: pick(options.x, inverted ? isNegative ? -6 : 6 : 0)
        };
        this.textAlign = options.textAlign || (inverted ? isNegative ? "right" : "left" : "center");
    }
    StackItem.prototype = {
        destroy: function() {
            destroyObjectProperties(this, this.axis);
        },
        setTotal: function(total) {
            this.total = total;
            this.cum = total;
        },
        addValue: function(y) {
            this.setTotal(correctFloat(this.total + y));
        },
        render: function(group) {
            var options = this.options, formatOption = options.format, str = formatOption ? format(formatOption, this) : options.formatter.call(this);
            if (this.label) {
                this.label.attr({
                    text: str,
                    visibility: HIDDEN
                });
            } else {
                this.label = this.axis.chart.renderer.text(str, 0, 0, options.useHTML).css(options.style).attr({
                    align: this.textAlign,
                    rotation: options.rotation,
                    visibility: HIDDEN
                }).add(group);
            }
        },
        cacheExtremes: function(series, extremes) {
            this.points[series.index] = extremes;
        },
        setOffset: function(xOffset, xWidth) {
            var stackItem = this, axis = stackItem.axis, chart = axis.chart, inverted = chart.inverted, neg = this.isNegative, y = axis.translate(this.percent ? 100 : this.total, 0, 0, 0, 1), yZero = axis.translate(0), h = mathAbs(y - yZero), x = chart.xAxis[0].translate(this.x) + xOffset, plotHeight = chart.plotHeight, stackBox = {
                x: inverted ? neg ? y : y - h : x,
                y: inverted ? plotHeight - x - xWidth : neg ? plotHeight - y - h : plotHeight - y,
                width: inverted ? h : xWidth,
                height: inverted ? xWidth : h
            }, label = this.label, alignAttr;
            if (label) {
                label.align(this.alignOptions, null, stackBox);
                alignAttr = label.alignAttr;
                label.attr({
                    visibility: this.options.crop === false || chart.isInsidePlot(alignAttr.x, alignAttr.y) ? hasSVG ? "inherit" : VISIBLE : HIDDEN
                });
            }
        }
    };
    function Axis() {
        this.init.apply(this, arguments);
    }
    Axis.prototype = {
        defaultOptions: {
            dateTimeLabelFormats: {
                millisecond: "%H:%M:%S.%L",
                second: "%H:%M:%S",
                minute: "%H:%M",
                hour: "%H:%M",
                day: "%e. %b",
                week: "%e. %b",
                month: "%b '%y",
                year: "%Y"
            },
            endOnTick: false,
            gridLineColor: "#C0C0C0",
            labels: defaultLabelOptions,
            lineColor: "#C0D0E0",
            lineWidth: 1,
            minPadding: .01,
            maxPadding: .01,
            minorGridLineColor: "#E0E0E0",
            minorGridLineWidth: 1,
            minorTickColor: "#A0A0A0",
            minorTickLength: 2,
            minorTickPosition: "outside",
            startOfWeek: 1,
            startOnTick: false,
            tickColor: "#C0D0E0",
            tickLength: 5,
            tickmarkPlacement: "between",
            tickPixelInterval: 100,
            tickPosition: "outside",
            tickWidth: 1,
            title: {
                align: "middle",
                style: {
                    color: "#4d759e",
                    fontWeight: "bold"
                }
            },
            type: "linear"
        },
        defaultYAxisOptions: {
            endOnTick: true,
            gridLineWidth: 1,
            tickPixelInterval: 72,
            showLastLabel: true,
            labels: {
                x: -8,
                y: 3
            },
            lineWidth: 0,
            maxPadding: .05,
            minPadding: .05,
            startOnTick: true,
            tickWidth: 0,
            title: {
                rotation: 270,
                text: "Values"
            },
            stackLabels: {
                enabled: false,
                formatter: function() {
                    return numberFormat(this.total, -1);
                },
                style: defaultLabelOptions.style
            }
        },
        defaultLeftAxisOptions: {
            labels: {
                x: -8,
                y: null
            },
            title: {
                rotation: 270
            }
        },
        defaultRightAxisOptions: {
            labels: {
                x: 8,
                y: null
            },
            title: {
                rotation: 90
            }
        },
        defaultBottomAxisOptions: {
            labels: {
                x: 0,
                y: 14
            },
            title: {
                rotation: 0
            }
        },
        defaultTopAxisOptions: {
            labels: {
                x: 0,
                y: -5
            },
            title: {
                rotation: 0
            }
        },
        init: function(chart, userOptions) {
            var isXAxis = userOptions.isX, axis = this;
            axis.horiz = chart.inverted ? !isXAxis : isXAxis;
            axis.isXAxis = isXAxis;
            axis.xOrY = isXAxis ? "x" : "y";
            axis.opposite = userOptions.opposite;
            axis.side = axis.horiz ? axis.opposite ? 0 : 2 : axis.opposite ? 1 : 3;
            axis.setOptions(userOptions);
            var options = this.options, type = options.type, isDatetimeAxis = type === "datetime";
            axis.labelFormatter = options.labels.formatter || axis.defaultLabelFormatter;
            axis.userOptions = userOptions;
            axis.minPixelPadding = 0;
            axis.chart = chart;
            axis.reversed = options.reversed;
            axis.zoomEnabled = options.zoomEnabled !== false;
            axis.categories = options.categories || type === "category";
            axis.isLog = type === "logarithmic";
            axis.isDatetimeAxis = isDatetimeAxis;
            axis.isLinked = defined(options.linkedTo);
            axis.tickmarkOffset = axis.categories && options.tickmarkPlacement === "between" ? .5 : 0;
            axis.ticks = {};
            axis.minorTicks = {};
            axis.plotLinesAndBands = [];
            axis.alternateBands = {};
            axis.len = 0;
            axis.minRange = axis.userMinRange = options.minRange || options.maxZoom;
            axis.range = options.range;
            axis.offset = options.offset || 0;
            axis.stacks = {};
            axis.oldStacks = {};
            axis.stackExtremes = {};
            axis.max = null;
            axis.min = null;
            var eventType, events = axis.options.events;
            if (inArray(axis, chart.axes) === -1) {
                chart.axes.push(axis);
                chart[isXAxis ? "xAxis" : "yAxis"].push(axis);
            }
            axis.series = axis.series || [];
            if (chart.inverted && isXAxis && axis.reversed === UNDEFINED) {
                axis.reversed = true;
            }
            axis.removePlotBand = axis.removePlotBandOrLine;
            axis.removePlotLine = axis.removePlotBandOrLine;
            for (eventType in events) {
                addEvent(axis, eventType, events[eventType]);
            }
            if (axis.isLog) {
                axis.val2lin = log2lin;
                axis.lin2val = lin2log;
            }
        },
        setOptions: function(userOptions) {
            this.options = merge(this.defaultOptions, this.isXAxis ? {} : this.defaultYAxisOptions, [ this.defaultTopAxisOptions, this.defaultRightAxisOptions, this.defaultBottomAxisOptions, this.defaultLeftAxisOptions ][this.side], merge(defaultOptions[this.isXAxis ? "xAxis" : "yAxis"], userOptions));
        },
        update: function(newOptions, redraw) {
            var chart = this.chart;
            newOptions = chart.options[this.xOrY + "Axis"][this.options.index] = merge(this.userOptions, newOptions);
            this.destroy(true);
            this._addedPlotLB = false;
            this.init(chart, extend(newOptions, {
                events: UNDEFINED
            }));
            chart.isDirtyBox = true;
            if (pick(redraw, true)) {
                chart.redraw();
            }
        },
        remove: function(redraw) {
            var chart = this.chart, key = this.xOrY + "Axis";
            each(this.series, function(series) {
                series.remove(false);
            });
            erase(chart.axes, this);
            erase(chart[key], this);
            chart.options[key].splice(this.options.index, 1);
            each(chart[key], function(axis, i) {
                axis.options.index = i;
            });
            this.destroy();
            chart.isDirtyBox = true;
            if (pick(redraw, true)) {
                chart.redraw();
            }
        },
        defaultLabelFormatter: function() {
            var axis = this.axis, value = this.value, categories = axis.categories, dateTimeLabelFormat = this.dateTimeLabelFormat, numericSymbols = defaultOptions.lang.numericSymbols, i = numericSymbols && numericSymbols.length, multi, ret, formatOption = axis.options.labels.format, numericSymbolDetector = axis.isLog ? value : axis.tickInterval;
            if (formatOption) {
                ret = format(formatOption, this);
            } else if (categories) {
                ret = value;
            } else if (dateTimeLabelFormat) {
                ret = dateFormat(dateTimeLabelFormat, value);
            } else if (i && numericSymbolDetector >= 1e3) {
                while (i-- && ret === UNDEFINED) {
                    multi = Math.pow(1e3, i + 1);
                    if (numericSymbolDetector >= multi && numericSymbols[i] !== null) {
                        ret = numberFormat(value / multi, -1) + numericSymbols[i];
                    }
                }
            }
            if (ret === UNDEFINED) {
                if (value >= 1e3) {
                    ret = numberFormat(value, 0);
                } else {
                    ret = numberFormat(value, -1);
                }
            }
            return ret;
        },
        getSeriesExtremes: function() {
            var axis = this, chart = axis.chart;
            axis.hasVisibleSeries = false;
            axis.dataMin = axis.dataMax = null;
            axis.stackExtremes = {};
            axis.buildStacks();
            each(axis.series, function(series) {
                if (series.visible || !chart.options.chart.ignoreHiddenSeries) {
                    var seriesOptions = series.options, stacking, xData, threshold = seriesOptions.threshold, seriesDataMin, seriesDataMax;
                    axis.hasVisibleSeries = true;
                    if (axis.isLog && threshold <= 0) {
                        threshold = null;
                    }
                    if (axis.isXAxis) {
                        xData = series.xData;
                        if (xData.length) {
                            axis.dataMin = mathMin(pick(axis.dataMin, xData[0]), arrayMin(xData));
                            axis.dataMax = mathMax(pick(axis.dataMax, xData[0]), arrayMax(xData));
                        }
                    } else {
                        stacking = seriesOptions.stacking;
                        axis.usePercentage = stacking === "percent";
                        if (axis.usePercentage) {
                            axis.dataMin = 0;
                            axis.dataMax = 99;
                        }
                        series.getExtremes();
                        seriesDataMax = series.dataMax;
                        seriesDataMin = series.dataMin;
                        if (!axis.usePercentage && defined(seriesDataMin) && defined(seriesDataMax)) {
                            axis.dataMin = mathMin(pick(axis.dataMin, seriesDataMin), seriesDataMin);
                            axis.dataMax = mathMax(pick(axis.dataMax, seriesDataMax), seriesDataMax);
                        }
                        if (defined(threshold)) {
                            if (axis.dataMin >= threshold) {
                                axis.dataMin = threshold;
                                axis.ignoreMinPadding = true;
                            } else if (axis.dataMax < threshold) {
                                axis.dataMax = threshold;
                                axis.ignoreMaxPadding = true;
                            }
                        }
                    }
                }
            });
        },
        translate: function(val, backwards, cvsCoord, old, handleLog, pointPlacement) {
            var axis = this, axisLength = axis.len, sign = 1, cvsOffset = 0, localA = old ? axis.oldTransA : axis.transA, localMin = old ? axis.oldMin : axis.min, returnValue, minPixelPadding = axis.minPixelPadding, postTranslate = (axis.options.ordinal || axis.isLog && handleLog) && axis.lin2val;
            if (!localA) {
                localA = axis.transA;
            }
            if (cvsCoord) {
                sign *= -1;
                cvsOffset = axisLength;
            }
            if (axis.reversed) {
                sign *= -1;
                cvsOffset -= sign * axisLength;
            }
            if (backwards) {
                val = val * sign + cvsOffset;
                val -= minPixelPadding;
                returnValue = val / localA + localMin;
                if (postTranslate) {
                    returnValue = axis.lin2val(returnValue);
                }
            } else {
                if (postTranslate) {
                    val = axis.val2lin(val);
                }
                if (pointPlacement === "between") {
                    pointPlacement = .5;
                }
                returnValue = sign * (val - localMin) * localA + cvsOffset + sign * minPixelPadding + (isNumber(pointPlacement) ? localA * pointPlacement * axis.pointRange : 0);
            }
            return returnValue;
        },
        toPixels: function(value, paneCoordinates) {
            return this.translate(value, false, !this.horiz, null, true) + (paneCoordinates ? 0 : this.pos);
        },
        toValue: function(pixel, paneCoordinates) {
            return this.translate(pixel - (paneCoordinates ? 0 : this.pos), true, !this.horiz, null, true);
        },
        getPlotLinePath: function(value, lineWidth, old, force) {
            var axis = this, chart = axis.chart, axisLeft = axis.left, axisTop = axis.top, x1, y1, x2, y2, translatedValue = axis.translate(value, null, null, old), cHeight = old && chart.oldChartHeight || chart.chartHeight, cWidth = old && chart.oldChartWidth || chart.chartWidth, skip, transB = axis.transB;
            x1 = x2 = mathRound(translatedValue + transB);
            y1 = y2 = mathRound(cHeight - translatedValue - transB);
            if (isNaN(translatedValue)) {
                skip = true;
            } else if (axis.horiz) {
                y1 = axisTop;
                y2 = cHeight - axis.bottom;
                if (x1 < axisLeft || x1 > axisLeft + axis.width) {
                    skip = true;
                }
            } else {
                x1 = axisLeft;
                x2 = cWidth - axis.right;
                if (y1 < axisTop || y1 > axisTop + axis.height) {
                    skip = true;
                }
            }
            return skip && !force ? null : chart.renderer.crispLine([ M, x1, y1, L, x2, y2 ], lineWidth || 0);
        },
        getPlotBandPath: function(from, to) {
            var toPath = this.getPlotLinePath(to), path = this.getPlotLinePath(from);
            if (path && toPath) {
                path.push(toPath[4], toPath[5], toPath[1], toPath[2]);
            } else {
                path = null;
            }
            return path;
        },
        getLinearTickPositions: function(tickInterval, min, max) {
            var pos, lastPos, roundedMin = correctFloat(mathFloor(min / tickInterval) * tickInterval), roundedMax = correctFloat(mathCeil(max / tickInterval) * tickInterval), tickPositions = [];
            pos = roundedMin;
            while (pos <= roundedMax) {
                tickPositions.push(pos);
                pos = correctFloat(pos + tickInterval);
                if (pos === lastPos) {
                    break;
                }
                lastPos = pos;
            }
            return tickPositions;
        },
        getLogTickPositions: function(interval, min, max, minor) {
            var axis = this, options = axis.options, axisLength = axis.len, positions = [];
            if (!minor) {
                axis._minorAutoInterval = null;
            }
            if (interval >= .5) {
                interval = mathRound(interval);
                positions = axis.getLinearTickPositions(interval, min, max);
            } else if (interval >= .08) {
                var roundedMin = mathFloor(min), intermediate, i, j, len, pos, lastPos, break2;
                if (interval > .3) {
                    intermediate = [ 1, 2, 4 ];
                } else if (interval > .15) {
                    intermediate = [ 1, 2, 4, 6, 8 ];
                } else {
                    intermediate = [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ];
                }
                for (i = roundedMin; i < max + 1 && !break2; i++) {
                    len = intermediate.length;
                    for (j = 0; j < len && !break2; j++) {
                        pos = log2lin(lin2log(i) * intermediate[j]);
                        if (pos > min && (!minor || lastPos <= max)) {
                            positions.push(lastPos);
                        }
                        if (lastPos > max) {
                            break2 = true;
                        }
                        lastPos = pos;
                    }
                }
            } else {
                var realMin = lin2log(min), realMax = lin2log(max), tickIntervalOption = options[minor ? "minorTickInterval" : "tickInterval"], filteredTickIntervalOption = tickIntervalOption === "auto" ? null : tickIntervalOption, tickPixelIntervalOption = options.tickPixelInterval / (minor ? 5 : 1), totalPixelLength = minor ? axisLength / axis.tickPositions.length : axisLength;
                interval = pick(filteredTickIntervalOption, axis._minorAutoInterval, (realMax - realMin) * tickPixelIntervalOption / (totalPixelLength || 1));
                interval = normalizeTickInterval(interval, null, getMagnitude(interval));
                positions = map(axis.getLinearTickPositions(interval, realMin, realMax), log2lin);
                if (!minor) {
                    axis._minorAutoInterval = interval / 5;
                }
            }
            if (!minor) {
                axis.tickInterval = interval;
            }
            return positions;
        },
        getMinorTickPositions: function() {
            var axis = this, options = axis.options, tickPositions = axis.tickPositions, minorTickInterval = axis.minorTickInterval, minorTickPositions = [], pos, i, len;
            if (axis.isLog) {
                len = tickPositions.length;
                for (i = 1; i < len; i++) {
                    minorTickPositions = minorTickPositions.concat(axis.getLogTickPositions(minorTickInterval, tickPositions[i - 1], tickPositions[i], true));
                }
            } else if (axis.isDatetimeAxis && options.minorTickInterval === "auto") {
                minorTickPositions = minorTickPositions.concat(getTimeTicks(normalizeTimeTickInterval(minorTickInterval), axis.min, axis.max, options.startOfWeek));
                if (minorTickPositions[0] < axis.min) {
                    minorTickPositions.shift();
                }
            } else {
                for (pos = axis.min + (tickPositions[0] - axis.min) % minorTickInterval; pos <= axis.max; pos += minorTickInterval) {
                    minorTickPositions.push(pos);
                }
            }
            return minorTickPositions;
        },
        adjustForMinRange: function() {
            var axis = this, options = axis.options, min = axis.min, max = axis.max, zoomOffset, spaceAvailable = axis.dataMax - axis.dataMin >= axis.minRange, closestDataRange, i, distance, xData, loopLength, minArgs, maxArgs;
            if (axis.isXAxis && axis.minRange === UNDEFINED && !axis.isLog) {
                if (defined(options.min) || defined(options.max)) {
                    axis.minRange = null;
                } else {
                    each(axis.series, function(series) {
                        xData = series.xData;
                        loopLength = series.xIncrement ? 1 : xData.length - 1;
                        for (i = loopLength; i > 0; i--) {
                            distance = xData[i] - xData[i - 1];
                            if (closestDataRange === UNDEFINED || distance < closestDataRange) {
                                closestDataRange = distance;
                            }
                        }
                    });
                    axis.minRange = mathMin(closestDataRange * 5, axis.dataMax - axis.dataMin);
                }
            }
            if (max - min < axis.minRange) {
                var minRange = axis.minRange;
                zoomOffset = (minRange - max + min) / 2;
                minArgs = [ min - zoomOffset, pick(options.min, min - zoomOffset) ];
                if (spaceAvailable) {
                    minArgs[2] = axis.dataMin;
                }
                min = arrayMax(minArgs);
                maxArgs = [ min + minRange, pick(options.max, min + minRange) ];
                if (spaceAvailable) {
                    maxArgs[2] = axis.dataMax;
                }
                max = arrayMin(maxArgs);
                if (max - min < minRange) {
                    minArgs[0] = max - minRange;
                    minArgs[1] = pick(options.min, max - minRange);
                    min = arrayMax(minArgs);
                }
            }
            axis.min = min;
            axis.max = max;
        },
        setAxisTranslation: function(saveOld) {
            var axis = this, range = axis.max - axis.min, pointRange = 0, closestPointRange, minPointOffset = 0, pointRangePadding = 0, linkedParent = axis.linkedParent, ordinalCorrection, transA = axis.transA;
            if (axis.isXAxis) {
                if (linkedParent) {
                    minPointOffset = linkedParent.minPointOffset;
                    pointRangePadding = linkedParent.pointRangePadding;
                } else {
                    each(axis.series, function(series) {
                        var seriesPointRange = series.pointRange, pointPlacement = series.options.pointPlacement, seriesClosestPointRange = series.closestPointRange;
                        if (seriesPointRange > range) {
                            seriesPointRange = 0;
                        }
                        pointRange = mathMax(pointRange, seriesPointRange);
                        minPointOffset = mathMax(minPointOffset, isString(pointPlacement) ? 0 : seriesPointRange / 2);
                        pointRangePadding = mathMax(pointRangePadding, pointPlacement === "on" ? 0 : seriesPointRange);
                        if (!series.noSharedTooltip && defined(seriesClosestPointRange)) {
                            closestPointRange = defined(closestPointRange) ? mathMin(closestPointRange, seriesClosestPointRange) : seriesClosestPointRange;
                        }
                    });
                }
                ordinalCorrection = axis.ordinalSlope && closestPointRange ? axis.ordinalSlope / closestPointRange : 1;
                axis.minPointOffset = minPointOffset = minPointOffset * ordinalCorrection;
                axis.pointRangePadding = pointRangePadding = pointRangePadding * ordinalCorrection;
                axis.pointRange = mathMin(pointRange, range);
                axis.closestPointRange = closestPointRange;
            }
            if (saveOld) {
                axis.oldTransA = transA;
            }
            axis.translationSlope = axis.transA = transA = axis.len / (range + pointRangePadding || 1);
            axis.transB = axis.horiz ? axis.left : axis.bottom;
            axis.minPixelPadding = transA * minPointOffset;
        },
        setTickPositions: function(secondPass) {
            var axis = this, chart = axis.chart, options = axis.options, isLog = axis.isLog, isDatetimeAxis = axis.isDatetimeAxis, isXAxis = axis.isXAxis, isLinked = axis.isLinked, tickPositioner = axis.options.tickPositioner, maxPadding = options.maxPadding, minPadding = options.minPadding, length, linkedParentExtremes, tickIntervalOption = options.tickInterval, minTickIntervalOption = options.minTickInterval, tickPixelIntervalOption = options.tickPixelInterval, tickPositions, categories = axis.categories;
            if (isLinked) {
                axis.linkedParent = chart[isXAxis ? "xAxis" : "yAxis"][options.linkedTo];
                linkedParentExtremes = axis.linkedParent.getExtremes();
                axis.min = pick(linkedParentExtremes.min, linkedParentExtremes.dataMin);
                axis.max = pick(linkedParentExtremes.max, linkedParentExtremes.dataMax);
                if (options.type !== axis.linkedParent.options.type) {
                    error(11, 1);
                }
            } else {
                axis.min = pick(axis.userMin, options.min, axis.dataMin);
                axis.max = pick(axis.userMax, options.max, axis.dataMax);
            }
            if (isLog) {
                if (!secondPass && mathMin(axis.min, pick(axis.dataMin, axis.min)) <= 0) {
                    error(10, 1);
                }
                axis.min = correctFloat(log2lin(axis.min));
                axis.max = correctFloat(log2lin(axis.max));
            }
            if (axis.range) {
                axis.userMin = axis.min = mathMax(axis.min, axis.max - axis.range);
                axis.userMax = axis.max;
                if (secondPass) {
                    axis.range = null;
                }
            }
            if (axis.beforePadding) {
                axis.beforePadding();
            }
            axis.adjustForMinRange();
            if (!categories && !axis.usePercentage && !isLinked && defined(axis.min) && defined(axis.max)) {
                length = axis.max - axis.min;
                if (length) {
                    if (!defined(options.min) && !defined(axis.userMin) && minPadding && (axis.dataMin < 0 || !axis.ignoreMinPadding)) {
                        axis.min -= length * minPadding;
                    }
                    if (!defined(options.max) && !defined(axis.userMax) && maxPadding && (axis.dataMax > 0 || !axis.ignoreMaxPadding)) {
                        axis.max += length * maxPadding;
                    }
                }
            }
            if (axis.min === axis.max || axis.min === undefined || axis.max === undefined) {
                axis.tickInterval = 1;
            } else if (isLinked && !tickIntervalOption && tickPixelIntervalOption === axis.linkedParent.options.tickPixelInterval) {
                axis.tickInterval = axis.linkedParent.tickInterval;
            } else {
                axis.tickInterval = pick(tickIntervalOption, categories ? 1 : (axis.max - axis.min) * tickPixelIntervalOption / (axis.len || 1));
            }
            if (isXAxis && !secondPass) {
                each(axis.series, function(series) {
                    series.processData(axis.min !== axis.oldMin || axis.max !== axis.oldMax);
                });
            }
            axis.setAxisTranslation(true);
            if (axis.beforeSetTickPositions) {
                axis.beforeSetTickPositions();
            }
            if (axis.postProcessTickInterval) {
                axis.tickInterval = axis.postProcessTickInterval(axis.tickInterval);
            }
            if (axis.pointRange) {
                axis.tickInterval = mathMax(axis.pointRange, axis.tickInterval);
            }
            if (!tickIntervalOption && axis.tickInterval < minTickIntervalOption) {
                axis.tickInterval = minTickIntervalOption;
            }
            if (!isDatetimeAxis && !isLog) {
                if (!tickIntervalOption) {
                    axis.tickInterval = normalizeTickInterval(axis.tickInterval, null, getMagnitude(axis.tickInterval), options);
                }
            }
            axis.minorTickInterval = options.minorTickInterval === "auto" && axis.tickInterval ? axis.tickInterval / 5 : options.minorTickInterval;
            axis.tickPositions = tickPositions = options.tickPositions ? [].concat(options.tickPositions) : tickPositioner && tickPositioner.apply(axis, [ axis.min, axis.max ]);
            if (!tickPositions) {
                if ((axis.max - axis.min) / axis.tickInterval > 2 * axis.len) {
                    error(19, true);
                }
                if (isDatetimeAxis) {
                    tickPositions = (axis.getNonLinearTimeTicks || getTimeTicks)(normalizeTimeTickInterval(axis.tickInterval, options.units), axis.min, axis.max, options.startOfWeek, axis.ordinalPositions, axis.closestPointRange, true);
                } else if (isLog) {
                    tickPositions = axis.getLogTickPositions(axis.tickInterval, axis.min, axis.max);
                } else {
                    tickPositions = axis.getLinearTickPositions(axis.tickInterval, axis.min, axis.max);
                }
                axis.tickPositions = tickPositions;
            }
            if (!isLinked) {
                var roundedMin = tickPositions[0], roundedMax = tickPositions[tickPositions.length - 1], minPointOffset = axis.minPointOffset || 0, singlePad;
                if (options.startOnTick) {
                    axis.min = roundedMin;
                } else if (axis.min - minPointOffset > roundedMin) {
                    tickPositions.shift();
                }
                if (options.endOnTick) {
                    axis.max = roundedMax;
                } else if (axis.max + minPointOffset < roundedMax) {
                    tickPositions.pop();
                }
                if (tickPositions.length === 1) {
                    singlePad = .001;
                    axis.min -= singlePad;
                    axis.max += singlePad;
                }
            }
        },
        setMaxTicks: function() {
            var chart = this.chart, maxTicks = chart.maxTicks || {}, tickPositions = this.tickPositions, key = this._maxTicksKey = [ this.xOrY, this.pos, this.len ].join("-");
            if (!this.isLinked && !this.isDatetimeAxis && tickPositions && tickPositions.length > (maxTicks[key] || 0) && this.options.alignTicks !== false) {
                maxTicks[key] = tickPositions.length;
            }
            chart.maxTicks = maxTicks;
        },
        adjustTickAmount: function() {
            var axis = this, chart = axis.chart, key = axis._maxTicksKey, tickPositions = axis.tickPositions, maxTicks = chart.maxTicks;
            if (maxTicks && maxTicks[key] && !axis.isDatetimeAxis && !axis.categories && !axis.isLinked && axis.options.alignTicks !== false) {
                var oldTickAmount = axis.tickAmount, calculatedTickAmount = tickPositions.length, tickAmount;
                axis.tickAmount = tickAmount = maxTicks[key];
                if (calculatedTickAmount < tickAmount) {
                    while (tickPositions.length < tickAmount) {
                        tickPositions.push(correctFloat(tickPositions[tickPositions.length - 1] + axis.tickInterval));
                    }
                    axis.transA *= (calculatedTickAmount - 1) / (tickAmount - 1);
                    axis.max = tickPositions[tickPositions.length - 1];
                }
                if (defined(oldTickAmount) && tickAmount !== oldTickAmount) {
                    axis.isDirty = true;
                }
            }
        },
        setScale: function() {
            var axis = this, stacks = axis.stacks, type, i, isDirtyData, isDirtyAxisLength;
            axis.oldMin = axis.min;
            axis.oldMax = axis.max;
            axis.oldAxisLength = axis.len;
            axis.setAxisSize();
            isDirtyAxisLength = axis.len !== axis.oldAxisLength;
            each(axis.series, function(series) {
                if (series.isDirtyData || series.isDirty || series.xAxis.isDirty) {
                    isDirtyData = true;
                }
            });
            if (isDirtyAxisLength || isDirtyData || axis.isLinked || axis.forceRedraw || axis.userMin !== axis.oldUserMin || axis.userMax !== axis.oldUserMax) {
                if (!axis.isXAxis) {
                    for (type in stacks) {
                        for (i in stacks[type]) {
                            stacks[type][i].total = null;
                        }
                    }
                }
                axis.forceRedraw = false;
                axis.getSeriesExtremes();
                axis.setTickPositions();
                axis.oldUserMin = axis.userMin;
                axis.oldUserMax = axis.userMax;
                if (!axis.isDirty) {
                    axis.isDirty = isDirtyAxisLength || axis.min !== axis.oldMin || axis.max !== axis.oldMax;
                }
            } else if (!axis.isXAxis) {
                if (axis.oldStacks) {
                    stacks = axis.stacks = axis.oldStacks;
                }
                for (type in stacks) {
                    for (i in stacks[type]) {
                        stacks[type][i].cum = stacks[type][i].total;
                    }
                }
            }
            axis.setMaxTicks();
        },
        setExtremes: function(newMin, newMax, redraw, animation, eventArguments) {
            var axis = this, chart = axis.chart;
            redraw = pick(redraw, true);
            eventArguments = extend(eventArguments, {
                min: newMin,
                max: newMax
            });
            fireEvent(axis, "setExtremes", eventArguments, function() {
                axis.userMin = newMin;
                axis.userMax = newMax;
                axis.isDirtyExtremes = true;
                if (redraw) {
                    chart.redraw(animation);
                }
            });
        },
        zoom: function(newMin, newMax) {
            if (!this.allowZoomOutside) {
                if (defined(this.dataMin) && newMin <= this.dataMin) {
                    newMin = UNDEFINED;
                }
                if (defined(this.dataMax) && newMax >= this.dataMax) {
                    newMax = UNDEFINED;
                }
            }
            this.displayBtn = newMin !== UNDEFINED || newMax !== UNDEFINED;
            this.setExtremes(newMin, newMax, false, UNDEFINED, {
                trigger: "zoom"
            });
            return true;
        },
        setAxisSize: function() {
            var chart = this.chart, options = this.options, offsetLeft = options.offsetLeft || 0, offsetRight = options.offsetRight || 0, horiz = this.horiz, width, height, top, left;
            this.left = left = pick(options.left, chart.plotLeft + offsetLeft);
            this.top = top = pick(options.top, chart.plotTop);
            this.width = width = pick(options.width, chart.plotWidth - offsetLeft + offsetRight);
            this.height = height = pick(options.height, chart.plotHeight);
            this.bottom = chart.chartHeight - height - top;
            this.right = chart.chartWidth - width - left;
            this.len = mathMax(horiz ? width : height, 0);
            this.pos = horiz ? left : top;
        },
        getExtremes: function() {
            var axis = this, isLog = axis.isLog;
            return {
                min: isLog ? correctFloat(lin2log(axis.min)) : axis.min,
                max: isLog ? correctFloat(lin2log(axis.max)) : axis.max,
                dataMin: axis.dataMin,
                dataMax: axis.dataMax,
                userMin: axis.userMin,
                userMax: axis.userMax
            };
        },
        getThreshold: function(threshold) {
            var axis = this, isLog = axis.isLog;
            var realMin = isLog ? lin2log(axis.min) : axis.min, realMax = isLog ? lin2log(axis.max) : axis.max;
            if (realMin > threshold || threshold === null) {
                threshold = realMin;
            } else if (realMax < threshold) {
                threshold = realMax;
            }
            return axis.translate(threshold, 0, 1, 0, 1);
        },
        addPlotBand: function(options) {
            this.addPlotBandOrLine(options, "plotBands");
        },
        addPlotLine: function(options) {
            this.addPlotBandOrLine(options, "plotLines");
        },
        addPlotBandOrLine: function(options, coll) {
            var obj = new PlotLineOrBand(this, options).render(), userOptions = this.userOptions;
            if (coll) {
                userOptions[coll] = userOptions[coll] || [];
                userOptions[coll].push(options);
            }
            this.plotLinesAndBands.push(obj);
            return obj;
        },
        autoLabelAlign: function(rotation) {
            var ret, angle = (pick(rotation, 0) - this.side * 90 + 720) % 360;
            if (angle > 15 && angle < 165) {
                ret = "right";
            } else if (angle > 195 && angle < 345) {
                ret = "left";
            } else {
                ret = "center";
            }
            return ret;
        },
        getOffset: function() {
            var axis = this, chart = axis.chart, renderer = chart.renderer, options = axis.options, tickPositions = axis.tickPositions, ticks = axis.ticks, horiz = axis.horiz, side = axis.side, invertedSide = chart.inverted ? [ 1, 0, 3, 2 ][side] : side, hasData, showAxis, titleOffset = 0, titleOffsetOption, titleMargin = 0, axisTitleOptions = options.title, labelOptions = options.labels, labelOffset = 0, axisOffset = chart.axisOffset, clipOffset = chart.clipOffset, directionFactor = [ -1, 1, 1, -1 ][side], n, i, autoStaggerLines = 1, maxStaggerLines = pick(labelOptions.maxStaggerLines, 5), sortedPositions, lastRight, overlap, pos, bBox, x, w, lineNo;
            axis.hasData = hasData = axis.hasVisibleSeries || defined(axis.min) && defined(axis.max) && !!tickPositions;
            axis.showAxis = showAxis = hasData || pick(options.showEmpty, true);
            axis.staggerLines = axis.horiz && labelOptions.staggerLines;
            if (!axis.axisGroup) {
                axis.gridGroup = renderer.g("grid").attr({
                    zIndex: options.gridZIndex || 1
                }).add();
                axis.axisGroup = renderer.g("axis").attr({
                    zIndex: options.zIndex || 2
                }).add();
                axis.labelGroup = renderer.g("axis-labels").attr({
                    zIndex: labelOptions.zIndex || 7
                }).add();
            }
            if (hasData || axis.isLinked) {
                axis.labelAlign = pick(labelOptions.align || axis.autoLabelAlign(labelOptions.rotation));
                each(tickPositions, function(pos) {
                    if (!ticks[pos]) {
                        ticks[pos] = new Tick(axis, pos);
                    } else {
                        ticks[pos].addLabel();
                    }
                });
                if (axis.horiz && !axis.staggerLines && maxStaggerLines && !labelOptions.rotation) {
                    sortedPositions = axis.reversed ? [].concat(tickPositions).reverse() : tickPositions;
                    while (autoStaggerLines < maxStaggerLines) {
                        lastRight = [];
                        overlap = false;
                        for (i = 0; i < sortedPositions.length; i++) {
                            pos = sortedPositions[i];
                            bBox = ticks[pos].label && ticks[pos].label.bBox;
                            w = bBox ? bBox.width : 0;
                            lineNo = i % autoStaggerLines;
                            if (w) {
                                x = axis.translate(pos);
                                if (lastRight[lineNo] !== UNDEFINED && x < lastRight[lineNo]) {
                                    overlap = true;
                                }
                                lastRight[lineNo] = x + w;
                            }
                        }
                        if (overlap) {
                            autoStaggerLines++;
                        } else {
                            break;
                        }
                    }
                    if (autoStaggerLines > 1) {
                        axis.staggerLines = autoStaggerLines;
                    }
                }
                each(tickPositions, function(pos) {
                    if (side === 0 || side === 2 || {
                        1: "left",
                        3: "right"
                    }[side] === axis.labelAlign) {
                        labelOffset = mathMax(ticks[pos].getLabelSize(), labelOffset);
                    }
                });
                if (axis.staggerLines) {
                    labelOffset *= axis.staggerLines;
                    axis.labelOffset = labelOffset;
                }
            } else {
                for (n in ticks) {
                    ticks[n].destroy();
                    delete ticks[n];
                }
            }
            if (axisTitleOptions && axisTitleOptions.text && axisTitleOptions.enabled !== false) {
                if (!axis.axisTitle) {
                    axis.axisTitle = renderer.text(axisTitleOptions.text, 0, 0, axisTitleOptions.useHTML).attr({
                        zIndex: 7,
                        rotation: axisTitleOptions.rotation || 0,
                        align: axisTitleOptions.textAlign || {
                            low: "left",
                            middle: "center",
                            high: "right"
                        }[axisTitleOptions.align]
                    }).css(axisTitleOptions.style).add(axis.axisGroup);
                    axis.axisTitle.isNew = true;
                }
                if (showAxis) {
                    titleOffset = axis.axisTitle.getBBox()[horiz ? "height" : "width"];
                    titleMargin = pick(axisTitleOptions.margin, horiz ? 5 : 10);
                    titleOffsetOption = axisTitleOptions.offset;
                }
                axis.axisTitle[showAxis ? "show" : "hide"]();
            }
            axis.offset = directionFactor * pick(options.offset, axisOffset[side]);
            axis.axisTitleMargin = pick(titleOffsetOption, labelOffset + titleMargin + (side !== 2 && labelOffset && directionFactor * options.labels[horiz ? "y" : "x"]));
            axisOffset[side] = mathMax(axisOffset[side], axis.axisTitleMargin + titleOffset + directionFactor * axis.offset);
            clipOffset[invertedSide] = mathMax(clipOffset[invertedSide], mathFloor(options.lineWidth / 2) * 2);
        },
        getLinePath: function(lineWidth) {
            var chart = this.chart, opposite = this.opposite, offset = this.offset, horiz = this.horiz, lineLeft = this.left + (opposite ? this.width : 0) + offset, lineTop = chart.chartHeight - this.bottom - (opposite ? this.height : 0) + offset;
            this.lineTop = lineTop;
            if (opposite) {
                lineWidth *= -1;
            }
            return chart.renderer.crispLine([ M, horiz ? this.left : lineLeft, horiz ? lineTop : this.top, L, horiz ? chart.chartWidth - this.right : lineLeft, horiz ? lineTop : chart.chartHeight - this.bottom ], lineWidth);
        },
        getTitlePosition: function() {
            var horiz = this.horiz, axisLeft = this.left, axisTop = this.top, axisLength = this.len, axisTitleOptions = this.options.title, margin = horiz ? axisLeft : axisTop, opposite = this.opposite, offset = this.offset, fontSize = pInt(axisTitleOptions.style.fontSize || 12), alongAxis = {
                low: margin + (horiz ? 0 : axisLength),
                middle: margin + axisLength / 2,
                high: margin + (horiz ? axisLength : 0)
            }[axisTitleOptions.align], offAxis = (horiz ? axisTop + this.height : axisLeft) + (horiz ? 1 : -1) * (opposite ? -1 : 1) * this.axisTitleMargin + (this.side === 2 ? fontSize : 0);
            return {
                x: horiz ? alongAxis : offAxis + (opposite ? this.width : 0) + offset + (axisTitleOptions.x || 0),
                y: horiz ? offAxis - (opposite ? this.height : 0) + offset : alongAxis + (axisTitleOptions.y || 0)
            };
        },
        render: function() {
            var axis = this, chart = axis.chart, renderer = chart.renderer, options = axis.options, isLog = axis.isLog, isLinked = axis.isLinked, tickPositions = axis.tickPositions, axisTitle = axis.axisTitle, stacks = axis.stacks, ticks = axis.ticks, minorTicks = axis.minorTicks, alternateBands = axis.alternateBands, stackLabelOptions = options.stackLabels, alternateGridColor = options.alternateGridColor, tickmarkOffset = axis.tickmarkOffset, lineWidth = options.lineWidth, linePath, hasRendered = chart.hasRendered, slideInTicks = hasRendered && defined(axis.oldMin) && !isNaN(axis.oldMin), hasData = axis.hasData, showAxis = axis.showAxis, from, to;
            each([ ticks, minorTicks, alternateBands ], function(coll) {
                var pos;
                for (pos in coll) {
                    coll[pos].isActive = false;
                }
            });
            if (hasData || isLinked) {
                if (axis.minorTickInterval && !axis.categories) {
                    each(axis.getMinorTickPositions(), function(pos) {
                        if (!minorTicks[pos]) {
                            minorTicks[pos] = new Tick(axis, pos, "minor");
                        }
                        if (slideInTicks && minorTicks[pos].isNew) {
                            minorTicks[pos].render(null, true);
                        }
                        minorTicks[pos].render(null, false, 1);
                    });
                }
                if (tickPositions.length) {
                    each(tickPositions.slice(1).concat([ tickPositions[0] ]), function(pos, i) {
                        i = i === tickPositions.length - 1 ? 0 : i + 1;
                        if (!isLinked || pos >= axis.min && pos <= axis.max) {
                            if (!ticks[pos]) {
                                ticks[pos] = new Tick(axis, pos);
                            }
                            if (slideInTicks && ticks[pos].isNew) {
                                ticks[pos].render(i, true);
                            }
                            ticks[pos].render(i, false, 1);
                        }
                    });
                    if (tickmarkOffset && axis.min === 0) {
                        if (!ticks[-1]) {
                            ticks[-1] = new Tick(axis, -1, null, true);
                        }
                        ticks[-1].render(-1);
                    }
                }
                if (alternateGridColor) {
                    each(tickPositions, function(pos, i) {
                        if (i % 2 === 0 && pos < axis.max) {
                            if (!alternateBands[pos]) {
                                alternateBands[pos] = new PlotLineOrBand(axis);
                            }
                            from = pos + tickmarkOffset;
                            to = tickPositions[i + 1] !== UNDEFINED ? tickPositions[i + 1] + tickmarkOffset : axis.max;
                            alternateBands[pos].options = {
                                from: isLog ? lin2log(from) : from,
                                to: isLog ? lin2log(to) : to,
                                color: alternateGridColor
                            };
                            alternateBands[pos].render();
                            alternateBands[pos].isActive = true;
                        }
                    });
                }
                if (!axis._addedPlotLB) {
                    each((options.plotLines || []).concat(options.plotBands || []), function(plotLineOptions) {
                        axis.addPlotBandOrLine(plotLineOptions);
                    });
                    axis._addedPlotLB = true;
                }
            }
            each([ ticks, minorTicks, alternateBands ], function(coll) {
                var pos, i, forDestruction = [], delay = globalAnimation ? globalAnimation.duration || 500 : 0, destroyInactiveItems = function() {
                    i = forDestruction.length;
                    while (i--) {
                        if (coll[forDestruction[i]] && !coll[forDestruction[i]].isActive) {
                            coll[forDestruction[i]].destroy();
                            delete coll[forDestruction[i]];
                        }
                    }
                };
                for (pos in coll) {
                    if (!coll[pos].isActive) {
                        coll[pos].render(pos, false, 0);
                        coll[pos].isActive = false;
                        forDestruction.push(pos);
                    }
                }
                if (coll === alternateBands || !chart.hasRendered || !delay) {
                    destroyInactiveItems();
                } else if (delay) {
                    setTimeout(destroyInactiveItems, delay);
                }
            });
            if (lineWidth) {
                linePath = axis.getLinePath(lineWidth);
                if (!axis.axisLine) {
                    axis.axisLine = renderer.path(linePath).attr({
                        stroke: options.lineColor,
                        "stroke-width": lineWidth,
                        zIndex: 7
                    }).add(axis.axisGroup);
                } else {
                    axis.axisLine.animate({
                        d: linePath
                    });
                }
                axis.axisLine[showAxis ? "show" : "hide"]();
            }
            if (axisTitle && showAxis) {
                axisTitle[axisTitle.isNew ? "attr" : "animate"](axis.getTitlePosition());
                axisTitle.isNew = false;
            }
            if (stackLabelOptions && stackLabelOptions.enabled) {
                var stackKey, oneStack, stackCategory, stackTotalGroup = axis.stackTotalGroup;
                if (!stackTotalGroup) {
                    axis.stackTotalGroup = stackTotalGroup = renderer.g("stack-labels").attr({
                        visibility: VISIBLE,
                        zIndex: 6
                    }).add();
                }
                stackTotalGroup.translate(chart.plotLeft, chart.plotTop);
                for (stackKey in stacks) {
                    oneStack = stacks[stackKey];
                    for (stackCategory in oneStack) {
                        oneStack[stackCategory].render(stackTotalGroup);
                    }
                }
            }
            axis.isDirty = false;
        },
        removePlotBandOrLine: function(id) {
            var plotLinesAndBands = this.plotLinesAndBands, options = this.options, userOptions = this.userOptions, i = plotLinesAndBands.length;
            while (i--) {
                if (plotLinesAndBands[i].id === id) {
                    plotLinesAndBands[i].destroy();
                }
            }
            each([ options.plotLines || [], userOptions.plotLines || [], options.plotBands || [], userOptions.plotBands || [] ], function(arr) {
                i = arr.length;
                while (i--) {
                    if (arr[i].id === id) {
                        erase(arr, arr[i]);
                    }
                }
            });
        },
        setTitle: function(newTitleOptions, redraw) {
            this.update({
                title: newTitleOptions
            }, redraw);
        },
        redraw: function() {
            var axis = this, chart = axis.chart, pointer = chart.pointer;
            if (pointer.reset) {
                pointer.reset(true);
            }
            axis.render();
            each(axis.plotLinesAndBands, function(plotLine) {
                plotLine.render();
            });
            each(axis.series, function(series) {
                series.isDirty = true;
            });
        },
        buildStacks: function() {
            if (this.isXAxis) {
                return;
            }
            each(this.series, function(series) {
                series.setStackedPoints();
            });
        },
        setCategories: function(categories, redraw) {
            this.update({
                categories: categories
            }, redraw);
        },
        destroy: function(keepEvents) {
            var axis = this, stacks = axis.stacks, stackKey, plotLinesAndBands = axis.plotLinesAndBands, i;
            if (!keepEvents) {
                removeEvent(axis);
            }
            for (stackKey in stacks) {
                destroyObjectProperties(stacks[stackKey]);
                stacks[stackKey] = null;
            }
            each([ axis.ticks, axis.minorTicks, axis.alternateBands ], function(coll) {
                destroyObjectProperties(coll);
            });
            i = plotLinesAndBands.length;
            while (i--) {
                plotLinesAndBands[i].destroy();
            }
            each([ "stackTotalGroup", "axisLine", "axisGroup", "gridGroup", "labelGroup", "axisTitle" ], function(prop) {
                if (axis[prop]) {
                    axis[prop] = axis[prop].destroy();
                }
            });
        }
    };
    function Tooltip() {
        this.init.apply(this, arguments);
    }
    Tooltip.prototype = {
        init: function(chart, options) {
            var borderWidth = options.borderWidth, style = options.style, padding = pInt(style.padding);
            this.chart = chart;
            this.options = options;
            this.crosshairs = [];
            this.now = {
                x: 0,
                y: 0
            };
            this.isHidden = true;
            this.label = chart.renderer.label("", 0, 0, options.shape, null, null, options.useHTML, null, "tooltip").attr({
                padding: padding,
                fill: options.backgroundColor,
                "stroke-width": borderWidth,
                r: options.borderRadius,
                zIndex: 8
            }).css(style).css({
                padding: 0
            }).hide().add();
            if (!useCanVG) {
                this.label.shadow(options.shadow);
            }
            this.shared = options.shared;
        },
        destroy: function() {
            each(this.crosshairs, function(crosshair) {
                if (crosshair) {
                    crosshair.destroy();
                }
            });
            if (this.label) {
                this.label = this.label.destroy();
            }
            clearTimeout(this.hideTimer);
            clearTimeout(this.tooltipTimeout);
        },
        move: function(x, y, anchorX, anchorY) {
            var tooltip = this, now = tooltip.now, animate = tooltip.options.animation !== false && !tooltip.isHidden;
            extend(now, {
                x: animate ? (2 * now.x + x) / 3 : x,
                y: animate ? (now.y + y) / 2 : y,
                anchorX: animate ? (2 * now.anchorX + anchorX) / 3 : anchorX,
                anchorY: animate ? (now.anchorY + anchorY) / 2 : anchorY
            });
            tooltip.label.attr(now);
            if (animate && (mathAbs(x - now.x) > 1 || mathAbs(y - now.y) > 1)) {
                clearTimeout(this.tooltipTimeout);
                this.tooltipTimeout = setTimeout(function() {
                    if (tooltip) {
                        tooltip.move(x, y, anchorX, anchorY);
                    }
                }, 32);
            }
        },
        hide: function() {
            var tooltip = this, hoverPoints;
            clearTimeout(this.hideTimer);
            if (!this.isHidden) {
                hoverPoints = this.chart.hoverPoints;
                this.hideTimer = setTimeout(function() {
                    tooltip.label.fadeOut();
                    tooltip.isHidden = true;
                }, pick(this.options.hideDelay, 500));
                if (hoverPoints) {
                    each(hoverPoints, function(point) {
                        point.setState();
                    });
                }
                this.chart.hoverPoints = null;
            }
        },
        hideCrosshairs: function() {
            each(this.crosshairs, function(crosshair) {
                if (crosshair) {
                    crosshair.hide();
                }
            });
        },
        getAnchor: function(points, mouseEvent) {
            var ret, chart = this.chart, inverted = chart.inverted, plotTop = chart.plotTop, plotX = 0, plotY = 0, yAxis;
            points = splat(points);
            ret = points[0].tooltipPos;
            if (this.followPointer && mouseEvent) {
                if (mouseEvent.chartX === UNDEFINED) {
                    mouseEvent = chart.pointer.normalize(mouseEvent);
                }
                ret = [ mouseEvent.chartX - chart.plotLeft, mouseEvent.chartY - plotTop ];
            }
            if (!ret) {
                each(points, function(point) {
                    yAxis = point.series.yAxis;
                    plotX += point.plotX;
                    plotY += (point.plotLow ? (point.plotLow + point.plotHigh) / 2 : point.plotY) + (!inverted && yAxis ? yAxis.top - plotTop : 0);
                });
                plotX /= points.length;
                plotY /= points.length;
                ret = [ inverted ? chart.plotWidth - plotY : plotX, this.shared && !inverted && points.length > 1 && mouseEvent ? mouseEvent.chartY - plotTop : inverted ? chart.plotHeight - plotX : plotY ];
            }
            return map(ret, mathRound);
        },
        getPosition: function(boxWidth, boxHeight, point) {
            var chart = this.chart, plotLeft = chart.plotLeft, plotTop = chart.plotTop, plotWidth = chart.plotWidth, plotHeight = chart.plotHeight, distance = pick(this.options.distance, 12), pointX = point.plotX, pointY = point.plotY, x = pointX + plotLeft + (chart.inverted ? distance : -boxWidth - distance), y = pointY - boxHeight + plotTop + 15, alignedRight;
            if (x < 7) {
                x = plotLeft + mathMax(pointX, 0) + distance;
            }
            if (x + boxWidth > plotLeft + plotWidth) {
                x -= x + boxWidth - (plotLeft + plotWidth);
                y = pointY - boxHeight + plotTop - distance;
                alignedRight = true;
            }
            if (y < plotTop + 5) {
                y = plotTop + 5;
                if (alignedRight && pointY >= y && pointY <= y + boxHeight) {
                    y = pointY + plotTop + distance;
                }
            }
            if (y + boxHeight > plotTop + plotHeight) {
                y = mathMax(plotTop, plotTop + plotHeight - boxHeight - distance);
            }
            return {
                x: x,
                y: y
            };
        },
        defaultFormatter: function(tooltip) {
            var items = this.points || splat(this), series = items[0].series, s;
            s = [ series.tooltipHeaderFormatter(items[0]) ];
            each(items, function(item) {
                series = item.series;
                s.push(series.tooltipFormatter && series.tooltipFormatter(item) || item.point.tooltipFormatter(series.tooltipOptions.pointFormat));
            });
            s.push(tooltip.options.footerFormat || "");
            return s.join("");
        },
        refresh: function(point, mouseEvent) {
            var tooltip = this, chart = tooltip.chart, label = tooltip.label, options = tooltip.options, x, y, anchor, textConfig = {}, text, pointConfig = [], formatter = options.formatter || tooltip.defaultFormatter, hoverPoints = chart.hoverPoints, borderColor, crosshairsOptions = options.crosshairs, shared = tooltip.shared, currentSeries;
            clearTimeout(this.hideTimer);
            tooltip.followPointer = splat(point)[0].series.tooltipOptions.followPointer;
            anchor = tooltip.getAnchor(point, mouseEvent);
            x = anchor[0];
            y = anchor[1];
            if (shared && !(point.series && point.series.noSharedTooltip)) {
                chart.hoverPoints = point;
                if (hoverPoints) {
                    each(hoverPoints, function(point) {
                        point.setState();
                    });
                }
                each(point, function(item) {
                    item.setState(HOVER_STATE);
                    pointConfig.push(item.getLabelConfig());
                });
                textConfig = {
                    x: point[0].category,
                    y: point[0].y
                };
                textConfig.points = pointConfig;
                point = point[0];
            } else {
                textConfig = point.getLabelConfig();
            }
            text = formatter.call(textConfig, tooltip);
            currentSeries = point.series;
            if (text === false) {
                this.hide();
            } else {
                if (tooltip.isHidden) {
                    stop(label);
                    label.attr("opacity", 1).show();
                }
                label.attr({
                    text: text
                });
                borderColor = options.borderColor || point.color || currentSeries.color || "#606060";
                label.attr({
                    stroke: borderColor
                });
                tooltip.updatePosition({
                    plotX: x,
                    plotY: y
                });
                this.isHidden = false;
            }
            if (crosshairsOptions) {
                crosshairsOptions = splat(crosshairsOptions);
                var path, i = crosshairsOptions.length, attribs, axis, val, series;
                while (i--) {
                    series = point.series;
                    axis = series[i ? "yAxis" : "xAxis"];
                    if (crosshairsOptions[i] && axis) {
                        val = i ? pick(point.stackY, point.y) : point.x;
                        if (axis.isLog) {
                            val = log2lin(val);
                        }
                        if (series.modifyValue) {
                            val = series.modifyValue(val);
                        }
                        path = axis.getPlotLinePath(val, 1);
                        if (tooltip.crosshairs[i]) {
                            tooltip.crosshairs[i].attr({
                                d: path,
                                visibility: VISIBLE
                            });
                        } else {
                            attribs = {
                                "stroke-width": crosshairsOptions[i].width || 1,
                                stroke: crosshairsOptions[i].color || "#C0C0C0",
                                zIndex: crosshairsOptions[i].zIndex || 2
                            };
                            if (crosshairsOptions[i].dashStyle) {
                                attribs.dashstyle = crosshairsOptions[i].dashStyle;
                            }
                            tooltip.crosshairs[i] = chart.renderer.path(path).attr(attribs).add();
                        }
                    }
                }
            }
            fireEvent(chart, "tooltipRefresh", {
                text: text,
                x: x + chart.plotLeft,
                y: y + chart.plotTop,
                borderColor: borderColor
            });
        },
        updatePosition: function(point) {
            var chart = this.chart, label = this.label, pos = (this.options.positioner || this.getPosition).call(this, label.width, label.height, point);
            this.move(mathRound(pos.x), mathRound(pos.y), point.plotX + chart.plotLeft, point.plotY + chart.plotTop);
        }
    };
    function Pointer(chart, options) {
        this.init(chart, options);
    }
    Pointer.prototype = {
        init: function(chart, options) {
            var zoomType = useCanVG ? "" : options.chart.zoomType, inverted = chart.inverted, zoomX, zoomY;
            this.options = options;
            this.chart = chart;
            this.zoomX = zoomX = /x/.test(zoomType);
            this.zoomY = zoomY = /y/.test(zoomType);
            this.zoomHor = zoomX && !inverted || zoomY && inverted;
            this.zoomVert = zoomY && !inverted || zoomX && inverted;
            this.pinchDown = [];
            this.lastValidTouch = {};
            if (options.tooltip.enabled) {
                chart.tooltip = new Tooltip(chart, options.tooltip);
            }
            this.setDOMEvents();
        },
        normalize: function(e) {
            var chartPosition, chartX, chartY, ePos;
            e = e || win.event;
            if (!e.target) {
                e.target = e.srcElement;
            }
            e = washMouseEvent(e);
            ePos = e.touches ? e.touches.item(0) : e;
            this.chartPosition = chartPosition = offset(this.chart.container);
            if (ePos.pageX === UNDEFINED) {
                chartX = mathMax(e.x, e.clientX - chartPosition.left);
                chartY = e.y;
            } else {
                chartX = ePos.pageX - chartPosition.left;
                chartY = ePos.pageY - chartPosition.top;
            }
            return extend(e, {
                chartX: mathRound(chartX),
                chartY: mathRound(chartY)
            });
        },
        getCoordinates: function(e) {
            var coordinates = {
                xAxis: [],
                yAxis: []
            };
            each(this.chart.axes, function(axis) {
                coordinates[axis.isXAxis ? "xAxis" : "yAxis"].push({
                    axis: axis,
                    value: axis.toValue(e[axis.horiz ? "chartX" : "chartY"])
                });
            });
            return coordinates;
        },
        getIndex: function(e) {
            var chart = this.chart;
            return chart.inverted ? chart.plotHeight + chart.plotTop - e.chartY : e.chartX - chart.plotLeft;
        },
        runPointActions: function(e) {
            var pointer = this, chart = pointer.chart, series = chart.series, tooltip = chart.tooltip, point, points, hoverPoint = chart.hoverPoint, hoverSeries = chart.hoverSeries, i, j, distance = chart.chartWidth, index = pointer.getIndex(e), anchor;
            if (tooltip && pointer.options.tooltip.shared && !(hoverSeries && hoverSeries.noSharedTooltip)) {
                points = [];
                i = series.length;
                for (j = 0; j < i; j++) {
                    if (series[j].visible && series[j].options.enableMouseTracking !== false && !series[j].noSharedTooltip && series[j].tooltipPoints.length) {
                        point = series[j].tooltipPoints[index];
                        if (point.series) {
                            point._dist = mathAbs(index - point.clientX);
                            distance = mathMin(distance, point._dist);
                            points.push(point);
                        }
                    }
                }
                i = points.length;
                while (i--) {
                    if (points[i]._dist > distance) {
                        points.splice(i, 1);
                    }
                }
                if (points.length && points[0].clientX !== pointer.hoverX) {
                    tooltip.refresh(points, e);
                    pointer.hoverX = points[0].clientX;
                }
            }
            if (hoverSeries && hoverSeries.tracker) {
                point = hoverSeries.tooltipPoints[index];
                if (point && point !== hoverPoint) {
                    point.onMouseOver(e);
                }
            } else if (tooltip && tooltip.followPointer && !tooltip.isHidden) {
                anchor = tooltip.getAnchor([ {} ], e);
                tooltip.updatePosition({
                    plotX: anchor[0],
                    plotY: anchor[1]
                });
            }
        },
        reset: function(allowMove) {
            var pointer = this, chart = pointer.chart, hoverSeries = chart.hoverSeries, hoverPoint = chart.hoverPoint, tooltip = chart.tooltip, tooltipPoints = tooltip && tooltip.shared ? chart.hoverPoints : hoverPoint;
            allowMove = allowMove && tooltip && tooltipPoints;
            if (allowMove && splat(tooltipPoints)[0].plotX === UNDEFINED) {
                allowMove = false;
            }
            if (allowMove) {
                tooltip.refresh(tooltipPoints);
            } else {
                if (hoverPoint) {
                    hoverPoint.onMouseOut();
                }
                if (hoverSeries) {
                    hoverSeries.onMouseOut();
                }
                if (tooltip) {
                    tooltip.hide();
                    tooltip.hideCrosshairs();
                }
                pointer.hoverX = null;
            }
        },
        scaleGroups: function(attribs, clip) {
            var chart = this.chart, seriesAttribs;
            each(chart.series, function(series) {
                seriesAttribs = attribs || series.getPlotBox();
                if (series.xAxis && series.xAxis.zoomEnabled) {
                    series.group.attr(seriesAttribs);
                    if (series.markerGroup) {
                        series.markerGroup.attr(seriesAttribs);
                        series.markerGroup.clip(clip ? chart.clipRect : null);
                    }
                    if (series.dataLabelsGroup) {
                        series.dataLabelsGroup.attr(seriesAttribs);
                    }
                }
            });
            chart.clipRect.attr(clip || chart.clipBox);
        },
        pinchTranslateDirection: function(horiz, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch) {
            var chart = this.chart, xy = horiz ? "x" : "y", XY = horiz ? "X" : "Y", sChartXY = "chart" + XY, wh = horiz ? "width" : "height", plotLeftTop = chart["plot" + (horiz ? "Left" : "Top")], selectionWH, selectionXY, clipXY, scale = 1, inverted = chart.inverted, bounds = chart.bounds[horiz ? "h" : "v"], singleTouch = pinchDown.length === 1, touch0Start = pinchDown[0][sChartXY], touch0Now = touches[0][sChartXY], touch1Start = !singleTouch && pinchDown[1][sChartXY], touch1Now = !singleTouch && touches[1][sChartXY], outOfBounds, transformScale, scaleKey, setScale = function() {
                if (!singleTouch && mathAbs(touch0Start - touch1Start) > 20) {
                    scale = mathAbs(touch0Now - touch1Now) / mathAbs(touch0Start - touch1Start);
                }
                clipXY = (plotLeftTop - touch0Now) / scale + touch0Start;
                selectionWH = chart["plot" + (horiz ? "Width" : "Height")] / scale;
            };
            setScale();
            selectionXY = clipXY;
            if (selectionXY < bounds.min) {
                selectionXY = bounds.min;
                outOfBounds = true;
            } else if (selectionXY + selectionWH > bounds.max) {
                selectionXY = bounds.max - selectionWH;
                outOfBounds = true;
            }
            if (outOfBounds) {
                touch0Now -= .8 * (touch0Now - lastValidTouch[xy][0]);
                if (!singleTouch) {
                    touch1Now -= .8 * (touch1Now - lastValidTouch[xy][1]);
                }
                setScale();
            } else {
                lastValidTouch[xy] = [ touch0Now, touch1Now ];
            }
            if (!inverted) {
                clip[xy] = clipXY - plotLeftTop;
                clip[wh] = selectionWH;
            }
            scaleKey = inverted ? horiz ? "scaleY" : "scaleX" : "scale" + XY;
            transformScale = inverted ? 1 / scale : scale;
            selectionMarker[wh] = selectionWH;
            selectionMarker[xy] = selectionXY;
            transform[scaleKey] = scale;
            transform["translate" + XY] = transformScale * plotLeftTop + (touch0Now - transformScale * touch0Start);
        },
        pinch: function(e) {
            var self = this, chart = self.chart, pinchDown = self.pinchDown, followTouchMove = chart.tooltip && chart.tooltip.options.followTouchMove, touches = e.touches, touchesLength = touches.length, lastValidTouch = self.lastValidTouch, zoomHor = self.zoomHor || self.pinchHor, zoomVert = self.zoomVert || self.pinchVert, hasZoom = zoomHor || zoomVert, selectionMarker = self.selectionMarker, transform = {}, clip = {};
            if (followTouchMove || hasZoom) {
                e.preventDefault();
            }
            map(touches, function(e) {
                return self.normalize(e);
            });
            if (e.type === "touchstart") {
                each(touches, function(e, i) {
                    pinchDown[i] = {
                        chartX: e.chartX,
                        chartY: e.chartY
                    };
                });
                lastValidTouch.x = [ pinchDown[0].chartX, pinchDown[1] && pinchDown[1].chartX ];
                lastValidTouch.y = [ pinchDown[0].chartY, pinchDown[1] && pinchDown[1].chartY ];
                each(chart.axes, function(axis) {
                    if (axis.zoomEnabled) {
                        var bounds = chart.bounds[axis.horiz ? "h" : "v"], minPixelPadding = axis.minPixelPadding, min = axis.toPixels(axis.dataMin), max = axis.toPixels(axis.dataMax), absMin = mathMin(min, max), absMax = mathMax(min, max);
                        bounds.min = mathMin(axis.pos, absMin - minPixelPadding);
                        bounds.max = mathMax(axis.pos + axis.len, absMax + minPixelPadding);
                    }
                });
            } else if (pinchDown.length) {
                if (!selectionMarker) {
                    self.selectionMarker = selectionMarker = extend({
                        destroy: noop
                    }, chart.plotBox);
                }
                if (zoomHor) {
                    self.pinchTranslateDirection(true, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);
                }
                if (zoomVert) {
                    self.pinchTranslateDirection(false, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);
                }
                self.hasPinched = hasZoom;
                self.scaleGroups(transform, clip);
                if (!hasZoom && followTouchMove && touchesLength === 1) {
                    this.runPointActions(self.normalize(e));
                }
            }
        },
        dragStart: function(e) {
            var chart = this.chart;
            chart.mouseIsDown = e.type;
            chart.cancelClick = false;
            chart.mouseDownX = this.mouseDownX = e.chartX;
            chart.mouseDownY = this.mouseDownY = e.chartY;
        },
        drag: function(e) {
            var chart = this.chart, chartOptions = chart.options.chart, chartX = e.chartX, chartY = e.chartY, zoomHor = this.zoomHor, zoomVert = this.zoomVert, plotLeft = chart.plotLeft, plotTop = chart.plotTop, plotWidth = chart.plotWidth, plotHeight = chart.plotHeight, clickedInside, size, mouseDownX = this.mouseDownX, mouseDownY = this.mouseDownY;
            if (chartX < plotLeft) {
                chartX = plotLeft;
            } else if (chartX > plotLeft + plotWidth) {
                chartX = plotLeft + plotWidth;
            }
            if (chartY < plotTop) {
                chartY = plotTop;
            } else if (chartY > plotTop + plotHeight) {
                chartY = plotTop + plotHeight;
            }
            this.hasDragged = Math.sqrt(Math.pow(mouseDownX - chartX, 2) + Math.pow(mouseDownY - chartY, 2));
            if (this.hasDragged > 10) {
                clickedInside = chart.isInsidePlot(mouseDownX - plotLeft, mouseDownY - plotTop);
                if (chart.hasCartesianSeries && (this.zoomX || this.zoomY) && clickedInside) {
                    if (!this.selectionMarker) {
                        this.selectionMarker = chart.renderer.rect(plotLeft, plotTop, zoomHor ? 1 : plotWidth, zoomVert ? 1 : plotHeight, 0).attr({
                            fill: chartOptions.selectionMarkerFill || "rgba(69,114,167,0.25)",
                            zIndex: 7
                        }).add();
                    }
                }
                if (this.selectionMarker && zoomHor) {
                    size = chartX - mouseDownX;
                    this.selectionMarker.attr({
                        width: mathAbs(size),
                        x: (size > 0 ? 0 : size) + mouseDownX
                    });
                }
                if (this.selectionMarker && zoomVert) {
                    size = chartY - mouseDownY;
                    this.selectionMarker.attr({
                        height: mathAbs(size),
                        y: (size > 0 ? 0 : size) + mouseDownY
                    });
                }
                if (clickedInside && !this.selectionMarker && chartOptions.panning) {
                    chart.pan(e, chartOptions.panning);
                }
            }
        },
        drop: function(e) {
            var chart = this.chart, hasPinched = this.hasPinched;
            if (this.selectionMarker) {
                var selectionData = {
                    xAxis: [],
                    yAxis: [],
                    originalEvent: e.originalEvent || e
                }, selectionBox = this.selectionMarker, selectionLeft = selectionBox.x, selectionTop = selectionBox.y, runZoom;
                if (this.hasDragged || hasPinched) {
                    each(chart.axes, function(axis) {
                        if (axis.zoomEnabled) {
                            var horiz = axis.horiz, selectionMin = axis.toValue(horiz ? selectionLeft : selectionTop), selectionMax = axis.toValue(horiz ? selectionLeft + selectionBox.width : selectionTop + selectionBox.height);
                            if (!isNaN(selectionMin) && !isNaN(selectionMax)) {
                                selectionData[axis.xOrY + "Axis"].push({
                                    axis: axis,
                                    min: mathMin(selectionMin, selectionMax),
                                    max: mathMax(selectionMin, selectionMax)
                                });
                                runZoom = true;
                            }
                        }
                    });
                    if (runZoom) {
                        fireEvent(chart, "selection", selectionData, function(args) {
                            chart.zoom(extend(args, hasPinched ? {
                                animation: false
                            } : null));
                        });
                    }
                }
                this.selectionMarker = this.selectionMarker.destroy();
                if (hasPinched) {
                    this.scaleGroups();
                }
            }
            if (chart) {
                css(chart.container, {
                    cursor: chart._cursor
                });
                chart.cancelClick = this.hasDragged > 10;
                chart.mouseIsDown = this.hasDragged = this.hasPinched = false;
                this.pinchDown = [];
            }
        },
        onContainerMouseDown: function(e) {
            e = this.normalize(e);
            if (e.preventDefault) {
                e.preventDefault();
            }
            this.dragStart(e);
        },
        onDocumentMouseUp: function(e) {
            this.drop(e);
        },
        onDocumentMouseMove: function(e) {
            var chart = this.chart, chartPosition = this.chartPosition, hoverSeries = chart.hoverSeries;
            e = washMouseEvent(e);
            if (chartPosition && hoverSeries && !this.inClass(e.target, "highcharts-tracker") && !chart.isInsidePlot(e.pageX - chartPosition.left - chart.plotLeft, e.pageY - chartPosition.top - chart.plotTop)) {
                this.reset();
            }
        },
        onContainerMouseLeave: function() {
            this.reset();
            this.chartPosition = null;
        },
        onContainerMouseMove: function(e) {
            var chart = this.chart;
            e = this.normalize(e);
            e.returnValue = false;
            if (chart.mouseIsDown === "mousedown") {
                this.drag(e);
            }
            if ((this.inClass(e.target, "highcharts-tracker") || chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) && !chart.openMenu) {
                this.runPointActions(e);
            }
        },
        inClass: function(element, className) {
            var elemClassName;
            while (element) {
                elemClassName = attr(element, "class");
                if (elemClassName) {
                    if (elemClassName.indexOf(className) !== -1) {
                        return true;
                    } else if (elemClassName.indexOf(PREFIX + "container") !== -1) {
                        return false;
                    }
                }
                element = element.parentNode;
            }
        },
        onTrackerMouseOut: function(e) {
            var series = this.chart.hoverSeries;
            if (series && !series.options.stickyTracking && !this.inClass(e.toElement || e.relatedTarget, PREFIX + "tooltip")) {
                series.onMouseOut();
            }
        },
        onContainerClick: function(e) {
            var chart = this.chart, hoverPoint = chart.hoverPoint, plotLeft = chart.plotLeft, plotTop = chart.plotTop, inverted = chart.inverted, chartPosition, plotX, plotY;
            e = this.normalize(e);
            e.cancelBubble = true;
            if (!chart.cancelClick) {
                if (hoverPoint && this.inClass(e.target, PREFIX + "tracker")) {
                    chartPosition = this.chartPosition;
                    plotX = hoverPoint.plotX;
                    plotY = hoverPoint.plotY;
                    extend(hoverPoint, {
                        pageX: chartPosition.left + plotLeft + (inverted ? chart.plotWidth - plotY : plotX),
                        pageY: chartPosition.top + plotTop + (inverted ? chart.plotHeight - plotX : plotY)
                    });
                    fireEvent(hoverPoint.series, "click", extend(e, {
                        point: hoverPoint
                    }));
                    if (chart.hoverPoint) {
                        hoverPoint.firePointEvent("click", e);
                    }
                } else {
                    extend(e, this.getCoordinates(e));
                    if (chart.isInsidePlot(e.chartX - plotLeft, e.chartY - plotTop)) {
                        fireEvent(chart, "click", e);
                    }
                }
            }
        },
        onContainerTouchStart: function(e) {
            var chart = this.chart;
            if (e.touches.length === 1) {
                e = this.normalize(e);
                if (chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) {
                    this.runPointActions(e);
                    this.pinch(e);
                } else {
                    this.reset();
                }
            } else if (e.touches.length === 2) {
                this.pinch(e);
            }
        },
        onContainerTouchMove: function(e) {
            if (e.touches.length === 1 || e.touches.length === 2) {
                this.pinch(e);
            }
        },
        onDocumentTouchEnd: function(e) {
            this.drop(e);
        },
        setDOMEvents: function() {
            var pointer = this, container = pointer.chart.container, events;
            this._events = events = [ [ container, "onmousedown", "onContainerMouseDown" ], [ container, "onmousemove", "onContainerMouseMove" ], [ container, "onclick", "onContainerClick" ], [ container, "mouseleave", "onContainerMouseLeave" ], [ doc, "mousemove", "onDocumentMouseMove" ], [ doc, "mouseup", "onDocumentMouseUp" ] ];
            if (hasTouch) {
                events.push([ container, "ontouchstart", "onContainerTouchStart" ], [ container, "ontouchmove", "onContainerTouchMove" ], [ doc, "touchend", "onDocumentTouchEnd" ]);
            }
            each(events, function(eventConfig) {
                pointer["_" + eventConfig[2]] = function(e) {
                    pointer[eventConfig[2]](e);
                };
                if (eventConfig[1].indexOf("on") === 0) {
                    eventConfig[0][eventConfig[1]] = pointer["_" + eventConfig[2]];
                } else {
                    addEvent(eventConfig[0], eventConfig[1], pointer["_" + eventConfig[2]]);
                }
            });
        },
        destroy: function() {
            var pointer = this;
            each(pointer._events, function(eventConfig) {
                if (eventConfig[1].indexOf("on") === 0) {
                    eventConfig[0][eventConfig[1]] = null;
                } else {
                    removeEvent(eventConfig[0], eventConfig[1], pointer["_" + eventConfig[2]]);
                }
            });
            delete pointer._events;
            clearInterval(pointer.tooltipTimeout);
        }
    };
    function Legend(chart, options) {
        this.init(chart, options);
    }
    Legend.prototype = {
        init: function(chart, options) {
            var legend = this, itemStyle = options.itemStyle, padding = pick(options.padding, 8), itemMarginTop = options.itemMarginTop || 0;
            this.options = options;
            if (!options.enabled) {
                return;
            }
            legend.baseline = pInt(itemStyle.fontSize) + 3 + itemMarginTop;
            legend.itemStyle = itemStyle;
            legend.itemHiddenStyle = merge(itemStyle, options.itemHiddenStyle);
            legend.itemMarginTop = itemMarginTop;
            legend.padding = padding;
            legend.initialItemX = padding;
            legend.initialItemY = padding - 5;
            legend.maxItemWidth = 0;
            legend.chart = chart;
            legend.itemHeight = 0;
            legend.lastLineHeight = 0;
            legend.render();
            addEvent(legend.chart, "endResize", function() {
                legend.positionCheckboxes();
            });
        },
        colorizeItem: function(item, visible) {
            var legend = this, options = legend.options, legendItem = item.legendItem, legendLine = item.legendLine, legendSymbol = item.legendSymbol, hiddenColor = legend.itemHiddenStyle.color, textColor = visible ? options.itemStyle.color : hiddenColor, symbolColor = visible ? item.color : hiddenColor, markerOptions = item.options && item.options.marker, symbolAttr = {
                stroke: symbolColor,
                fill: symbolColor
            }, key, val;
            if (legendItem) {
                legendItem.css({
                    fill: textColor,
                    color: textColor
                });
            }
            if (legendLine) {
                legendLine.attr({
                    stroke: symbolColor
                });
            }
            if (legendSymbol) {
                if (markerOptions && legendSymbol.isMarker) {
                    markerOptions = item.convertAttribs(markerOptions);
                    for (key in markerOptions) {
                        val = markerOptions[key];
                        if (val !== UNDEFINED) {
                            symbolAttr[key] = val;
                        }
                    }
                }
                legendSymbol.attr(symbolAttr);
            }
        },
        positionItem: function(item) {
            var legend = this, options = legend.options, symbolPadding = options.symbolPadding, ltr = !options.rtl, legendItemPos = item._legendItemPos, itemX = legendItemPos[0], itemY = legendItemPos[1], checkbox = item.checkbox;
            if (item.legendGroup) {
                item.legendGroup.translate(ltr ? itemX : legend.legendWidth - itemX - 2 * symbolPadding - 4, itemY);
            }
            if (checkbox) {
                checkbox.x = itemX;
                checkbox.y = itemY;
            }
        },
        destroyItem: function(item) {
            var checkbox = item.checkbox;
            each([ "legendItem", "legendLine", "legendSymbol", "legendGroup" ], function(key) {
                if (item[key]) {
                    item[key] = item[key].destroy();
                }
            });
            if (checkbox) {
                discardElement(item.checkbox);
            }
        },
        destroy: function() {
            var legend = this, legendGroup = legend.group, box = legend.box;
            if (box) {
                legend.box = box.destroy();
            }
            if (legendGroup) {
                legend.group = legendGroup.destroy();
            }
        },
        positionCheckboxes: function(scrollOffset) {
            var alignAttr = this.group.alignAttr, translateY, clipHeight = this.clipHeight || this.legendHeight;
            if (alignAttr) {
                translateY = alignAttr.translateY;
                each(this.allItems, function(item) {
                    var checkbox = item.checkbox, top;
                    if (checkbox) {
                        top = translateY + checkbox.y + (scrollOffset || 0) + 3;
                        css(checkbox, {
                            left: alignAttr.translateX + item.legendItemWidth + checkbox.x - 20 + PX,
                            top: top + PX,
                            display: top > translateY - 6 && top < translateY + clipHeight - 6 ? "" : NONE
                        });
                    }
                });
            }
        },
        renderTitle: function() {
            var options = this.options, padding = this.padding, titleOptions = options.title, titleHeight = 0, bBox;
            if (titleOptions.text) {
                if (!this.title) {
                    this.title = this.chart.renderer.label(titleOptions.text, padding - 3, padding - 4, null, null, null, null, null, "legend-title").attr({
                        zIndex: 1
                    }).css(titleOptions.style).add(this.group);
                }
                bBox = this.title.getBBox();
                titleHeight = bBox.height;
                this.offsetWidth = bBox.width;
                this.contentGroup.attr({
                    translateY: titleHeight
                });
            }
            this.titleHeight = titleHeight;
        },
        renderItem: function(item) {
            var legend = this, chart = legend.chart, renderer = chart.renderer, options = legend.options, horizontal = options.layout === "horizontal", symbolWidth = options.symbolWidth, symbolPadding = options.symbolPadding, itemStyle = legend.itemStyle, itemHiddenStyle = legend.itemHiddenStyle, padding = legend.padding, itemDistance = horizontal ? pick(options.itemDistance, 8) : 0, ltr = !options.rtl, itemHeight, widthOption = options.width, itemMarginBottom = options.itemMarginBottom || 0, itemMarginTop = legend.itemMarginTop, initialItemX = legend.initialItemX, bBox, itemWidth, li = item.legendItem, series = item.series || item, itemOptions = series.options, showCheckbox = itemOptions.showCheckbox, useHTML = options.useHTML;
            if (!li) {
                item.legendGroup = renderer.g("legend-item").attr({
                    zIndex: 1
                }).add(legend.scrollGroup);
                series.drawLegendSymbol(legend, item);
                item.legendItem = li = renderer.text(options.labelFormat ? format(options.labelFormat, item) : options.labelFormatter.call(item), ltr ? symbolWidth + symbolPadding : -symbolPadding, legend.baseline, useHTML).css(merge(item.visible ? itemStyle : itemHiddenStyle)).attr({
                    align: ltr ? "left" : "right",
                    zIndex: 2
                }).add(item.legendGroup);
                (useHTML ? li : item.legendGroup).on("mouseover", function() {
                    item.setState(HOVER_STATE);
                    li.css(legend.options.itemHoverStyle);
                }).on("mouseout", function() {
                    li.css(item.visible ? itemStyle : itemHiddenStyle);
                    item.setState();
                }).on("click", function(event) {
                    var strLegendItemClick = "legendItemClick", fnLegendItemClick = function() {
                        item.setVisible();
                    };
                    event = {
                        browserEvent: event
                    };
                    if (item.firePointEvent) {
                        item.firePointEvent(strLegendItemClick, event, fnLegendItemClick);
                    } else {
                        fireEvent(item, strLegendItemClick, event, fnLegendItemClick);
                    }
                });
                legend.colorizeItem(item, item.visible);
                if (itemOptions && showCheckbox) {
                    item.checkbox = createElement("input", {
                        type: "checkbox",
                        checked: item.selected,
                        defaultChecked: item.selected
                    }, options.itemCheckboxStyle, chart.container);
                    addEvent(item.checkbox, "click", function(event) {
                        var target = event.target;
                        fireEvent(item, "checkboxClick", {
                            checked: target.checked
                        }, function() {
                            item.select();
                        });
                    });
                }
            }
            bBox = li.getBBox();
            itemWidth = item.legendItemWidth = options.itemWidth || symbolWidth + symbolPadding + bBox.width + itemDistance + (showCheckbox ? 20 : 0);
            legend.itemHeight = itemHeight = bBox.height;
            if (horizontal && legend.itemX - initialItemX + itemWidth > (widthOption || chart.chartWidth - 2 * padding - initialItemX)) {
                legend.itemX = initialItemX;
                legend.itemY += itemMarginTop + legend.lastLineHeight + itemMarginBottom;
                legend.lastLineHeight = 0;
            }
            legend.maxItemWidth = mathMax(legend.maxItemWidth, itemWidth);
            legend.lastItemY = itemMarginTop + legend.itemY + itemMarginBottom;
            legend.lastLineHeight = mathMax(itemHeight, legend.lastLineHeight);
            item._legendItemPos = [ legend.itemX, legend.itemY ];
            if (horizontal) {
                legend.itemX += itemWidth;
            } else {
                legend.itemY += itemMarginTop + itemHeight + itemMarginBottom;
                legend.lastLineHeight = itemHeight;
            }
            legend.offsetWidth = widthOption || mathMax((horizontal ? legend.itemX - initialItemX - itemDistance : itemWidth) + padding, legend.offsetWidth);
        },
        render: function() {
            var legend = this, chart = legend.chart, renderer = chart.renderer, legendGroup = legend.group, allItems, display, legendWidth, legendHeight, box = legend.box, options = legend.options, padding = legend.padding, legendBorderWidth = options.borderWidth, legendBackgroundColor = options.backgroundColor;
            legend.itemX = legend.initialItemX;
            legend.itemY = legend.initialItemY;
            legend.offsetWidth = 0;
            legend.lastItemY = 0;
            if (!legendGroup) {
                legend.group = legendGroup = renderer.g("legend").attr({
                    zIndex: 7
                }).add();
                legend.contentGroup = renderer.g().attr({
                    zIndex: 1
                }).add(legendGroup);
                legend.scrollGroup = renderer.g().add(legend.contentGroup);
            }
            legend.renderTitle();
            allItems = [];
            each(chart.series, function(serie) {
                var seriesOptions = serie.options;
                if (!seriesOptions.showInLegend || defined(seriesOptions.linkedTo)) {
                    return;
                }
                allItems = allItems.concat(serie.legendItems || (seriesOptions.legendType === "point" ? serie.data : serie));
            });
            stableSort(allItems, function(a, b) {
                return (a.options && a.options.legendIndex || 0) - (b.options && b.options.legendIndex || 0);
            });
            if (options.reversed) {
                allItems.reverse();
            }
            legend.allItems = allItems;
            legend.display = display = !!allItems.length;
            each(allItems, function(item) {
                legend.renderItem(item);
            });
            legendWidth = options.width || legend.offsetWidth;
            legendHeight = legend.lastItemY + legend.lastLineHeight + legend.titleHeight;
            legendHeight = legend.handleOverflow(legendHeight);
            if (legendBorderWidth || legendBackgroundColor) {
                legendWidth += padding;
                legendHeight += padding;
                if (!box) {
                    legend.box = box = renderer.rect(0, 0, legendWidth, legendHeight, options.borderRadius, legendBorderWidth || 0).attr({
                        stroke: options.borderColor,
                        "stroke-width": legendBorderWidth || 0,
                        fill: legendBackgroundColor || NONE
                    }).add(legendGroup).shadow(options.shadow);
                    box.isNew = true;
                } else if (legendWidth > 0 && legendHeight > 0) {
                    box[box.isNew ? "attr" : "animate"](box.crisp(null, null, null, legendWidth, legendHeight));
                    box.isNew = false;
                }
                box[display ? "show" : "hide"]();
            }
            legend.legendWidth = legendWidth;
            legend.legendHeight = legendHeight;
            each(allItems, function(item) {
                legend.positionItem(item);
            });
            if (display) {
                legendGroup.align(extend({
                    width: legendWidth,
                    height: legendHeight
                }, options), true, "spacingBox");
            }
            if (!chart.isResizing) {
                this.positionCheckboxes();
            }
        },
        handleOverflow: function(legendHeight) {
            var legend = this, chart = this.chart, renderer = chart.renderer, pageCount, options = this.options, optionsY = options.y, alignTop = options.verticalAlign === "top", spaceHeight = chart.spacingBox.height + (alignTop ? -optionsY : optionsY) - this.padding, maxHeight = options.maxHeight, clipHeight, clipRect = this.clipRect, navOptions = options.navigation, animation = pick(navOptions.animation, true), arrowSize = navOptions.arrowSize || 12, nav = this.nav;
            if (options.layout === "horizontal") {
                spaceHeight /= 2;
            }
            if (maxHeight) {
                spaceHeight = mathMin(spaceHeight, maxHeight);
            }
            if (legendHeight > spaceHeight && !options.useHTML) {
                this.clipHeight = clipHeight = spaceHeight - 20 - this.titleHeight;
                this.pageCount = pageCount = mathCeil(legendHeight / clipHeight);
                this.currentPage = pick(this.currentPage, 1);
                this.fullHeight = legendHeight;
                if (!clipRect) {
                    clipRect = legend.clipRect = renderer.clipRect(0, 0, 9999, 0);
                    legend.contentGroup.clip(clipRect);
                }
                clipRect.attr({
                    height: clipHeight
                });
                if (!nav) {
                    this.nav = nav = renderer.g().attr({
                        zIndex: 1
                    }).add(this.group);
                    this.up = renderer.symbol("triangle", 0, 0, arrowSize, arrowSize).on("click", function() {
                        legend.scroll(-1, animation);
                    }).add(nav);
                    this.pager = renderer.text("", 15, 10).css(navOptions.style).add(nav);
                    this.down = renderer.symbol("triangle-down", 0, 0, arrowSize, arrowSize).on("click", function() {
                        legend.scroll(1, animation);
                    }).add(nav);
                }
                legend.scroll(0);
                legendHeight = spaceHeight;
            } else if (nav) {
                clipRect.attr({
                    height: chart.chartHeight
                });
                nav.hide();
                this.scrollGroup.attr({
                    translateY: 1
                });
                this.clipHeight = 0;
            }
            return legendHeight;
        },
        scroll: function(scrollBy, animation) {
            var pageCount = this.pageCount, currentPage = this.currentPage + scrollBy, clipHeight = this.clipHeight, navOptions = this.options.navigation, activeColor = navOptions.activeColor, inactiveColor = navOptions.inactiveColor, pager = this.pager, padding = this.padding, scrollOffset;
            if (currentPage > pageCount) {
                currentPage = pageCount;
            }
            if (currentPage > 0) {
                if (animation !== UNDEFINED) {
                    setAnimation(animation, this.chart);
                }
                this.nav.attr({
                    translateX: padding,
                    translateY: clipHeight + 7 + this.titleHeight,
                    visibility: VISIBLE
                });
                this.up.attr({
                    fill: currentPage === 1 ? inactiveColor : activeColor
                }).css({
                    cursor: currentPage === 1 ? "default" : "pointer"
                });
                pager.attr({
                    text: currentPage + "/" + this.pageCount
                });
                this.down.attr({
                    x: 18 + this.pager.getBBox().width,
                    fill: currentPage === pageCount ? inactiveColor : activeColor
                }).css({
                    cursor: currentPage === pageCount ? "default" : "pointer"
                });
                scrollOffset = -mathMin(clipHeight * (currentPage - 1), this.fullHeight - clipHeight + padding) + 1;
                this.scrollGroup.animate({
                    translateY: scrollOffset
                });
                pager.attr({
                    text: currentPage + "/" + pageCount
                });
                this.currentPage = currentPage;
                this.positionCheckboxes(scrollOffset);
            }
        }
    };
    function Chart() {
        this.init.apply(this, arguments);
    }
    Chart.prototype = {
        init: function(userOptions, callback) {
            var options, seriesOptions = userOptions.series;
            userOptions.series = null;
            options = merge(defaultOptions, userOptions);
            options.series = userOptions.series = seriesOptions;
            var optionsChart = options.chart, optionsMargin = optionsChart.margin, margin = isObject(optionsMargin) ? optionsMargin : [ optionsMargin, optionsMargin, optionsMargin, optionsMargin ];
            this.optionsMarginTop = pick(optionsChart.marginTop, margin[0]);
            this.optionsMarginRight = pick(optionsChart.marginRight, margin[1]);
            this.optionsMarginBottom = pick(optionsChart.marginBottom, margin[2]);
            this.optionsMarginLeft = pick(optionsChart.marginLeft, margin[3]);
            var chartEvents = optionsChart.events;
            this.bounds = {
                h: {},
                v: {}
            };
            this.callback = callback;
            this.isResizing = 0;
            this.options = options;
            this.axes = [];
            this.series = [];
            this.hasCartesianSeries = optionsChart.showAxes;
            var chart = this, eventType;
            chart.index = charts.length;
            charts.push(chart);
            if (optionsChart.reflow !== false) {
                addEvent(chart, "load", function() {
                    chart.initReflow();
                });
            }
            if (chartEvents) {
                for (eventType in chartEvents) {
                    addEvent(chart, eventType, chartEvents[eventType]);
                }
            }
            chart.xAxis = [];
            chart.yAxis = [];
            chart.animation = useCanVG ? false : pick(optionsChart.animation, true);
            chart.pointCount = 0;
            chart.counters = new ChartCounters();
            chart.firstRender();
        },
        initSeries: function(options) {
            var chart = this, optionsChart = chart.options.chart, type = options.type || optionsChart.type || optionsChart.defaultSeriesType, series, constr = seriesTypes[type];
            if (!constr) {
                error(17, true);
            }
            series = new constr();
            series.init(this, options);
            return series;
        },
        addSeries: function(options, redraw, animation) {
            var series, chart = this;
            if (options) {
                redraw = pick(redraw, true);
                fireEvent(chart, "addSeries", {
                    options: options
                }, function() {
                    series = chart.initSeries(options);
                    chart.isDirtyLegend = true;
                    chart.linkSeries();
                    if (redraw) {
                        chart.redraw(animation);
                    }
                });
            }
            return series;
        },
        addAxis: function(options, isX, redraw, animation) {
            var key = isX ? "xAxis" : "yAxis", chartOptions = this.options, axis;
            axis = new Axis(this, merge(options, {
                index: this[key].length,
                isX: isX
            }));
            chartOptions[key] = splat(chartOptions[key] || {});
            chartOptions[key].push(options);
            if (pick(redraw, true)) {
                this.redraw(animation);
            }
        },
        isInsidePlot: function(plotX, plotY, inverted) {
            var x = inverted ? plotY : plotX, y = inverted ? plotX : plotY;
            return x >= 0 && x <= this.plotWidth && y >= 0 && y <= this.plotHeight;
        },
        adjustTickAmounts: function() {
            if (this.options.chart.alignTicks !== false) {
                each(this.axes, function(axis) {
                    axis.adjustTickAmount();
                });
            }
            this.maxTicks = null;
        },
        redraw: function(animation) {
            var chart = this, axes = chart.axes, series = chart.series, pointer = chart.pointer, legend = chart.legend, redrawLegend = chart.isDirtyLegend, hasStackedSeries, hasDirtyStacks, isDirtyBox = chart.isDirtyBox, seriesLength = series.length, i = seriesLength, serie, renderer = chart.renderer, isHiddenChart = renderer.isHidden(), afterRedraw = [];
            setAnimation(animation, chart);
            if (isHiddenChart) {
                chart.cloneRenderTo();
            }
            chart.layOutTitles();
            while (i--) {
                serie = series[i];
                if (serie.options.stacking) {
                    hasStackedSeries = true;
                    if (serie.isDirty) {
                        hasDirtyStacks = true;
                        break;
                    }
                }
            }
            if (hasDirtyStacks) {
                i = seriesLength;
                while (i--) {
                    serie = series[i];
                    if (serie.options.stacking) {
                        serie.isDirty = true;
                    }
                }
            }
            each(series, function(serie) {
                if (serie.isDirty) {
                    if (serie.options.legendType === "point") {
                        redrawLegend = true;
                    }
                }
            });
            if (redrawLegend && legend.options.enabled) {
                legend.render();
                chart.isDirtyLegend = false;
            }
            if (hasStackedSeries) {
                chart.getStacks();
            }
            if (chart.hasCartesianSeries) {
                if (!chart.isResizing) {
                    chart.maxTicks = null;
                    each(axes, function(axis) {
                        axis.setScale();
                    });
                }
                chart.adjustTickAmounts();
                chart.getMargins();
                each(axes, function(axis) {
                    if (axis.isDirty) {
                        isDirtyBox = true;
                    }
                });
                each(axes, function(axis) {
                    if (axis.isDirtyExtremes) {
                        axis.isDirtyExtremes = false;
                        afterRedraw.push(function() {
                            fireEvent(axis, "afterSetExtremes", axis.getExtremes());
                        });
                    }
                    if (isDirtyBox || hasStackedSeries) {
                        axis.redraw();
                    }
                });
            }
            if (isDirtyBox) {
                chart.drawChartBox();
            }
            each(series, function(serie) {
                if (serie.isDirty && serie.visible && (!serie.isCartesian || serie.xAxis)) {
                    serie.redraw();
                }
            });
            if (pointer && pointer.reset) {
                pointer.reset(true);
            }
            renderer.draw();
            fireEvent(chart, "redraw");
            if (isHiddenChart) {
                chart.cloneRenderTo(true);
            }
            each(afterRedraw, function(callback) {
                callback.call();
            });
        },
        showLoading: function(str) {
            var chart = this, options = chart.options, loadingDiv = chart.loadingDiv;
            var loadingOptions = options.loading;
            if (!loadingDiv) {
                chart.loadingDiv = loadingDiv = createElement(DIV, {
                    className: PREFIX + "loading"
                }, extend(loadingOptions.style, {
                    zIndex: 10,
                    display: NONE
                }), chart.container);
                chart.loadingSpan = createElement("span", null, loadingOptions.labelStyle, loadingDiv);
            }
            chart.loadingSpan.innerHTML = str || options.lang.loading;
            if (!chart.loadingShown) {
                css(loadingDiv, {
                    opacity: 0,
                    display: "",
                    left: chart.plotLeft + PX,
                    top: chart.plotTop + PX,
                    width: chart.plotWidth + PX,
                    height: chart.plotHeight + PX
                });
                animate(loadingDiv, {
                    opacity: loadingOptions.style.opacity
                }, {
                    duration: loadingOptions.showDuration || 0
                });
                chart.loadingShown = true;
            }
        },
        hideLoading: function() {
            var options = this.options, loadingDiv = this.loadingDiv;
            if (loadingDiv) {
                animate(loadingDiv, {
                    opacity: 0
                }, {
                    duration: options.loading.hideDuration || 100,
                    complete: function() {
                        css(loadingDiv, {
                            display: NONE
                        });
                    }
                });
            }
            this.loadingShown = false;
        },
        get: function(id) {
            var chart = this, axes = chart.axes, series = chart.series;
            var i, j, points;
            for (i = 0; i < axes.length; i++) {
                if (axes[i].options.id === id) {
                    return axes[i];
                }
            }
            for (i = 0; i < series.length; i++) {
                if (series[i].options.id === id) {
                    return series[i];
                }
            }
            for (i = 0; i < series.length; i++) {
                points = series[i].points || [];
                for (j = 0; j < points.length; j++) {
                    if (points[j].id === id) {
                        return points[j];
                    }
                }
            }
            return null;
        },
        getAxes: function() {
            var chart = this, options = this.options, xAxisOptions = options.xAxis = splat(options.xAxis || {}), yAxisOptions = options.yAxis = splat(options.yAxis || {}), optionsArray, axis;
            each(xAxisOptions, function(axis, i) {
                axis.index = i;
                axis.isX = true;
            });
            each(yAxisOptions, function(axis, i) {
                axis.index = i;
            });
            optionsArray = xAxisOptions.concat(yAxisOptions);
            each(optionsArray, function(axisOptions) {
                axis = new Axis(chart, axisOptions);
            });
            chart.adjustTickAmounts();
        },
        getSelectedPoints: function() {
            var points = [];
            each(this.series, function(serie) {
                points = points.concat(grep(serie.points || [], function(point) {
                    return point.selected;
                }));
            });
            return points;
        },
        getSelectedSeries: function() {
            return grep(this.series, function(serie) {
                return serie.selected;
            });
        },
        getStacks: function() {
            var chart = this;
            each(chart.yAxis, function(axis) {
                if (axis.stacks && axis.hasVisibleSeries) {
                    axis.oldStacks = axis.stacks;
                }
            });
            each(chart.series, function(series) {
                if (series.options.stacking && (series.visible === true || chart.options.chart.ignoreHiddenSeries === false)) {
                    series.stackKey = series.type + pick(series.options.stack, "");
                }
            });
        },
        showResetZoom: function() {
            var chart = this, lang = defaultOptions.lang, btnOptions = chart.options.chart.resetZoomButton, theme = btnOptions.theme, states = theme.states, alignTo = btnOptions.relativeTo === "chart" ? null : "plotBox";
            this.resetZoomButton = chart.renderer.button(lang.resetZoom, null, null, function() {
                chart.zoomOut();
            }, theme, states && states.hover).attr({
                align: btnOptions.position.align,
                title: lang.resetZoomTitle
            }).add().align(btnOptions.position, false, alignTo);
        },
        zoomOut: function() {
            var chart = this;
            fireEvent(chart, "selection", {
                resetSelection: true
            }, function() {
                chart.zoom();
            });
        },
        zoom: function(event) {
            var chart = this, hasZoomed, pointer = chart.pointer, displayButton = false, resetZoomButton;
            if (!event || event.resetSelection) {
                each(chart.axes, function(axis) {
                    hasZoomed = axis.zoom();
                });
            } else {
                each(event.xAxis.concat(event.yAxis), function(axisData) {
                    var axis = axisData.axis, isXAxis = axis.isXAxis;
                    if (pointer[isXAxis ? "zoomX" : "zoomY"] || pointer[isXAxis ? "pinchX" : "pinchY"]) {
                        hasZoomed = axis.zoom(axisData.min, axisData.max);
                        if (axis.displayBtn) {
                            displayButton = true;
                        }
                    }
                });
            }
            resetZoomButton = chart.resetZoomButton;
            if (displayButton && !resetZoomButton) {
                chart.showResetZoom();
            } else if (!displayButton && isObject(resetZoomButton)) {
                chart.resetZoomButton = resetZoomButton.destroy();
            }
            if (hasZoomed) {
                chart.redraw(pick(chart.options.chart.animation, event && event.animation, chart.pointCount < 100));
            }
        },
        pan: function(e, panning) {
            var chart = this, hoverPoints = chart.hoverPoints, doRedraw;
            if (hoverPoints) {
                each(hoverPoints, function(point) {
                    point.setState();
                });
            }
            each(panning === "xy" ? [ 1, 0 ] : [ 1 ], function(isX) {
                var mousePos = e[isX ? "chartX" : "chartY"], axis = chart[isX ? "xAxis" : "yAxis"][0], startPos = chart[isX ? "mouseDownX" : "mouseDownY"], halfPointRange = (axis.pointRange || 0) / 2, extremes = axis.getExtremes(), newMin = axis.toValue(startPos - mousePos, true) + halfPointRange, newMax = axis.toValue(startPos + chart[isX ? "plotWidth" : "plotHeight"] - mousePos, true) - halfPointRange;
                if (axis.series.length && newMin > mathMin(extremes.dataMin, extremes.min) && newMax < mathMax(extremes.dataMax, extremes.max)) {
                    axis.setExtremes(newMin, newMax, false, false, {
                        trigger: "pan"
                    });
                    doRedraw = true;
                }
                chart[isX ? "mouseDownX" : "mouseDownY"] = mousePos;
            });
            if (doRedraw) {
                chart.redraw(false);
            }
            css(chart.container, {
                cursor: "move"
            });
        },
        setTitle: function(titleOptions, subtitleOptions) {
            var chart = this, options = chart.options, chartTitleOptions, chartSubtitleOptions;
            chartTitleOptions = options.title = merge(options.title, titleOptions);
            chartSubtitleOptions = options.subtitle = merge(options.subtitle, subtitleOptions);
            each([ [ "title", titleOptions, chartTitleOptions ], [ "subtitle", subtitleOptions, chartSubtitleOptions ] ], function(arr) {
                var name = arr[0], title = chart[name], titleOptions = arr[1], chartTitleOptions = arr[2];
                if (title && titleOptions) {
                    chart[name] = title = title.destroy();
                }
                if (chartTitleOptions && chartTitleOptions.text && !title) {
                    chart[name] = chart.renderer.text(chartTitleOptions.text, 0, 0, chartTitleOptions.useHTML).attr({
                        align: chartTitleOptions.align,
                        "class": PREFIX + name,
                        zIndex: chartTitleOptions.zIndex || 4
                    }).css(chartTitleOptions.style).add();
                }
            });
            chart.layOutTitles();
        },
        layOutTitles: function() {
            var titleOffset = 0, title = this.title, subtitle = this.subtitle, options = this.options, titleOptions = options.title, subtitleOptions = options.subtitle, autoWidth = this.spacingBox.width - 44;
            if (title) {
                title.css({
                    width: (titleOptions.width || autoWidth) + PX
                }).align(extend({
                    y: 15
                }, titleOptions), false, "spacingBox");
                if (!titleOptions.floating && !titleOptions.verticalAlign) {
                    titleOffset = title.getBBox().height;
                    if (titleOffset >= 18 && titleOffset <= 25) {
                        titleOffset = 15;
                    }
                }
            }
            if (subtitle) {
                subtitle.css({
                    width: (subtitleOptions.width || autoWidth) + PX
                }).align(extend({
                    y: titleOffset + titleOptions.margin
                }, subtitleOptions), false, "spacingBox");
                if (!subtitleOptions.floating && !subtitleOptions.verticalAlign) {
                    titleOffset = mathCeil(titleOffset + subtitle.getBBox().height);
                }
            }
            this.titleOffset = titleOffset;
        },
        getChartSize: function() {
            var chart = this, optionsChart = chart.options.chart, renderTo = chart.renderToClone || chart.renderTo;
            chart.containerWidth = adapterRun(renderTo, "width");
            chart.containerHeight = adapterRun(renderTo, "height");
            chart.chartWidth = mathMax(0, optionsChart.width || chart.containerWidth || 600);
            chart.chartHeight = mathMax(0, pick(optionsChart.height, chart.containerHeight > 19 ? chart.containerHeight : 400));
        },
        cloneRenderTo: function(revert) {
            var clone = this.renderToClone, container = this.container;
            if (revert) {
                if (clone) {
                    this.renderTo.appendChild(container);
                    discardElement(clone);
                    delete this.renderToClone;
                }
            } else {
                if (container && container.parentNode === this.renderTo) {
                    this.renderTo.removeChild(container);
                }
                this.renderToClone = clone = this.renderTo.cloneNode(0);
                css(clone, {
                    position: ABSOLUTE,
                    top: "-9999px",
                    display: "block"
                });
                doc.body.appendChild(clone);
                if (container) {
                    clone.appendChild(container);
                }
            }
        },
        getContainer: function() {
            var chart = this, container, optionsChart = chart.options.chart, chartWidth, chartHeight, renderTo, indexAttrName = "data-highcharts-chart", oldChartIndex, containerId;
            chart.renderTo = renderTo = optionsChart.renderTo;
            containerId = PREFIX + idCounter++;
            if (isString(renderTo)) {
                chart.renderTo = renderTo = doc.getElementById(renderTo);
            }
            if (!renderTo) {
                error(13, true);
            }
            oldChartIndex = pInt(attr(renderTo, indexAttrName));
            if (!isNaN(oldChartIndex) && charts[oldChartIndex]) {
                charts[oldChartIndex].destroy();
            }
            attr(renderTo, indexAttrName, chart.index);
            renderTo.innerHTML = "";
            if (!renderTo.offsetWidth) {
                chart.cloneRenderTo();
            }
            chart.getChartSize();
            chartWidth = chart.chartWidth;
            chartHeight = chart.chartHeight;
            chart.container = container = createElement(DIV, {
                className: PREFIX + "container" + (optionsChart.className ? " " + optionsChart.className : ""),
                id: containerId
            }, extend({
                position: RELATIVE,
                overflow: HIDDEN,
                width: chartWidth + PX,
                height: chartHeight + PX,
                textAlign: "left",
                lineHeight: "normal",
                zIndex: 0,
                "-webkit-tap-highlight-color": "rgba(0,0,0,0)"
            }, optionsChart.style), chart.renderToClone || renderTo);
            chart._cursor = container.style.cursor;
            chart.renderer = optionsChart.forExport ? new SVGRenderer(container, chartWidth, chartHeight, true) : new Renderer(container, chartWidth, chartHeight);
            if (useCanVG) {
                chart.renderer.create(chart, container, chartWidth, chartHeight);
            }
        },
        getMargins: function() {
            var chart = this, optionsChart = chart.options.chart, spacingTop = optionsChart.spacingTop, spacingRight = optionsChart.spacingRight, spacingBottom = optionsChart.spacingBottom, spacingLeft = optionsChart.spacingLeft, axisOffset, legend = chart.legend, optionsMarginTop = chart.optionsMarginTop, optionsMarginLeft = chart.optionsMarginLeft, optionsMarginRight = chart.optionsMarginRight, optionsMarginBottom = chart.optionsMarginBottom, legendOptions = chart.options.legend, legendMargin = pick(legendOptions.margin, 10), legendX = legendOptions.x, legendY = legendOptions.y, align = legendOptions.align, verticalAlign = legendOptions.verticalAlign, titleOffset = chart.titleOffset;
            chart.resetMargins();
            axisOffset = chart.axisOffset;
            if (titleOffset && !defined(optionsMarginTop)) {
                chart.plotTop = mathMax(chart.plotTop, titleOffset + chart.options.title.margin + spacingTop);
            }
            if (legend.display && !legendOptions.floating) {
                if (align === "right") {
                    if (!defined(optionsMarginRight)) {
                        chart.marginRight = mathMax(chart.marginRight, legend.legendWidth - legendX + legendMargin + spacingRight);
                    }
                } else if (align === "left") {
                    if (!defined(optionsMarginLeft)) {
                        chart.plotLeft = mathMax(chart.plotLeft, legend.legendWidth + legendX + legendMargin + spacingLeft);
                    }
                } else if (verticalAlign === "top") {
                    if (!defined(optionsMarginTop)) {
                        chart.plotTop = mathMax(chart.plotTop, legend.legendHeight + legendY + legendMargin + spacingTop);
                    }
                } else if (verticalAlign === "bottom") {
                    if (!defined(optionsMarginBottom)) {
                        chart.marginBottom = mathMax(chart.marginBottom, legend.legendHeight - legendY + legendMargin + spacingBottom);
                    }
                }
            }
            if (chart.extraBottomMargin) {
                chart.marginBottom += chart.extraBottomMargin;
            }
            if (chart.extraTopMargin) {
                chart.plotTop += chart.extraTopMargin;
            }
            if (chart.hasCartesianSeries) {
                each(chart.axes, function(axis) {
                    axis.getOffset();
                });
            }
            if (!defined(optionsMarginLeft)) {
                chart.plotLeft += axisOffset[3];
            }
            if (!defined(optionsMarginTop)) {
                chart.plotTop += axisOffset[0];
            }
            if (!defined(optionsMarginBottom)) {
                chart.marginBottom += axisOffset[2];
            }
            if (!defined(optionsMarginRight)) {
                chart.marginRight += axisOffset[1];
            }
            chart.setChartSize();
        },
        initReflow: function() {
            var chart = this, optionsChart = chart.options.chart, renderTo = chart.renderTo, reflowTimeout;
            function reflow(e) {
                var width = optionsChart.width || adapterRun(renderTo, "width"), height = optionsChart.height || adapterRun(renderTo, "height"), target = e ? e.target : win;
                if (!chart.hasUserSize && width && height && (target === win || target === doc)) {
                    if (width !== chart.containerWidth || height !== chart.containerHeight) {
                        clearTimeout(reflowTimeout);
                        chart.reflowTimeout = reflowTimeout = setTimeout(function() {
                            if (chart.container) {
                                chart.setSize(width, height, false);
                                chart.hasUserSize = null;
                            }
                        }, 100);
                    }
                    chart.containerWidth = width;
                    chart.containerHeight = height;
                }
            }
            addEvent(win, "resize", reflow);
            addEvent(chart, "destroy", function() {
                removeEvent(win, "resize", reflow);
            });
        },
        setSize: function(width, height, animation) {
            var chart = this, chartWidth, chartHeight, fireEndResize;
            chart.isResizing += 1;
            fireEndResize = function() {
                if (chart) {
                    fireEvent(chart, "endResize", null, function() {
                        chart.isResizing -= 1;
                    });
                }
            };
            setAnimation(animation, chart);
            chart.oldChartHeight = chart.chartHeight;
            chart.oldChartWidth = chart.chartWidth;
            if (defined(width)) {
                chart.chartWidth = chartWidth = mathMax(0, mathRound(width));
                chart.hasUserSize = !!chartWidth;
            }
            if (defined(height)) {
                chart.chartHeight = chartHeight = mathMax(0, mathRound(height));
            }
            css(chart.container, {
                width: chartWidth + PX,
                height: chartHeight + PX
            });
            chart.setChartSize(true);
            chart.renderer.setSize(chartWidth, chartHeight, animation);
            chart.maxTicks = null;
            each(chart.axes, function(axis) {
                axis.isDirty = true;
                axis.setScale();
            });
            each(chart.series, function(serie) {
                serie.isDirty = true;
            });
            chart.isDirtyLegend = true;
            chart.isDirtyBox = true;
            chart.getMargins();
            chart.redraw(animation);
            chart.oldChartHeight = null;
            fireEvent(chart, "resize");
            if (globalAnimation === false) {
                fireEndResize();
            } else {
                setTimeout(fireEndResize, globalAnimation && globalAnimation.duration || 500);
            }
        },
        setChartSize: function(skipAxes) {
            var chart = this, inverted = chart.inverted, renderer = chart.renderer, chartWidth = chart.chartWidth, chartHeight = chart.chartHeight, optionsChart = chart.options.chart, spacingTop = optionsChart.spacingTop, spacingRight = optionsChart.spacingRight, spacingBottom = optionsChart.spacingBottom, spacingLeft = optionsChart.spacingLeft, clipOffset = chart.clipOffset, clipX, clipY, plotLeft, plotTop, plotWidth, plotHeight, plotBorderWidth;
            chart.plotLeft = plotLeft = mathRound(chart.plotLeft);
            chart.plotTop = plotTop = mathRound(chart.plotTop);
            chart.plotWidth = plotWidth = mathMax(0, mathRound(chartWidth - plotLeft - chart.marginRight));
            chart.plotHeight = plotHeight = mathMax(0, mathRound(chartHeight - plotTop - chart.marginBottom));
            chart.plotSizeX = inverted ? plotHeight : plotWidth;
            chart.plotSizeY = inverted ? plotWidth : plotHeight;
            chart.plotBorderWidth = optionsChart.plotBorderWidth || 0;
            chart.spacingBox = renderer.spacingBox = {
                x: spacingLeft,
                y: spacingTop,
                width: chartWidth - spacingLeft - spacingRight,
                height: chartHeight - spacingTop - spacingBottom
            };
            chart.plotBox = renderer.plotBox = {
                x: plotLeft,
                y: plotTop,
                width: plotWidth,
                height: plotHeight
            };
            plotBorderWidth = 2 * mathFloor(chart.plotBorderWidth / 2);
            clipX = mathCeil(mathMax(plotBorderWidth, clipOffset[3]) / 2);
            clipY = mathCeil(mathMax(plotBorderWidth, clipOffset[0]) / 2);
            chart.clipBox = {
                x: clipX,
                y: clipY,
                width: mathFloor(chart.plotSizeX - mathMax(plotBorderWidth, clipOffset[1]) / 2 - clipX),
                height: mathFloor(chart.plotSizeY - mathMax(plotBorderWidth, clipOffset[2]) / 2 - clipY)
            };
            if (!skipAxes) {
                each(chart.axes, function(axis) {
                    axis.setAxisSize();
                    axis.setAxisTranslation();
                });
            }
        },
        resetMargins: function() {
            var chart = this, optionsChart = chart.options.chart, spacingTop = optionsChart.spacingTop, spacingRight = optionsChart.spacingRight, spacingBottom = optionsChart.spacingBottom, spacingLeft = optionsChart.spacingLeft;
            chart.plotTop = pick(chart.optionsMarginTop, spacingTop);
            chart.marginRight = pick(chart.optionsMarginRight, spacingRight);
            chart.marginBottom = pick(chart.optionsMarginBottom, spacingBottom);
            chart.plotLeft = pick(chart.optionsMarginLeft, spacingLeft);
            chart.axisOffset = [ 0, 0, 0, 0 ];
            chart.clipOffset = [ 0, 0, 0, 0 ];
        },
        drawChartBox: function() {
            var chart = this, optionsChart = chart.options.chart, renderer = chart.renderer, chartWidth = chart.chartWidth, chartHeight = chart.chartHeight, chartBackground = chart.chartBackground, plotBackground = chart.plotBackground, plotBorder = chart.plotBorder, plotBGImage = chart.plotBGImage, chartBorderWidth = optionsChart.borderWidth || 0, chartBackgroundColor = optionsChart.backgroundColor, plotBackgroundColor = optionsChart.plotBackgroundColor, plotBackgroundImage = optionsChart.plotBackgroundImage, plotBorderWidth = optionsChart.plotBorderWidth || 0, mgn, bgAttr, plotLeft = chart.plotLeft, plotTop = chart.plotTop, plotWidth = chart.plotWidth, plotHeight = chart.plotHeight, plotBox = chart.plotBox, clipRect = chart.clipRect, clipBox = chart.clipBox;
            mgn = chartBorderWidth + (optionsChart.shadow ? 8 : 0);
            if (chartBorderWidth || chartBackgroundColor) {
                if (!chartBackground) {
                    bgAttr = {
                        fill: chartBackgroundColor || NONE
                    };
                    if (chartBorderWidth) {
                        bgAttr.stroke = optionsChart.borderColor;
                        bgAttr["stroke-width"] = chartBorderWidth;
                    }
                    chart.chartBackground = renderer.rect(mgn / 2, mgn / 2, chartWidth - mgn, chartHeight - mgn, optionsChart.borderRadius, chartBorderWidth).attr(bgAttr).add().shadow(optionsChart.shadow);
                } else {
                    chartBackground.animate(chartBackground.crisp(null, null, null, chartWidth - mgn, chartHeight - mgn));
                }
            }
            if (plotBackgroundColor) {
                if (!plotBackground) {
                    chart.plotBackground = renderer.rect(plotLeft, plotTop, plotWidth, plotHeight, 0).attr({
                        fill: plotBackgroundColor
                    }).add().shadow(optionsChart.plotShadow);
                } else {
                    plotBackground.animate(plotBox);
                }
            }
            if (plotBackgroundImage) {
                if (!plotBGImage) {
                    chart.plotBGImage = renderer.image(plotBackgroundImage, plotLeft, plotTop, plotWidth, plotHeight).add();
                } else {
                    plotBGImage.animate(plotBox);
                }
            }
            if (!clipRect) {
                chart.clipRect = renderer.clipRect(clipBox);
            } else {
                clipRect.animate({
                    width: clipBox.width,
                    height: clipBox.height
                });
            }
            if (plotBorderWidth) {
                if (!plotBorder) {
                    chart.plotBorder = renderer.rect(plotLeft, plotTop, plotWidth, plotHeight, 0, -plotBorderWidth).attr({
                        stroke: optionsChart.plotBorderColor,
                        "stroke-width": plotBorderWidth,
                        zIndex: 1
                    }).add();
                } else {
                    plotBorder.animate(plotBorder.crisp(null, plotLeft, plotTop, plotWidth, plotHeight));
                }
            }
            chart.isDirtyBox = false;
        },
        propFromSeries: function() {
            var chart = this, optionsChart = chart.options.chart, klass, seriesOptions = chart.options.series, i, value;
            each([ "inverted", "angular", "polar" ], function(key) {
                klass = seriesTypes[optionsChart.type || optionsChart.defaultSeriesType];
                value = chart[key] || optionsChart[key] || klass && klass.prototype[key];
                i = seriesOptions && seriesOptions.length;
                while (!value && i--) {
                    klass = seriesTypes[seriesOptions[i].type];
                    if (klass && klass.prototype[key]) {
                        value = true;
                    }
                }
                chart[key] = value;
            });
        },
        linkSeries: function() {
            var chart = this, chartSeries = chart.series;
            each(chartSeries, function(series) {
                series.linkedSeries.length = 0;
            });
            each(chartSeries, function(series) {
                var linkedTo = series.options.linkedTo;
                if (isString(linkedTo)) {
                    if (linkedTo === ":previous") {
                        linkedTo = chart.series[series.index - 1];
                    } else {
                        linkedTo = chart.get(linkedTo);
                    }
                    if (linkedTo) {
                        linkedTo.linkedSeries.push(series);
                        series.linkedParent = linkedTo;
                    }
                }
            });
        },
        render: function() {
            var chart = this, axes = chart.axes, renderer = chart.renderer, options = chart.options;
            var labels = options.labels, credits = options.credits, creditsHref;
            chart.setTitle();
            chart.legend = new Legend(chart, options.legend);
            chart.getStacks();
            each(axes, function(axis) {
                axis.setScale();
            });
            chart.getMargins();
            chart.maxTicks = null;
            each(axes, function(axis) {
                axis.setTickPositions(true);
                axis.setMaxTicks();
            });
            chart.adjustTickAmounts();
            chart.getMargins();
            chart.drawChartBox();
            if (chart.hasCartesianSeries) {
                each(axes, function(axis) {
                    axis.render();
                });
            }
            if (!chart.seriesGroup) {
                chart.seriesGroup = renderer.g("series-group").attr({
                    zIndex: 3
                }).add();
            }
            each(chart.series, function(serie) {
                serie.translate();
                serie.setTooltipPoints();
                serie.render();
            });
            if (labels.items) {
                each(labels.items, function(label) {
                    var style = extend(labels.style, label.style), x = pInt(style.left) + chart.plotLeft, y = pInt(style.top) + chart.plotTop + 12;
                    delete style.left;
                    delete style.top;
                    renderer.text(label.html, x, y).attr({
                        zIndex: 2
                    }).css(style).add();
                });
            }
            if (credits.enabled && !chart.credits) {
                creditsHref = credits.href;
                chart.credits = renderer.text(credits.text, 0, 0).on("click", function() {
                    if (creditsHref) {
                        location.href = creditsHref;
                    }
                }).attr({
                    align: credits.position.align,
                    zIndex: 8
                }).css(credits.style).add().align(credits.position);
            }
            chart.hasRendered = true;
        },
        destroy: function() {
            var chart = this, axes = chart.axes, series = chart.series, container = chart.container, i, parentNode = container && container.parentNode;
            fireEvent(chart, "destroy");
            charts[chart.index] = UNDEFINED;
            chart.renderTo.removeAttribute("data-highcharts-chart");
            removeEvent(chart);
            i = axes.length;
            while (i--) {
                axes[i] = axes[i].destroy();
            }
            i = series.length;
            while (i--) {
                series[i] = series[i].destroy();
            }
            each([ "title", "subtitle", "chartBackground", "plotBackground", "plotBGImage", "plotBorder", "seriesGroup", "clipRect", "credits", "pointer", "scroller", "rangeSelector", "legend", "resetZoomButton", "tooltip", "renderer" ], function(name) {
                var prop = chart[name];
                if (prop && prop.destroy) {
                    chart[name] = prop.destroy();
                }
            });
            if (container) {
                container.innerHTML = "";
                removeEvent(container);
                if (parentNode) {
                    discardElement(container);
                }
            }
            for (i in chart) {
                delete chart[i];
            }
        },
        isReadyToRender: function() {
            var chart = this;
            if (!hasSVG && win == win.top && doc.readyState !== "complete" || useCanVG && !win.canvg) {
                if (useCanVG) {
                    CanVGController.push(function() {
                        chart.firstRender();
                    }, chart.options.global.canvasToolsURL);
                } else {
                    doc.attachEvent("onreadystatechange", function() {
                        doc.detachEvent("onreadystatechange", chart.firstRender);
                        if (doc.readyState === "complete") {
                            chart.firstRender();
                        }
                    });
                }
                return false;
            }
            return true;
        },
        firstRender: function() {
            var chart = this, options = chart.options, callback = chart.callback;
            if (!chart.isReadyToRender()) {
                return;
            }
            chart.getContainer();
            fireEvent(chart, "init");
            chart.resetMargins();
            chart.setChartSize();
            chart.propFromSeries();
            chart.getAxes();
            each(options.series || [], function(serieOptions) {
                chart.initSeries(serieOptions);
            });
            chart.linkSeries();
            fireEvent(chart, "beforeRender");
            chart.pointer = new Pointer(chart, options);
            chart.render();
            chart.renderer.draw();
            if (callback) {
                callback.apply(chart, [ chart ]);
            }
            each(chart.callbacks, function(fn) {
                fn.apply(chart, [ chart ]);
            });
            chart.cloneRenderTo(true);
            fireEvent(chart, "load");
        }
    };
    Chart.prototype.callbacks = [];
    var Point = function() {};
    Point.prototype = {
        init: function(series, options, x) {
            var point = this, colors;
            point.series = series;
            point.applyOptions(options, x);
            point.pointAttr = {};
            if (series.options.colorByPoint) {
                colors = series.options.colors || series.chart.options.colors;
                point.color = point.color || colors[series.colorCounter++];
                if (series.colorCounter === colors.length) {
                    series.colorCounter = 0;
                }
            }
            series.chart.pointCount++;
            return point;
        },
        applyOptions: function(options, x) {
            var point = this, series = point.series, pointValKey = series.pointValKey;
            options = Point.prototype.optionsToObject.call(this, options);
            extend(point, options);
            point.options = point.options ? extend(point.options, options) : options;
            if (pointValKey) {
                point.y = point[pointValKey];
            }
            if (point.x === UNDEFINED && series) {
                point.x = x === UNDEFINED ? series.autoIncrement() : x;
            }
            return point;
        },
        optionsToObject: function(options) {
            var ret, series = this.series, pointArrayMap = series.pointArrayMap || [ "y" ], valueCount = pointArrayMap.length, firstItemType, i = 0, j = 0;
            if (typeof options === "number" || options === null) {
                ret = {
                    y: options
                };
            } else if (isArray(options)) {
                ret = {};
                if (options.length > valueCount) {
                    firstItemType = typeof options[0];
                    if (firstItemType === "string") {
                        ret.name = options[0];
                    } else if (firstItemType === "number") {
                        ret.x = options[0];
                    }
                    i++;
                }
                while (j < valueCount) {
                    ret[pointArrayMap[j++]] = options[i++];
                }
            } else if (typeof options === "object") {
                ret = options;
                if (options.dataLabels) {
                    series._hasPointLabels = true;
                }
                if (options.marker) {
                    series._hasPointMarkers = true;
                }
            }
            return ret;
        },
        destroy: function() {
            var point = this, series = point.series, chart = series.chart, hoverPoints = chart.hoverPoints, prop;
            chart.pointCount--;
            if (hoverPoints) {
                point.setState();
                erase(hoverPoints, point);
                if (!hoverPoints.length) {
                    chart.hoverPoints = null;
                }
            }
            if (point === chart.hoverPoint) {
                point.onMouseOut();
            }
            if (point.graphic || point.dataLabel) {
                removeEvent(point);
                point.destroyElements();
            }
            if (point.legendItem) {
                chart.legend.destroyItem(point);
            }
            for (prop in point) {
                point[prop] = null;
            }
        },
        destroyElements: function() {
            var point = this, props = [ "graphic", "dataLabel", "dataLabelUpper", "group", "connector", "shadowGroup" ], prop, i = 6;
            while (i--) {
                prop = props[i];
                if (point[prop]) {
                    point[prop] = point[prop].destroy();
                }
            }
        },
        getLabelConfig: function() {
            var point = this;
            return {
                x: point.category,
                y: point.y,
                key: point.name || point.category,
                series: point.series,
                point: point,
                percentage: point.percentage,
                total: point.total || point.stackTotal
            };
        },
        select: function(selected, accumulate) {
            var point = this, series = point.series, chart = series.chart;
            selected = pick(selected, !point.selected);
            point.firePointEvent(selected ? "select" : "unselect", {
                accumulate: accumulate
            }, function() {
                point.selected = point.options.selected = selected;
                series.options.data[inArray(point, series.data)] = point.options;
                point.setState(selected && SELECT_STATE);
                if (!accumulate) {
                    each(chart.getSelectedPoints(), function(loopPoint) {
                        if (loopPoint.selected && loopPoint !== point) {
                            loopPoint.selected = loopPoint.options.selected = false;
                            series.options.data[inArray(loopPoint, series.data)] = loopPoint.options;
                            loopPoint.setState(NORMAL_STATE);
                            loopPoint.firePointEvent("unselect");
                        }
                    });
                }
            });
        },
        onMouseOver: function(e) {
            var point = this, series = point.series, chart = series.chart, tooltip = chart.tooltip, hoverPoint = chart.hoverPoint;
            if (hoverPoint && hoverPoint !== point) {
                hoverPoint.onMouseOut();
            }
            point.firePointEvent("mouseOver");
            if (tooltip && (!tooltip.shared || series.noSharedTooltip)) {
                tooltip.refresh(point, e);
            }
            point.setState(HOVER_STATE);
            chart.hoverPoint = point;
        },
        onMouseOut: function() {
            var chart = this.series.chart, hoverPoints = chart.hoverPoints;
            if (!hoverPoints || inArray(this, hoverPoints) === -1) {
                this.firePointEvent("mouseOut");
                this.setState();
                chart.hoverPoint = null;
            }
        },
        tooltipFormatter: function(pointFormat) {
            var series = this.series, seriesTooltipOptions = series.tooltipOptions, valueDecimals = pick(seriesTooltipOptions.valueDecimals, ""), valuePrefix = seriesTooltipOptions.valuePrefix || "", valueSuffix = seriesTooltipOptions.valueSuffix || "";
            each(series.pointArrayMap || [ "y" ], function(key) {
                key = "{point." + key;
                if (valuePrefix || valueSuffix) {
                    pointFormat = pointFormat.replace(key + "}", valuePrefix + key + "}" + valueSuffix);
                }
                pointFormat = pointFormat.replace(key + "}", key + ":,." + valueDecimals + "f}");
            });
            return format(pointFormat, {
                point: this,
                series: this.series
            });
        },
        update: function(options, redraw, animation) {
            var point = this, series = point.series, graphic = point.graphic, i, data = series.data, chart = series.chart, seriesOptions = series.options;
            redraw = pick(redraw, true);
            point.firePointEvent("update", {
                options: options
            }, function() {
                point.applyOptions(options);
                if (isObject(options)) {
                    series.getAttribs();
                    if (graphic) {
                        if (options.marker && options.marker.symbol) {
                            point.graphic = graphic.destroy();
                        } else {
                            graphic.attr(point.pointAttr[series.state]);
                        }
                    }
                }
                i = inArray(point, data);
                series.xData[i] = point.x;
                series.yData[i] = series.toYData ? series.toYData(point) : point.y;
                series.zData[i] = point.z;
                seriesOptions.data[i] = point.options;
                series.isDirty = series.isDirtyData = chart.isDirtyBox = true;
                if (seriesOptions.legendType === "point") {
                    chart.legend.destroyItem(point);
                }
                if (redraw) {
                    chart.redraw(animation);
                }
            });
        },
        remove: function(redraw, animation) {
            var point = this, series = point.series, chart = series.chart, i, data = series.data;
            setAnimation(animation, chart);
            redraw = pick(redraw, true);
            point.firePointEvent("remove", null, function() {
                i = inArray(point, data);
                data.splice(i, 1);
                series.options.data.splice(i, 1);
                series.xData.splice(i, 1);
                series.yData.splice(i, 1);
                series.zData.splice(i, 1);
                point.destroy();
                series.isDirty = true;
                series.isDirtyData = true;
                if (redraw) {
                    chart.redraw();
                }
            });
        },
        firePointEvent: function(eventType, eventArgs, defaultFunction) {
            var point = this, series = this.series, seriesOptions = series.options;
            if (seriesOptions.point.events[eventType] || point.options && point.options.events && point.options.events[eventType]) {
                this.importEvents();
            }
            if (eventType === "click" && seriesOptions.allowPointSelect) {
                defaultFunction = function(event) {
                    point.select(null, event.ctrlKey || event.metaKey || event.shiftKey);
                };
            }
            fireEvent(this, eventType, eventArgs, defaultFunction);
        },
        importEvents: function() {
            if (!this.hasImportedEvents) {
                var point = this, options = merge(point.series.options.point, point.options), events = options.events, eventType;
                point.events = events;
                for (eventType in events) {
                    addEvent(point, eventType, events[eventType]);
                }
                this.hasImportedEvents = true;
            }
        },
        setState: function(state) {
            var point = this, plotX = point.plotX, plotY = point.plotY, series = point.series, stateOptions = series.options.states, markerOptions = defaultPlotOptions[series.type].marker && series.options.marker, normalDisabled = markerOptions && !markerOptions.enabled, markerStateOptions = markerOptions && markerOptions.states[state], stateDisabled = markerStateOptions && markerStateOptions.enabled === false, stateMarkerGraphic = series.stateMarkerGraphic, pointMarker = point.marker || {}, chart = series.chart, radius, newSymbol, pointAttr = point.pointAttr;
            state = state || NORMAL_STATE;
            if (state === point.state || point.selected && state !== SELECT_STATE || stateOptions[state] && stateOptions[state].enabled === false || state && (stateDisabled || normalDisabled && !markerStateOptions.enabled)) {
                return;
            }
            if (point.graphic) {
                radius = markerOptions && point.graphic.symbolName && pointAttr[state].r;
                point.graphic.attr(merge(pointAttr[state], radius ? {
                    x: plotX - radius,
                    y: plotY - radius,
                    width: 2 * radius,
                    height: 2 * radius
                } : {}));
            } else {
                if (state && markerStateOptions) {
                    radius = markerStateOptions.radius;
                    newSymbol = pointMarker.symbol || series.symbol;
                    if (stateMarkerGraphic && stateMarkerGraphic.currentSymbol !== newSymbol) {
                        stateMarkerGraphic = stateMarkerGraphic.destroy();
                    }
                    if (!stateMarkerGraphic) {
                        series.stateMarkerGraphic = stateMarkerGraphic = chart.renderer.symbol(newSymbol, plotX - radius, plotY - radius, 2 * radius, 2 * radius).attr(pointAttr[state]).add(series.markerGroup);
                        stateMarkerGraphic.currentSymbol = newSymbol;
                    } else {
                        stateMarkerGraphic.attr({
                            x: plotX - radius,
                            y: plotY - radius
                        });
                    }
                }
                if (stateMarkerGraphic) {
                    stateMarkerGraphic[state && chart.isInsidePlot(plotX, plotY) ? "show" : "hide"]();
                }
            }
            point.state = state;
        }
    };
    var Series = function() {};
    Series.prototype = {
        isCartesian: true,
        type: "line",
        pointClass: Point,
        sorted: true,
        requireSorting: true,
        pointAttrToOptions: {
            stroke: "lineColor",
            "stroke-width": "lineWidth",
            fill: "fillColor",
            r: "radius"
        },
        colorCounter: 0,
        init: function(chart, options) {
            var series = this, eventType, events, chartSeries = chart.series;
            series.chart = chart;
            series.options = options = series.setOptions(options);
            series.linkedSeries = [];
            series.bindAxes();
            extend(series, {
                name: options.name,
                state: NORMAL_STATE,
                pointAttr: {},
                visible: options.visible !== false,
                selected: options.selected === true
            });
            if (useCanVG) {
                options.animation = false;
            }
            events = options.events;
            for (eventType in events) {
                addEvent(series, eventType, events[eventType]);
            }
            if (events && events.click || options.point && options.point.events && options.point.events.click || options.allowPointSelect) {
                chart.runTrackerClick = true;
            }
            series.getColor();
            series.getSymbol();
            series.setData(options.data, false);
            if (series.isCartesian) {
                chart.hasCartesianSeries = true;
            }
            chartSeries.push(series);
            series._i = chartSeries.length - 1;
            stableSort(chartSeries, function(a, b) {
                return pick(a.options.index, a._i) - pick(b.options.index, a._i);
            });
            each(chartSeries, function(series, i) {
                series.index = i;
                series.name = series.name || "Series " + (i + 1);
            });
        },
        bindAxes: function() {
            var series = this, seriesOptions = series.options, chart = series.chart, axisOptions;
            if (series.isCartesian) {
                each([ "xAxis", "yAxis" ], function(AXIS) {
                    each(chart[AXIS], function(axis) {
                        axisOptions = axis.options;
                        if (seriesOptions[AXIS] === axisOptions.index || seriesOptions[AXIS] !== UNDEFINED && seriesOptions[AXIS] === axisOptions.id || seriesOptions[AXIS] === UNDEFINED && axisOptions.index === 0) {
                            axis.series.push(series);
                            series[AXIS] = axis;
                            axis.isDirty = true;
                        }
                    });
                    if (!series[AXIS]) {
                        error(18, true);
                    }
                });
            }
        },
        autoIncrement: function() {
            var series = this, options = series.options, xIncrement = series.xIncrement;
            xIncrement = pick(xIncrement, options.pointStart, 0);
            series.pointInterval = pick(series.pointInterval, options.pointInterval, 1);
            series.xIncrement = xIncrement + series.pointInterval;
            return xIncrement;
        },
        getSegments: function() {
            var series = this, lastNull = -1, segments = [], i, points = series.points, pointsLength = points.length;
            if (pointsLength) {
                if (series.options.connectNulls) {
                    i = pointsLength;
                    while (i--) {
                        if (points[i].y === null) {
                            points.splice(i, 1);
                        }
                    }
                    if (points.length) {
                        segments = [ points ];
                    }
                } else {
                    each(points, function(point, i) {
                        if (point.y === null) {
                            if (i > lastNull + 1) {
                                segments.push(points.slice(lastNull + 1, i));
                            }
                            lastNull = i;
                        } else if (i === pointsLength - 1) {
                            segments.push(points.slice(lastNull + 1, i + 1));
                        }
                    });
                }
            }
            series.segments = segments;
        },
        setOptions: function(itemOptions) {
            var chart = this.chart, chartOptions = chart.options, plotOptions = chartOptions.plotOptions, typeOptions = plotOptions[this.type], options;
            this.userOptions = itemOptions;
            options = merge(typeOptions, plotOptions.series, itemOptions);
            this.tooltipOptions = merge(chartOptions.tooltip, options.tooltip);
            if (typeOptions.marker === null) {
                delete options.marker;
            }
            return options;
        },
        getColor: function() {
            var options = this.options, userOptions = this.userOptions, defaultColors = this.chart.options.colors, counters = this.chart.counters, color, colorIndex;
            color = options.color || defaultPlotOptions[this.type].color;
            if (!color && !options.colorByPoint) {
                if (defined(userOptions._colorIndex)) {
                    colorIndex = userOptions._colorIndex;
                } else {
                    userOptions._colorIndex = counters.color;
                    colorIndex = counters.color++;
                }
                color = defaultColors[colorIndex];
            }
            this.color = color;
            counters.wrapColor(defaultColors.length);
        },
        getSymbol: function() {
            var series = this, userOptions = series.userOptions, seriesMarkerOption = series.options.marker, chart = series.chart, defaultSymbols = chart.options.symbols, counters = chart.counters, symbolIndex;
            series.symbol = seriesMarkerOption.symbol;
            if (!series.symbol) {
                if (defined(userOptions._symbolIndex)) {
                    symbolIndex = userOptions._symbolIndex;
                } else {
                    userOptions._symbolIndex = counters.symbol;
                    symbolIndex = counters.symbol++;
                }
                series.symbol = defaultSymbols[symbolIndex];
            }
            if (/^url/.test(series.symbol)) {
                seriesMarkerOption.radius = 0;
            }
            counters.wrapSymbol(defaultSymbols.length);
        },
        drawLegendSymbol: function(legend) {
            var options = this.options, markerOptions = options.marker, radius, legendOptions = legend.options, legendSymbol, symbolWidth = legendOptions.symbolWidth, renderer = this.chart.renderer, legendItemGroup = this.legendGroup, verticalCenter = legend.baseline - mathRound(renderer.fontMetrics(legendOptions.itemStyle.fontSize).b * .3), attr;
            if (options.lineWidth) {
                attr = {
                    "stroke-width": options.lineWidth
                };
                if (options.dashStyle) {
                    attr.dashstyle = options.dashStyle;
                }
                this.legendLine = renderer.path([ M, 0, verticalCenter, L, symbolWidth, verticalCenter ]).attr(attr).add(legendItemGroup);
            }
            if (markerOptions && markerOptions.enabled) {
                radius = markerOptions.radius;
                this.legendSymbol = legendSymbol = renderer.symbol(this.symbol, symbolWidth / 2 - radius, verticalCenter - radius, 2 * radius, 2 * radius).add(legendItemGroup);
                legendSymbol.isMarker = true;
            }
        },
        addPoint: function(options, redraw, shift, animation) {
            var series = this, seriesOptions = series.options, data = series.data, graph = series.graph, area = series.area, chart = series.chart, xData = series.xData, yData = series.yData, zData = series.zData, names = series.names, currentShift = graph && graph.shift || 0, dataOptions = seriesOptions.data, point;
            setAnimation(animation, chart);
            if (shift) {
                each([ graph, area, series.graphNeg, series.areaNeg ], function(shape) {
                    if (shape) {
                        shape.shift = currentShift + 1;
                    }
                });
            }
            if (area) {
                area.isArea = true;
            }
            redraw = pick(redraw, true);
            point = {
                series: series
            };
            series.pointClass.prototype.applyOptions.apply(point, [ options ]);
            xData.push(point.x);
            yData.push(series.toYData ? series.toYData(point) : point.y);
            zData.push(point.z);
            if (names) {
                names[point.x] = point.name;
            }
            dataOptions.push(options);
            if (seriesOptions.legendType === "point") {
                series.generatePoints();
            }
            if (shift) {
                if (data[0] && data[0].remove) {
                    data[0].remove(false);
                } else {
                    data.shift();
                    xData.shift();
                    yData.shift();
                    zData.shift();
                    dataOptions.shift();
                }
            }
            series.isDirty = true;
            series.isDirtyData = true;
            if (redraw) {
                series.getAttribs();
                chart.redraw();
            }
        },
        setData: function(data, redraw) {
            var series = this, oldData = series.points, options = series.options, chart = series.chart, firstPoint = null, xAxis = series.xAxis, names = xAxis && xAxis.categories && !xAxis.categories.length ? [] : null, i;
            series.xIncrement = null;
            series.pointRange = xAxis && xAxis.categories ? 1 : options.pointRange;
            series.colorCounter = 0;
            var xData = [], yData = [], zData = [], dataLength = data ? data.length : [], turboThreshold = pick(options.turboThreshold, 1e3), pt, pointArrayMap = series.pointArrayMap, valueCount = pointArrayMap && pointArrayMap.length, hasToYData = !!series.toYData;
            if (turboThreshold && dataLength > turboThreshold) {
                i = 0;
                while (firstPoint === null && i < dataLength) {
                    firstPoint = data[i];
                    i++;
                }
                if (isNumber(firstPoint)) {
                    var x = pick(options.pointStart, 0), pointInterval = pick(options.pointInterval, 1);
                    for (i = 0; i < dataLength; i++) {
                        xData[i] = x;
                        yData[i] = data[i];
                        x += pointInterval;
                    }
                    series.xIncrement = x;
                } else if (isArray(firstPoint)) {
                    if (valueCount) {
                        for (i = 0; i < dataLength; i++) {
                            pt = data[i];
                            xData[i] = pt[0];
                            yData[i] = pt.slice(1, valueCount + 1);
                        }
                    } else {
                        for (i = 0; i < dataLength; i++) {
                            pt = data[i];
                            xData[i] = pt[0];
                            yData[i] = pt[1];
                        }
                    }
                } else {
                    error(12);
                }
            } else {
                for (i = 0; i < dataLength; i++) {
                    if (data[i] !== UNDEFINED) {
                        pt = {
                            series: series
                        };
                        series.pointClass.prototype.applyOptions.apply(pt, [ data[i] ]);
                        xData[i] = pt.x;
                        yData[i] = hasToYData ? series.toYData(pt) : pt.y;
                        zData[i] = pt.z;
                        if (names && pt.name) {
                            names[pt.x] = pt.name;
                        }
                    }
                }
            }
            if (isString(yData[0])) {
                error(14, true);
            }
            series.data = [];
            series.options.data = data;
            series.xData = xData;
            series.yData = yData;
            series.zData = zData;
            series.names = names;
            i = oldData && oldData.length || 0;
            while (i--) {
                if (oldData[i] && oldData[i].destroy) {
                    oldData[i].destroy();
                }
            }
            if (xAxis) {
                xAxis.minRange = xAxis.userMinRange;
            }
            series.isDirty = series.isDirtyData = chart.isDirtyBox = true;
            if (pick(redraw, true)) {
                chart.redraw(false);
            }
        },
        remove: function(redraw, animation) {
            var series = this, chart = series.chart;
            redraw = pick(redraw, true);
            if (!series.isRemoving) {
                series.isRemoving = true;
                fireEvent(series, "remove", null, function() {
                    series.destroy();
                    chart.isDirtyLegend = chart.isDirtyBox = true;
                    chart.linkSeries();
                    if (redraw) {
                        chart.redraw(animation);
                    }
                });
            }
            series.isRemoving = false;
        },
        processData: function(force) {
            var series = this, processedXData = series.xData, processedYData = series.yData, dataLength = processedXData.length, croppedData, cropStart = 0, cropped, distance, closestPointRange, xAxis = series.xAxis, i, options = series.options, cropThreshold = options.cropThreshold, isCartesian = series.isCartesian;
            if (isCartesian && !series.isDirty && !xAxis.isDirty && !series.yAxis.isDirty && !force) {
                return false;
            }
            if (isCartesian && series.sorted && (!cropThreshold || dataLength > cropThreshold || series.forceCrop)) {
                var min = xAxis.min, max = xAxis.max;
                if (processedXData[dataLength - 1] < min || processedXData[0] > max) {
                    processedXData = [];
                    processedYData = [];
                } else if (processedXData[0] < min || processedXData[dataLength - 1] > max) {
                    croppedData = this.cropData(series.xData, series.yData, min, max);
                    processedXData = croppedData.xData;
                    processedYData = croppedData.yData;
                    cropStart = croppedData.start;
                    cropped = true;
                }
            }
            for (i = processedXData.length - 1; i >= 0; i--) {
                distance = processedXData[i] - processedXData[i - 1];
                if (distance > 0 && (closestPointRange === UNDEFINED || distance < closestPointRange)) {
                    closestPointRange = distance;
                } else if (distance < 0 && series.requireSorting) {
                    error(15);
                }
            }
            series.cropped = cropped;
            series.cropStart = cropStart;
            series.processedXData = processedXData;
            series.processedYData = processedYData;
            if (options.pointRange === null) {
                series.pointRange = closestPointRange || 1;
            }
            series.closestPointRange = closestPointRange;
        },
        cropData: function(xData, yData, min, max) {
            var dataLength = xData.length, cropStart = 0, cropEnd = dataLength, i;
            for (i = 0; i < dataLength; i++) {
                if (xData[i] >= min) {
                    cropStart = mathMax(0, i - 1);
                    break;
                }
            }
            for (;i < dataLength; i++) {
                if (xData[i] > max) {
                    cropEnd = i + 1;
                    break;
                }
            }
            return {
                xData: xData.slice(cropStart, cropEnd),
                yData: yData.slice(cropStart, cropEnd),
                start: cropStart,
                end: cropEnd
            };
        },
        generatePoints: function() {
            var series = this, options = series.options, dataOptions = options.data, data = series.data, dataLength, processedXData = series.processedXData, processedYData = series.processedYData, pointClass = series.pointClass, processedDataLength = processedXData.length, cropStart = series.cropStart || 0, cursor, hasGroupedData = series.hasGroupedData, point, points = [], i;
            if (!data && !hasGroupedData) {
                var arr = [];
                arr.length = dataOptions.length;
                data = series.data = arr;
            }
            for (i = 0; i < processedDataLength; i++) {
                cursor = cropStart + i;
                if (!hasGroupedData) {
                    if (data[cursor]) {
                        point = data[cursor];
                    } else if (dataOptions[cursor] !== UNDEFINED) {
                        data[cursor] = point = new pointClass().init(series, dataOptions[cursor], processedXData[i]);
                    }
                    points[i] = point;
                } else {
                    points[i] = new pointClass().init(series, [ processedXData[i] ].concat(splat(processedYData[i])));
                }
            }
            if (data && (processedDataLength !== (dataLength = data.length) || hasGroupedData)) {
                for (i = 0; i < dataLength; i++) {
                    if (i === cropStart && !hasGroupedData) {
                        i += processedDataLength;
                    }
                    if (data[i]) {
                        data[i].destroyElements();
                        data[i].plotX = UNDEFINED;
                    }
                }
            }
            series.data = data;
            series.points = points;
        },
        setStackedPoints: function() {
            if (!this.options.stacking || this.visible !== true && this.chart.options.chart.ignoreHiddenSeries !== false) {
                return;
            }
            var series = this, xData = series.processedXData, yData = series.processedYData, yDataLength = yData.length, seriesOptions = series.options, threshold = seriesOptions.threshold, stackOption = seriesOptions.stack, stacking = seriesOptions.stacking, stackKey = series.stackKey, negKey = "-" + stackKey, yAxis = series.yAxis, stacks = yAxis.stacks, oldStacks = yAxis.oldStacks, stackExtremes = yAxis.stackExtremes, isNegative, total, stack, key, i, x, y;
            for (i = 0; i < yDataLength; i++) {
                x = xData[i];
                y = yData[i];
                isNegative = series.negStacks && y < threshold;
                key = isNegative ? negKey : stackKey;
                if (typeof y === "number" && !stackExtremes[stackKey]) {
                    stackExtremes[stackKey] = {
                        dataMin: y,
                        dataMax: y
                    };
                }
                if (!stacks[key]) {
                    stacks[key] = {};
                }
                if (!stacks[key][x]) {
                    if (oldStacks[key] && oldStacks[key][x]) {
                        stacks[key][x] = oldStacks[key][x];
                        stacks[key][x].total = null;
                    } else {
                        stacks[key][x] = new StackItem(yAxis, yAxis.options.stackLabels, isNegative, x, stackOption, stacking);
                    }
                }
                stack = stacks[key][x];
                total = stack.total;
                stack.addValue(y || 0);
                stack.cacheExtremes(series, [ total, total + (y || 0) ]);
                if (typeof y === "number") {
                    stackExtremes[stackKey].dataMin = mathMin(stackExtremes[stackKey].dataMin, stack.total, y);
                    stackExtremes[stackKey].dataMax = mathMax(stackExtremes[stackKey].dataMax, stack.total, y);
                }
            }
            yAxis.oldStacks = {};
        },
        getExtremes: function() {
            var xAxis = this.xAxis, yAxis = this.yAxis, stackKey = this.stackKey, stackExtremes, stackMin, stackMax, options = this.options, threshold = yAxis.isLog ? null : options.threshold, xData = this.processedXData, yData = this.processedYData, yDataLength = yData.length, activeYData = [], activeCounter = 0, xExtremes = xAxis.getExtremes(), xMin = xExtremes.min, xMax = xExtremes.max, validValue, withinRange, dataMin, dataMax, x, y, i, j;
            if (options.stacking) {
                stackExtremes = yAxis.stackExtremes[stackKey];
                stackMin = stackExtremes.dataMin;
                stackMax = stackExtremes.dataMax;
                dataMin = mathMin(stackMin, pick(threshold, stackMin));
                dataMax = mathMax(stackMax, pick(threshold, stackMax));
            }
            if (!defined(dataMin) || !defined(dataMax)) {
                for (i = 0; i < yDataLength; i++) {
                    x = xData[i];
                    y = yData[i];
                    validValue = y !== null && y !== UNDEFINED && (!yAxis.isLog || y.length || y > 0);
                    withinRange = this.getExtremesFromAll || this.cropped || (xData[i + 1] || x) >= xMin && (xData[i - 1] || x) <= xMax;
                    if (validValue && withinRange) {
                        j = y.length;
                        if (j) {
                            while (j--) {
                                if (y[j] !== null) {
                                    activeYData[activeCounter++] = y[j];
                                }
                            }
                        } else {
                            activeYData[activeCounter++] = y;
                        }
                    }
                }
                dataMin = pick(dataMin, arrayMin(activeYData));
                dataMax = pick(dataMax, arrayMax(activeYData));
            }
            this.dataMin = dataMin;
            this.dataMax = dataMax;
        },
        translate: function() {
            if (!this.processedXData) {
                this.processData();
            }
            this.generatePoints();
            var series = this, options = series.options, stacking = options.stacking, xAxis = series.xAxis, categories = xAxis.categories, yAxis = series.yAxis, points = series.points, dataLength = points.length, hasModifyValue = !!series.modifyValue, i, pointPlacement = options.pointPlacement, dynamicallyPlaced = pointPlacement === "between" || isNumber(pointPlacement), threshold = options.threshold;
            for (i = 0; i < dataLength; i++) {
                var point = points[i], xValue = point.x, yValue = point.y, yBottom = point.low, stack = yAxis.stacks[(series.negStacks && yValue < threshold ? "-" : "") + series.stackKey], pointStack, pointStackTotal;
                if (yAxis.isLog && yValue <= 0) {
                    point.y = yValue = null;
                }
                point.plotX = xAxis.translate(xValue, 0, 0, 0, 1, pointPlacement);
                if (stacking && series.visible && stack && stack[xValue]) {
                    pointStack = stack[xValue];
                    pointStackTotal = pointStack.total;
                    pointStack.cum = yBottom = pointStack.cum - yValue;
                    yValue = yBottom + yValue;
                    if (pointStack.cum === 0) {
                        yBottom = pick(threshold, yAxis.min);
                    }
                    if (yAxis.isLog && yBottom <= 0) {
                        yBottom = null;
                    }
                    if (stacking === "percent") {
                        yBottom = pointStackTotal ? yBottom * 100 / pointStackTotal : 0;
                        yValue = pointStackTotal ? yValue * 100 / pointStackTotal : 0;
                    }
                    point.percentage = pointStackTotal ? point.y * 100 / pointStackTotal : 0;
                    point.total = point.stackTotal = pointStackTotal;
                    point.stackY = yValue;
                    pointStack.setOffset(series.pointXOffset || 0, series.barW || 0);
                }
                point.yBottom = defined(yBottom) ? yAxis.translate(yBottom, 0, 1, 0, 1) : null;
                if (hasModifyValue) {
                    yValue = series.modifyValue(yValue, point);
                }
                point.plotY = typeof yValue === "number" && yValue !== Infinity ? yAxis.translate(yValue, 0, 1, 0, 1) : UNDEFINED;
                point.clientX = dynamicallyPlaced ? xAxis.translate(xValue, 0, 0, 0, 1) : point.plotX;
                point.negative = point.y < (threshold || 0);
                point.category = categories && categories[point.x] !== UNDEFINED ? categories[point.x] : point.x;
            }
            series.getSegments();
        },
        setTooltipPoints: function(renew) {
            var series = this, points = [], pointsLength, low, high, xAxis = series.xAxis, axisLength = xAxis ? xAxis.tooltipLen || xAxis.len : series.chart.plotSizeX, point, nextPoint, i, tooltipPoints = [];
            if (series.options.enableMouseTracking === false) {
                return;
            }
            if (renew) {
                series.tooltipPoints = null;
            }
            each(series.segments || series.points, function(segment) {
                points = points.concat(segment);
            });
            if (xAxis && xAxis.reversed) {
                points = points.reverse();
            }
            if (series.orderTooltipPoints) {
                series.orderTooltipPoints(points);
            }
            pointsLength = points.length;
            for (i = 0; i < pointsLength; i++) {
                point = points[i];
                nextPoint = points[i + 1];
                low = points[i - 1] ? high + 1 : 0;
                high = points[i + 1] ? mathMin(mathMax(0, mathFloor((point.clientX + (nextPoint ? nextPoint.wrappedClientX || nextPoint.clientX : axisLength)) / 2)), axisLength) : axisLength;
                while (low >= 0 && low <= high) {
                    tooltipPoints[low++] = point;
                }
            }
            series.tooltipPoints = tooltipPoints;
        },
        tooltipHeaderFormatter: function(point) {
            var series = this, tooltipOptions = series.tooltipOptions, xDateFormat = tooltipOptions.xDateFormat, dateTimeLabelFormats = tooltipOptions.dateTimeLabelFormats, xAxis = series.xAxis, isDateTime = xAxis && xAxis.options.type === "datetime", headerFormat = tooltipOptions.headerFormat, closestPointRange = xAxis && xAxis.closestPointRange, n;
            if (isDateTime && !xDateFormat) {
                if (closestPointRange) {
                    for (n in timeUnits) {
                        if (timeUnits[n] >= closestPointRange) {
                            xDateFormat = dateTimeLabelFormats[n];
                            break;
                        }
                    }
                } else {
                    xDateFormat = dateTimeLabelFormats.day;
                }
            }
            if (isDateTime && xDateFormat && isNumber(point.key)) {
                headerFormat = headerFormat.replace("{point.key}", "{point.key:" + xDateFormat + "}");
            }
            return format(headerFormat, {
                point: point,
                series: series
            });
        },
        onMouseOver: function() {
            var series = this, chart = series.chart, hoverSeries = chart.hoverSeries;
            if (hoverSeries && hoverSeries !== series) {
                hoverSeries.onMouseOut();
            }
            if (series.options.events.mouseOver) {
                fireEvent(series, "mouseOver");
            }
            series.setState(HOVER_STATE);
            chart.hoverSeries = series;
        },
        onMouseOut: function() {
            var series = this, options = series.options, chart = series.chart, tooltip = chart.tooltip, hoverPoint = chart.hoverPoint;
            if (hoverPoint) {
                hoverPoint.onMouseOut();
            }
            if (series && options.events.mouseOut) {
                fireEvent(series, "mouseOut");
            }
            if (tooltip && !options.stickyTracking && (!tooltip.shared || series.noSharedTooltip)) {
                tooltip.hide();
            }
            series.setState();
            chart.hoverSeries = null;
        },
        animate: function(init) {
            var series = this, chart = series.chart, renderer = chart.renderer, clipRect, markerClipRect, animation = series.options.animation, clipBox = chart.clipBox, inverted = chart.inverted, sharedClipKey;
            if (animation && !isObject(animation)) {
                animation = defaultPlotOptions[series.type].animation;
            }
            sharedClipKey = "_sharedClip" + animation.duration + animation.easing;
            if (init) {
                clipRect = chart[sharedClipKey];
                markerClipRect = chart[sharedClipKey + "m"];
                if (!clipRect) {
                    chart[sharedClipKey] = clipRect = renderer.clipRect(extend(clipBox, {
                        width: 0
                    }));
                    chart[sharedClipKey + "m"] = markerClipRect = renderer.clipRect(-99, inverted ? -chart.plotLeft : -chart.plotTop, 99, inverted ? chart.chartWidth : chart.chartHeight);
                }
                series.group.clip(clipRect);
                series.markerGroup.clip(markerClipRect);
                series.sharedClipKey = sharedClipKey;
            } else {
                clipRect = chart[sharedClipKey];
                if (clipRect) {
                    clipRect.animate({
                        width: chart.plotSizeX
                    }, animation);
                    chart[sharedClipKey + "m"].animate({
                        width: chart.plotSizeX + 99
                    }, animation);
                }
                series.animate = null;
                series.animationTimeout = setTimeout(function() {
                    series.afterAnimate();
                }, animation.duration);
            }
        },
        afterAnimate: function() {
            var chart = this.chart, sharedClipKey = this.sharedClipKey, group = this.group;
            if (group && this.options.clip !== false) {
                group.clip(chart.clipRect);
                this.markerGroup.clip();
            }
            setTimeout(function() {
                if (sharedClipKey && chart[sharedClipKey]) {
                    chart[sharedClipKey] = chart[sharedClipKey].destroy();
                    chart[sharedClipKey + "m"] = chart[sharedClipKey + "m"].destroy();
                }
            }, 100);
        },
        drawPoints: function() {
            var series = this, pointAttr, points = series.points, chart = series.chart, plotX, plotY, i, point, radius, symbol, isImage, graphic, options = series.options, seriesMarkerOptions = options.marker, pointMarkerOptions, enabled, isInside, markerGroup = series.markerGroup;
            if (seriesMarkerOptions.enabled || series._hasPointMarkers) {
                i = points.length;
                while (i--) {
                    point = points[i];
                    plotX = mathFloor(point.plotX);
                    plotY = point.plotY;
                    graphic = point.graphic;
                    pointMarkerOptions = point.marker || {};
                    enabled = seriesMarkerOptions.enabled && pointMarkerOptions.enabled === UNDEFINED || pointMarkerOptions.enabled;
                    isInside = chart.isInsidePlot(mathRound(plotX), plotY, chart.inverted);
                    if (enabled && plotY !== UNDEFINED && !isNaN(plotY) && point.y !== null) {
                        pointAttr = point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE];
                        radius = pointAttr.r;
                        symbol = pick(pointMarkerOptions.symbol, series.symbol);
                        isImage = symbol.indexOf("url") === 0;
                        if (graphic) {
                            graphic.attr({
                                visibility: isInside ? hasSVG ? "inherit" : VISIBLE : HIDDEN
                            }).animate(extend({
                                x: plotX - radius,
                                y: plotY - radius
                            }, graphic.symbolName ? {
                                width: 2 * radius,
                                height: 2 * radius
                            } : {}));
                        } else if (isInside && (radius > 0 || isImage)) {
                            point.graphic = graphic = chart.renderer.symbol(symbol, plotX - radius, plotY - radius, 2 * radius, 2 * radius).attr(pointAttr).add(markerGroup);
                        }
                    } else if (graphic) {
                        point.graphic = graphic.destroy();
                    }
                }
            }
        },
        convertAttribs: function(options, base1, base2, base3) {
            var conversion = this.pointAttrToOptions, attr, option, obj = {};
            options = options || {};
            base1 = base1 || {};
            base2 = base2 || {};
            base3 = base3 || {};
            for (attr in conversion) {
                option = conversion[attr];
                obj[attr] = pick(options[option], base1[attr], base2[attr], base3[attr]);
            }
            return obj;
        },
        getAttribs: function() {
            var series = this, seriesOptions = series.options, normalOptions = defaultPlotOptions[series.type].marker ? seriesOptions.marker : seriesOptions, stateOptions = normalOptions.states, stateOptionsHover = stateOptions[HOVER_STATE], pointStateOptionsHover, seriesColor = series.color, normalDefaults = {
                stroke: seriesColor,
                fill: seriesColor
            }, points = series.points || [], i, point, seriesPointAttr = [], pointAttr, pointAttrToOptions = series.pointAttrToOptions, hasPointSpecificOptions, negativeColor = seriesOptions.negativeColor, key;
            if (seriesOptions.marker) {
                stateOptionsHover.radius = stateOptionsHover.radius || normalOptions.radius + 2;
                stateOptionsHover.lineWidth = stateOptionsHover.lineWidth || normalOptions.lineWidth + 1;
            } else {
                stateOptionsHover.color = stateOptionsHover.color || Color(stateOptionsHover.color || seriesColor).brighten(stateOptionsHover.brightness).get();
            }
            seriesPointAttr[NORMAL_STATE] = series.convertAttribs(normalOptions, normalDefaults);
            each([ HOVER_STATE, SELECT_STATE ], function(state) {
                seriesPointAttr[state] = series.convertAttribs(stateOptions[state], seriesPointAttr[NORMAL_STATE]);
            });
            series.pointAttr = seriesPointAttr;
            i = points.length;
            while (i--) {
                point = points[i];
                normalOptions = point.options && point.options.marker || point.options;
                if (normalOptions && normalOptions.enabled === false) {
                    normalOptions.radius = 0;
                }
                if (point.negative && negativeColor) {
                    point.color = point.fillColor = negativeColor;
                }
                hasPointSpecificOptions = seriesOptions.colorByPoint || point.color;
                if (point.options) {
                    for (key in pointAttrToOptions) {
                        if (defined(normalOptions[pointAttrToOptions[key]])) {
                            hasPointSpecificOptions = true;
                        }
                    }
                }
                if (hasPointSpecificOptions) {
                    normalOptions = normalOptions || {};
                    pointAttr = [];
                    stateOptions = normalOptions.states || {};
                    pointStateOptionsHover = stateOptions[HOVER_STATE] = stateOptions[HOVER_STATE] || {};
                    if (!seriesOptions.marker) {
                        pointStateOptionsHover.color = Color(pointStateOptionsHover.color || point.color).brighten(pointStateOptionsHover.brightness || stateOptionsHover.brightness).get();
                    }
                    pointAttr[NORMAL_STATE] = series.convertAttribs(extend({
                        color: point.color
                    }, normalOptions), seriesPointAttr[NORMAL_STATE]);
                    pointAttr[HOVER_STATE] = series.convertAttribs(stateOptions[HOVER_STATE], seriesPointAttr[HOVER_STATE], pointAttr[NORMAL_STATE]);
                    pointAttr[SELECT_STATE] = series.convertAttribs(stateOptions[SELECT_STATE], seriesPointAttr[SELECT_STATE], pointAttr[NORMAL_STATE]);
                    if (point.negative && seriesOptions.marker && negativeColor) {
                        pointAttr[NORMAL_STATE].fill = pointAttr[HOVER_STATE].fill = pointAttr[SELECT_STATE].fill = series.convertAttribs({
                            fillColor: negativeColor
                        }).fill;
                    }
                } else {
                    pointAttr = seriesPointAttr;
                }
                point.pointAttr = pointAttr;
            }
        },
        update: function(newOptions, redraw) {
            var chart = this.chart, oldOptions = this.userOptions, oldType = this.type;
            newOptions = merge(oldOptions, {
                animation: false,
                index: this.index,
                pointStart: this.xData[0]
            }, {
                data: this.options.data
            }, newOptions);
            this.remove(false);
            extend(this, seriesTypes[newOptions.type || oldType].prototype);
            this.init(chart, newOptions);
            if (pick(redraw, true)) {
                chart.redraw(false);
            }
        },
        destroy: function() {
            var series = this, chart = series.chart, issue134 = /AppleWebKit\/533/.test(userAgent), destroy, i, data = series.data || [], point, prop, axis;
            fireEvent(series, "destroy");
            removeEvent(series);
            each([ "xAxis", "yAxis" ], function(AXIS) {
                axis = series[AXIS];
                if (axis) {
                    erase(axis.series, series);
                    axis.isDirty = axis.forceRedraw = true;
                }
            });
            if (series.legendItem) {
                series.chart.legend.destroyItem(series);
            }
            i = data.length;
            while (i--) {
                point = data[i];
                if (point && point.destroy) {
                    point.destroy();
                }
            }
            series.points = null;
            clearTimeout(series.animationTimeout);
            each([ "area", "graph", "dataLabelsGroup", "group", "markerGroup", "tracker", "graphNeg", "areaNeg", "posClip", "negClip" ], function(prop) {
                if (series[prop]) {
                    destroy = issue134 && prop === "group" ? "hide" : "destroy";
                    series[prop][destroy]();
                }
            });
            if (chart.hoverSeries === series) {
                chart.hoverSeries = null;
            }
            erase(chart.series, series);
            for (prop in series) {
                delete series[prop];
            }
        },
        drawDataLabels: function() {
            var series = this, seriesOptions = series.options, options = seriesOptions.dataLabels, points = series.points, pointOptions, generalOptions, str, dataLabelsGroup;
            if (options.enabled || series._hasPointLabels) {
                if (series.dlProcessOptions) {
                    series.dlProcessOptions(options);
                }
                dataLabelsGroup = series.plotGroup("dataLabelsGroup", "data-labels", series.visible ? VISIBLE : HIDDEN, options.zIndex || 6);
                generalOptions = options;
                each(points, function(point) {
                    var enabled, dataLabel = point.dataLabel, labelConfig, attr, name, rotation, connector = point.connector, isNew = true;
                    pointOptions = point.options && point.options.dataLabels;
                    enabled = generalOptions.enabled || pointOptions && pointOptions.enabled;
                    if (dataLabel && !enabled) {
                        point.dataLabel = dataLabel.destroy();
                    } else if (enabled) {
                        options = merge(generalOptions, pointOptions);
                        rotation = options.rotation;
                        labelConfig = point.getLabelConfig();
                        str = options.format ? format(options.format, labelConfig) : options.formatter.call(labelConfig, options);
                        options.style.color = pick(options.color, options.style.color, series.color, "black");
                        if (dataLabel) {
                            if (defined(str)) {
                                dataLabel.attr({
                                    text: str
                                });
                                isNew = false;
                            } else {
                                point.dataLabel = dataLabel = dataLabel.destroy();
                                if (connector) {
                                    point.connector = connector.destroy();
                                }
                            }
                        } else if (defined(str)) {
                            attr = {
                                fill: options.backgroundColor,
                                stroke: options.borderColor,
                                "stroke-width": options.borderWidth,
                                r: options.borderRadius || 0,
                                rotation: rotation,
                                padding: options.padding,
                                zIndex: 1
                            };
                            for (name in attr) {
                                if (attr[name] === UNDEFINED) {
                                    delete attr[name];
                                }
                            }
                            dataLabel = point.dataLabel = series.chart.renderer[rotation ? "text" : "label"](str, 0, -999, null, null, null, options.useHTML).attr(attr).css(options.style).add(dataLabelsGroup).shadow(options.shadow);
                        }
                        if (dataLabel) {
                            series.alignDataLabel(point, dataLabel, options, null, isNew);
                        }
                    }
                });
            }
        },
        alignDataLabel: function(point, dataLabel, options, alignTo, isNew) {
            var chart = this.chart, inverted = chart.inverted, plotX = pick(point.plotX, -999), plotY = pick(point.plotY, -999), bBox = dataLabel.getBBox(), alignAttr;
            alignTo = extend({
                x: inverted ? chart.plotWidth - plotY : plotX,
                y: mathRound(inverted ? chart.plotHeight - plotX : plotY),
                width: 0,
                height: 0
            }, alignTo);
            extend(options, {
                width: bBox.width,
                height: bBox.height
            });
            if (options.rotation) {
                alignAttr = {
                    align: options.align,
                    x: alignTo.x + options.x + alignTo.width / 2,
                    y: alignTo.y + options.y + alignTo.height / 2
                };
                dataLabel[isNew ? "attr" : "animate"](alignAttr);
            } else {
                dataLabel.align(options, null, alignTo);
                alignAttr = dataLabel.alignAttr;
            }
            dataLabel.attr({
                visibility: options.crop === false || chart.isInsidePlot(alignAttr.x, alignAttr.y) && chart.isInsidePlot(alignAttr.x + bBox.width, alignAttr.y + bBox.height) ? chart.renderer.isSVG ? "inherit" : VISIBLE : HIDDEN
            });
        },
        getSegmentPath: function(segment) {
            var series = this, segmentPath = [], step = series.options.step;
            each(segment, function(point, i) {
                var plotX = point.plotX, plotY = point.plotY, lastPoint;
                if (series.getPointSpline) {
                    segmentPath.push.apply(segmentPath, series.getPointSpline(segment, point, i));
                } else {
                    segmentPath.push(i ? L : M);
                    if (step && i) {
                        lastPoint = segment[i - 1];
                        if (step === "right") {
                            segmentPath.push(lastPoint.plotX, plotY);
                        } else if (step === "center") {
                            segmentPath.push((lastPoint.plotX + plotX) / 2, lastPoint.plotY, (lastPoint.plotX + plotX) / 2, plotY);
                        } else {
                            segmentPath.push(plotX, lastPoint.plotY);
                        }
                    }
                    segmentPath.push(point.plotX, point.plotY);
                }
            });
            return segmentPath;
        },
        getGraphPath: function() {
            var series = this, graphPath = [], segmentPath, singlePoints = [];
            each(series.segments, function(segment) {
                segmentPath = series.getSegmentPath(segment);
                if (segment.length > 1) {
                    graphPath = graphPath.concat(segmentPath);
                } else {
                    singlePoints.push(segment[0]);
                }
            });
            series.singlePoints = singlePoints;
            series.graphPath = graphPath;
            return graphPath;
        },
        drawGraph: function() {
            var series = this, options = this.options, props = [ [ "graph", options.lineColor || this.color ] ], lineWidth = options.lineWidth, dashStyle = options.dashStyle, graphPath = this.getGraphPath(), negativeColor = options.negativeColor;
            if (negativeColor) {
                props.push([ "graphNeg", negativeColor ]);
            }
            each(props, function(prop, i) {
                var graphKey = prop[0], graph = series[graphKey], attribs;
                if (graph) {
                    stop(graph);
                    graph.animate({
                        d: graphPath
                    });
                } else if (lineWidth && graphPath.length) {
                    attribs = {
                        stroke: prop[1],
                        "stroke-width": lineWidth,
                        zIndex: 1
                    };
                    if (dashStyle) {
                        attribs.dashstyle = dashStyle;
                    }
                    series[graphKey] = series.chart.renderer.path(graphPath).attr(attribs).add(series.group).shadow(!i && options.shadow);
                }
            });
        },
        clipNeg: function() {
            var options = this.options, chart = this.chart, renderer = chart.renderer, negativeColor = options.negativeColor || options.negativeFillColor, translatedThreshold, posAttr, negAttr, graph = this.graph, area = this.area, posClip = this.posClip, negClip = this.negClip, chartWidth = chart.chartWidth, chartHeight = chart.chartHeight, chartSizeMax = mathMax(chartWidth, chartHeight), yAxis = this.yAxis, above, below;
            if (negativeColor && (graph || area)) {
                translatedThreshold = mathRound(yAxis.toPixels(options.threshold || 0, true));
                above = {
                    x: 0,
                    y: 0,
                    width: chartSizeMax,
                    height: translatedThreshold
                };
                below = {
                    x: 0,
                    y: translatedThreshold,
                    width: chartSizeMax,
                    height: chartSizeMax
                };
                if (chart.inverted) {
                    above.height = below.y = chart.plotWidth - translatedThreshold;
                    if (renderer.isVML) {
                        above = {
                            x: chart.plotWidth - translatedThreshold - chart.plotLeft,
                            y: 0,
                            width: chartWidth,
                            height: chartHeight
                        };
                        below = {
                            x: translatedThreshold + chart.plotLeft - chartWidth,
                            y: 0,
                            width: chart.plotLeft + translatedThreshold,
                            height: chartWidth
                        };
                    }
                }
                if (yAxis.reversed) {
                    posAttr = below;
                    negAttr = above;
                } else {
                    posAttr = above;
                    negAttr = below;
                }
                if (posClip) {
                    posClip.animate(posAttr);
                    negClip.animate(negAttr);
                } else {
                    this.posClip = posClip = renderer.clipRect(posAttr);
                    this.negClip = negClip = renderer.clipRect(negAttr);
                    if (graph && this.graphNeg) {
                        graph.clip(posClip);
                        this.graphNeg.clip(negClip);
                    }
                    if (area) {
                        area.clip(posClip);
                        this.areaNeg.clip(negClip);
                    }
                }
            }
        },
        invertGroups: function() {
            var series = this, chart = series.chart;
            if (!series.xAxis) {
                return;
            }
            function setInvert() {
                var size = {
                    width: series.yAxis.len,
                    height: series.xAxis.len
                };
                each([ "group", "markerGroup" ], function(groupName) {
                    if (series[groupName]) {
                        series[groupName].attr(size).invert();
                    }
                });
            }
            addEvent(chart, "resize", setInvert);
            addEvent(series, "destroy", function() {
                removeEvent(chart, "resize", setInvert);
            });
            setInvert();
            series.invertGroups = setInvert;
        },
        plotGroup: function(prop, name, visibility, zIndex, parent) {
            var group = this[prop], isNew = !group;
            if (isNew) {
                this[prop] = group = this.chart.renderer.g(name).attr({
                    visibility: visibility,
                    zIndex: zIndex || .1
                }).add(parent);
            }
            group[isNew ? "attr" : "animate"](this.getPlotBox());
            return group;
        },
        getPlotBox: function() {
            return {
                translateX: this.xAxis ? this.xAxis.left : this.chart.plotLeft,
                translateY: this.yAxis ? this.yAxis.top : this.chart.plotTop,
                scaleX: 1,
                scaleY: 1
            };
        },
        render: function() {
            var series = this, chart = series.chart, group, options = series.options, animation = options.animation, doAnimation = animation && !!series.animate && chart.renderer.isSVG, visibility = series.visible ? VISIBLE : HIDDEN, zIndex = options.zIndex, hasRendered = series.hasRendered, chartSeriesGroup = chart.seriesGroup;
            group = series.plotGroup("group", "series", visibility, zIndex, chartSeriesGroup);
            series.markerGroup = series.plotGroup("markerGroup", "markers", visibility, zIndex, chartSeriesGroup);
            if (doAnimation) {
                series.animate(true);
            }
            series.getAttribs();
            group.inverted = series.isCartesian ? chart.inverted : false;
            if (series.drawGraph) {
                series.drawGraph();
                series.clipNeg();
            }
            series.drawDataLabels();
            series.drawPoints();
            if (series.options.enableMouseTracking !== false) {
                series.drawTracker();
            }
            if (chart.inverted) {
                series.invertGroups();
            }
            if (options.clip !== false && !series.sharedClipKey && !hasRendered) {
                group.clip(chart.clipRect);
            }
            if (doAnimation) {
                series.animate();
            } else if (!hasRendered) {
                series.afterAnimate();
            }
            series.isDirty = series.isDirtyData = false;
            series.hasRendered = true;
        },
        redraw: function() {
            var series = this, chart = series.chart, wasDirtyData = series.isDirtyData, group = series.group, xAxis = series.xAxis, yAxis = series.yAxis;
            if (group) {
                if (chart.inverted) {
                    group.attr({
                        width: chart.plotWidth,
                        height: chart.plotHeight
                    });
                }
                group.animate({
                    translateX: pick(xAxis && xAxis.left, chart.plotLeft),
                    translateY: pick(yAxis && yAxis.top, chart.plotTop)
                });
            }
            series.translate();
            series.setTooltipPoints(true);
            series.render();
            if (wasDirtyData) {
                fireEvent(series, "updatedData");
            }
        },
        setState: function(state) {
            var series = this, options = series.options, graph = series.graph, graphNeg = series.graphNeg, stateOptions = options.states, lineWidth = options.lineWidth, attribs;
            state = state || NORMAL_STATE;
            if (series.state !== state) {
                series.state = state;
                if (stateOptions[state] && stateOptions[state].enabled === false) {
                    return;
                }
                if (state) {
                    lineWidth = stateOptions[state].lineWidth || lineWidth + 1;
                }
                if (graph && !graph.dashstyle) {
                    attribs = {
                        "stroke-width": lineWidth
                    };
                    graph.attr(attribs);
                    if (graphNeg) {
                        graphNeg.attr(attribs);
                    }
                }
            }
        },
        setVisible: function(vis, redraw) {
            var series = this, chart = series.chart, legendItem = series.legendItem, showOrHide, ignoreHiddenSeries = chart.options.chart.ignoreHiddenSeries, oldVisibility = series.visible;
            series.visible = vis = series.userOptions.visible = vis === UNDEFINED ? !oldVisibility : vis;
            showOrHide = vis ? "show" : "hide";
            each([ "group", "dataLabelsGroup", "markerGroup", "tracker" ], function(key) {
                if (series[key]) {
                    series[key][showOrHide]();
                }
            });
            if (chart.hoverSeries === series) {
                series.onMouseOut();
            }
            if (legendItem) {
                chart.legend.colorizeItem(series, vis);
            }
            series.isDirty = true;
            if (series.options.stacking) {
                each(chart.series, function(otherSeries) {
                    if (otherSeries.options.stacking && otherSeries.visible) {
                        otherSeries.isDirty = true;
                    }
                });
            }
            each(series.linkedSeries, function(otherSeries) {
                otherSeries.setVisible(vis, false);
            });
            if (ignoreHiddenSeries) {
                chart.isDirtyBox = true;
            }
            if (redraw !== false) {
                chart.redraw();
            }
            fireEvent(series, showOrHide);
        },
        show: function() {
            this.setVisible(true);
        },
        hide: function() {
            this.setVisible(false);
        },
        select: function(selected) {
            var series = this;
            series.selected = selected = selected === UNDEFINED ? !series.selected : selected;
            if (series.checkbox) {
                series.checkbox.checked = selected;
            }
            fireEvent(series, selected ? "select" : "unselect");
        },
        drawTracker: function() {
            var series = this, options = series.options, trackByArea = options.trackByArea, trackerPath = [].concat(trackByArea ? series.areaPath : series.graphPath), trackerPathLength = trackerPath.length, chart = series.chart, pointer = chart.pointer, renderer = chart.renderer, snap = chart.options.tooltip.snap, tracker = series.tracker, cursor = options.cursor, css = cursor && {
                cursor: cursor
            }, singlePoints = series.singlePoints, singlePoint, i, onMouseOver = function() {
                if (chart.hoverSeries !== series) {
                    series.onMouseOver();
                }
            };
            if (trackerPathLength && !trackByArea) {
                i = trackerPathLength + 1;
                while (i--) {
                    if (trackerPath[i] === M) {
                        trackerPath.splice(i + 1, 0, trackerPath[i + 1] - snap, trackerPath[i + 2], L);
                    }
                    if (i && trackerPath[i] === M || i === trackerPathLength) {
                        trackerPath.splice(i, 0, L, trackerPath[i - 2] + snap, trackerPath[i - 1]);
                    }
                }
            }
            for (i = 0; i < singlePoints.length; i++) {
                singlePoint = singlePoints[i];
                trackerPath.push(M, singlePoint.plotX - snap, singlePoint.plotY, L, singlePoint.plotX + snap, singlePoint.plotY);
            }
            if (tracker) {
                tracker.attr({
                    d: trackerPath
                });
            } else {
                series.tracker = renderer.path(trackerPath).attr({
                    "stroke-linejoin": "round",
                    visibility: series.visible ? VISIBLE : HIDDEN,
                    stroke: TRACKER_FILL,
                    fill: trackByArea ? TRACKER_FILL : NONE,
                    "stroke-width": options.lineWidth + (trackByArea ? 0 : 2 * snap),
                    zIndex: 2
                }).add(series.group);
                each([ series.tracker, series.markerGroup ], function(tracker) {
                    tracker.addClass(PREFIX + "tracker").on("mouseover", onMouseOver).on("mouseout", function(e) {
                        pointer.onTrackerMouseOut(e);
                    }).css(css);
                    if (hasTouch) {
                        tracker.on("touchstart", onMouseOver);
                    }
                });
            }
        }
    };
    var LineSeries = extendClass(Series);
    seriesTypes.line = LineSeries;
    defaultPlotOptions.area = merge(defaultSeriesOptions, {
        threshold: 0
    });
    var AreaSeries = extendClass(Series, {
        type: "area",
        getSegments: function() {
            var segments = [], segment = [], keys = [], xAxis = this.xAxis, yAxis = this.yAxis, stack = yAxis.stacks[this.stackKey], pointMap = {}, plotX, plotY, points = this.points, val, i, x;
            if (this.options.stacking && !this.cropped) {
                for (i = 0; i < points.length; i++) {
                    pointMap[points[i].x] = points[i];
                }
                for (x in stack) {
                    keys.push(+x);
                }
                keys.sort(function(a, b) {
                    return a - b;
                });
                each(keys, function(x) {
                    if (pointMap[x]) {
                        segment.push(pointMap[x]);
                    } else {
                        plotX = xAxis.translate(x);
                        val = stack[x].percent ? stack[x].total ? stack[x].cum * 100 / stack[x].total : 0 : stack[x].cum;
                        plotY = yAxis.toPixels(val, true);
                        segment.push({
                            y: null,
                            plotX: plotX,
                            clientX: plotX,
                            plotY: plotY,
                            yBottom: plotY,
                            onMouseOver: noop
                        });
                    }
                });
                if (segment.length) {
                    segments.push(segment);
                }
            } else {
                Series.prototype.getSegments.call(this);
                segments = this.segments;
            }
            this.segments = segments;
        },
        getSegmentPath: function(segment) {
            var segmentPath = Series.prototype.getSegmentPath.call(this, segment), areaSegmentPath = [].concat(segmentPath), i, options = this.options, segLength = segmentPath.length;
            if (segLength === 3) {
                areaSegmentPath.push(L, segmentPath[1], segmentPath[2]);
            }
            if (options.stacking && !this.closedStacks) {
                for (i = segment.length - 1; i >= 0; i--) {
                    if (i < segment.length - 1 && options.step) {
                        areaSegmentPath.push(segment[i + 1].plotX, segment[i].yBottom);
                    }
                    areaSegmentPath.push(segment[i].plotX, segment[i].yBottom);
                }
            } else {
                this.closeSegment(areaSegmentPath, segment);
            }
            this.areaPath = this.areaPath.concat(areaSegmentPath);
            return segmentPath;
        },
        closeSegment: function(path, segment) {
            var translatedThreshold = this.yAxis.getThreshold(this.options.threshold);
            path.push(L, segment[segment.length - 1].plotX, translatedThreshold, L, segment[0].plotX, translatedThreshold);
        },
        drawGraph: function() {
            this.areaPath = [];
            Series.prototype.drawGraph.apply(this);
            var series = this, areaPath = this.areaPath, options = this.options, negativeColor = options.negativeColor, negativeFillColor = options.negativeFillColor, props = [ [ "area", this.color, options.fillColor ] ];
            if (negativeColor || negativeFillColor) {
                props.push([ "areaNeg", negativeColor, negativeFillColor ]);
            }
            each(props, function(prop) {
                var areaKey = prop[0], area = series[areaKey];
                if (area) {
                    area.animate({
                        d: areaPath
                    });
                } else {
                    series[areaKey] = series.chart.renderer.path(areaPath).attr({
                        fill: pick(prop[2], Color(prop[1]).setOpacity(pick(options.fillOpacity, .75)).get()),
                        zIndex: 0
                    }).add(series.group);
                }
            });
        },
        drawLegendSymbol: function(legend, item) {
            item.legendSymbol = this.chart.renderer.rect(0, legend.baseline - 11, legend.options.symbolWidth, 12, 2).attr({
                zIndex: 3
            }).add(item.legendGroup);
        }
    });
    seriesTypes.area = AreaSeries;
    defaultPlotOptions.spline = merge(defaultSeriesOptions);
    var SplineSeries = extendClass(Series, {
        type: "spline",
        getPointSpline: function(segment, point, i) {
            var smoothing = 1.5, denom = smoothing + 1, plotX = point.plotX, plotY = point.plotY, lastPoint = segment[i - 1], nextPoint = segment[i + 1], leftContX, leftContY, rightContX, rightContY, ret;
            if (lastPoint && nextPoint) {
                var lastX = lastPoint.plotX, lastY = lastPoint.plotY, nextX = nextPoint.plotX, nextY = nextPoint.plotY, correction;
                leftContX = (smoothing * plotX + lastX) / denom;
                leftContY = (smoothing * plotY + lastY) / denom;
                rightContX = (smoothing * plotX + nextX) / denom;
                rightContY = (smoothing * plotY + nextY) / denom;
                correction = (rightContY - leftContY) * (rightContX - plotX) / (rightContX - leftContX) + plotY - rightContY;
                leftContY += correction;
                rightContY += correction;
                if (leftContY > lastY && leftContY > plotY) {
                    leftContY = mathMax(lastY, plotY);
                    rightContY = 2 * plotY - leftContY;
                } else if (leftContY < lastY && leftContY < plotY) {
                    leftContY = mathMin(lastY, plotY);
                    rightContY = 2 * plotY - leftContY;
                }
                if (rightContY > nextY && rightContY > plotY) {
                    rightContY = mathMax(nextY, plotY);
                    leftContY = 2 * plotY - rightContY;
                } else if (rightContY < nextY && rightContY < plotY) {
                    rightContY = mathMin(nextY, plotY);
                    leftContY = 2 * plotY - rightContY;
                }
                point.rightContX = rightContX;
                point.rightContY = rightContY;
            }
            if (!i) {
                ret = [ M, plotX, plotY ];
            } else {
                ret = [ "C", lastPoint.rightContX || lastPoint.plotX, lastPoint.rightContY || lastPoint.plotY, leftContX || plotX, leftContY || plotY, plotX, plotY ];
                lastPoint.rightContX = lastPoint.rightContY = null;
            }
            return ret;
        }
    });
    seriesTypes.spline = SplineSeries;
    defaultPlotOptions.areaspline = merge(defaultPlotOptions.area);
    var areaProto = AreaSeries.prototype, AreaSplineSeries = extendClass(SplineSeries, {
        type: "areaspline",
        closedStacks: true,
        getSegmentPath: areaProto.getSegmentPath,
        closeSegment: areaProto.closeSegment,
        drawGraph: areaProto.drawGraph,
        drawLegendSymbol: areaProto.drawLegendSymbol
    });
    seriesTypes.areaspline = AreaSplineSeries;
    defaultPlotOptions.column = merge(defaultSeriesOptions, {
        borderColor: "#FFFFFF",
        borderWidth: 1,
        borderRadius: 0,
        groupPadding: .2,
        marker: null,
        pointPadding: .1,
        minPointLength: 0,
        cropThreshold: 50,
        pointRange: null,
        states: {
            hover: {
                brightness: .1,
                shadow: false
            },
            select: {
                color: "#C0C0C0",
                borderColor: "#000000",
                shadow: false
            }
        },
        dataLabels: {
            align: null,
            verticalAlign: null,
            y: null
        },
        stickyTracking: false,
        threshold: 0
    });
    var ColumnSeries = extendClass(Series, {
        type: "column",
        pointAttrToOptions: {
            stroke: "borderColor",
            "stroke-width": "borderWidth",
            fill: "color",
            r: "borderRadius"
        },
        trackerGroups: [ "group", "dataLabelsGroup" ],
        negStacks: true,
        init: function() {
            Series.prototype.init.apply(this, arguments);
            var series = this, chart = series.chart;
            if (chart.hasRendered) {
                each(chart.series, function(otherSeries) {
                    if (otherSeries.type === series.type) {
                        otherSeries.isDirty = true;
                    }
                });
            }
        },
        getColumnMetrics: function() {
            var series = this, options = series.options, xAxis = series.xAxis, yAxis = series.yAxis, reversedXAxis = xAxis.reversed, stackKey, stackGroups = {}, columnIndex, columnCount = 0;
            if (options.grouping === false) {
                columnCount = 1;
            } else {
                each(series.chart.series, function(otherSeries) {
                    var otherOptions = otherSeries.options, otherYAxis = otherSeries.yAxis;
                    if (otherSeries.type === series.type && otherSeries.visible && yAxis.len === otherYAxis.len && yAxis.pos === otherYAxis.pos) {
                        if (otherOptions.stacking) {
                            stackKey = otherSeries.stackKey;
                            if (stackGroups[stackKey] === UNDEFINED) {
                                stackGroups[stackKey] = columnCount++;
                            }
                            columnIndex = stackGroups[stackKey];
                        } else if (otherOptions.grouping !== false) {
                            columnIndex = columnCount++;
                        }
                        otherSeries.columnIndex = columnIndex;
                    }
                });
            }
            var categoryWidth = mathMin(mathAbs(xAxis.transA) * (xAxis.ordinalSlope || options.pointRange || xAxis.closestPointRange || 1), xAxis.len), groupPadding = categoryWidth * options.groupPadding, groupWidth = categoryWidth - 2 * groupPadding, pointOffsetWidth = groupWidth / columnCount, optionPointWidth = options.pointWidth, pointPadding = defined(optionPointWidth) ? (pointOffsetWidth - optionPointWidth) / 2 : pointOffsetWidth * options.pointPadding, pointWidth = pick(optionPointWidth, pointOffsetWidth - 2 * pointPadding), colIndex = (reversedXAxis ? columnCount - (series.columnIndex || 0) : series.columnIndex) || 0, pointXOffset = pointPadding + (groupPadding + colIndex * pointOffsetWidth - categoryWidth / 2) * (reversedXAxis ? -1 : 1);
            return series.columnMetrics = {
                width: pointWidth,
                offset: pointXOffset
            };
        },
        translate: function() {
            var series = this, chart = series.chart, options = series.options, borderWidth = options.borderWidth, yAxis = series.yAxis, threshold = options.threshold, translatedThreshold = series.translatedThreshold = yAxis.getThreshold(threshold), minPointLength = pick(options.minPointLength, 5), metrics = series.getColumnMetrics(), pointWidth = metrics.width, seriesBarW = series.barW = mathCeil(mathMax(pointWidth, 1 + 2 * borderWidth)), pointXOffset = series.pointXOffset = metrics.offset, xCrisp = -(borderWidth % 2 ? .5 : 0), yCrisp = borderWidth % 2 ? .5 : 1;
            if (chart.renderer.isVML && chart.inverted) {
                yCrisp += 1;
            }
            Series.prototype.translate.apply(series);
            each(series.points, function(point) {
                var plotY = mathMin(mathMax(-999, point.plotY), yAxis.len + 999), yBottom = pick(point.yBottom, translatedThreshold), barX = point.plotX + pointXOffset, barW = seriesBarW, barY = mathMin(plotY, yBottom), right, bottom, fromTop, fromLeft, barH = mathMax(plotY, yBottom) - barY;
                if (mathAbs(barH) < minPointLength) {
                    if (minPointLength) {
                        barH = minPointLength;
                        barY = mathRound(mathAbs(barY - translatedThreshold) > minPointLength ? yBottom - minPointLength : translatedThreshold - (yAxis.translate(point.y, 0, 1, 0, 1) <= translatedThreshold ? minPointLength : 0));
                    }
                }
                point.barX = barX;
                point.pointWidth = pointWidth;
                fromLeft = mathAbs(barX) < .5;
                right = mathRound(barX + barW) + xCrisp;
                barX = mathRound(barX) + xCrisp;
                barW = right - barX;
                fromTop = mathAbs(barY) < .5;
                bottom = mathRound(barY + barH) + yCrisp;
                barY = mathRound(barY) + yCrisp;
                barH = bottom - barY;
                if (fromLeft) {
                    barX += 1;
                    barW -= 1;
                }
                if (fromTop) {
                    barY -= 1;
                    barH += 1;
                }
                point.shapeType = "rect";
                point.shapeArgs = {
                    x: barX,
                    y: barY,
                    width: barW,
                    height: barH
                };
            });
        },
        getSymbol: noop,
        drawLegendSymbol: AreaSeries.prototype.drawLegendSymbol,
        drawGraph: noop,
        drawPoints: function() {
            var series = this, options = series.options, renderer = series.chart.renderer, shapeArgs;
            each(series.points, function(point) {
                var plotY = point.plotY, graphic = point.graphic;
                if (plotY !== UNDEFINED && !isNaN(plotY) && point.y !== null) {
                    shapeArgs = point.shapeArgs;
                    if (graphic) {
                        stop(graphic);
                        graphic.animate(merge(shapeArgs));
                    } else {
                        point.graphic = graphic = renderer[point.shapeType](shapeArgs).attr(point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE]).add(series.group).shadow(options.shadow, null, options.stacking && !options.borderRadius);
                    }
                } else if (graphic) {
                    point.graphic = graphic.destroy();
                }
            });
        },
        drawTracker: function() {
            var series = this, chart = series.chart, pointer = chart.pointer, cursor = series.options.cursor, css = cursor && {
                cursor: cursor
            }, onMouseOver = function(e) {
                var target = e.target, point;
                if (chart.hoverSeries !== series) {
                    series.onMouseOver();
                }
                while (target && !point) {
                    point = target.point;
                    target = target.parentNode;
                }
                if (point !== UNDEFINED && point !== chart.hoverPoint) {
                    point.onMouseOver(e);
                }
            };
            each(series.points, function(point) {
                if (point.graphic) {
                    point.graphic.element.point = point;
                }
                if (point.dataLabel) {
                    point.dataLabel.element.point = point;
                }
            });
            if (!series._hasTracking) {
                each(series.trackerGroups, function(key) {
                    if (series[key]) {
                        series[key].addClass(PREFIX + "tracker").on("mouseover", onMouseOver).on("mouseout", function(e) {
                            pointer.onTrackerMouseOut(e);
                        }).css(css);
                        if (hasTouch) {
                            series[key].on("touchstart", onMouseOver);
                        }
                    }
                });
                series._hasTracking = true;
            }
        },
        alignDataLabel: function(point, dataLabel, options, alignTo, isNew) {
            var chart = this.chart, inverted = chart.inverted, dlBox = point.dlBox || point.shapeArgs, below = point.below || point.plotY > pick(this.translatedThreshold, chart.plotSizeY), inside = pick(options.inside, !!this.options.stacking);
            if (dlBox) {
                alignTo = merge(dlBox);
                if (inverted) {
                    alignTo = {
                        x: chart.plotWidth - alignTo.y - alignTo.height,
                        y: chart.plotHeight - alignTo.x - alignTo.width,
                        width: alignTo.height,
                        height: alignTo.width
                    };
                }
                if (!inside) {
                    if (inverted) {
                        alignTo.x += below ? 0 : alignTo.width;
                        alignTo.width = 0;
                    } else {
                        alignTo.y += below ? alignTo.height : 0;
                        alignTo.height = 0;
                    }
                }
            }
            options.align = pick(options.align, !inverted || inside ? "center" : below ? "right" : "left");
            options.verticalAlign = pick(options.verticalAlign, inverted || inside ? "middle" : below ? "top" : "bottom");
            Series.prototype.alignDataLabel.call(this, point, dataLabel, options, alignTo, isNew);
        },
        animate: function(init) {
            var series = this, yAxis = this.yAxis, options = series.options, inverted = this.chart.inverted, attr = {}, translatedThreshold;
            if (hasSVG) {
                if (init) {
                    attr.scaleY = .001;
                    translatedThreshold = mathMin(yAxis.pos + yAxis.len, mathMax(yAxis.pos, yAxis.toPixels(options.threshold)));
                    if (inverted) {
                        attr.translateX = translatedThreshold - yAxis.len;
                    } else {
                        attr.translateY = translatedThreshold;
                    }
                    series.group.attr(attr);
                } else {
                    attr.scaleY = 1;
                    attr[inverted ? "translateX" : "translateY"] = yAxis.pos;
                    series.group.animate(attr, series.options.animation);
                    series.animate = null;
                }
            }
        },
        remove: function() {
            var series = this, chart = series.chart;
            if (chart.hasRendered) {
                each(chart.series, function(otherSeries) {
                    if (otherSeries.type === series.type) {
                        otherSeries.isDirty = true;
                    }
                });
            }
            Series.prototype.remove.apply(series, arguments);
        }
    });
    seriesTypes.column = ColumnSeries;
    defaultPlotOptions.bar = merge(defaultPlotOptions.column);
    var BarSeries = extendClass(ColumnSeries, {
        type: "bar",
        inverted: true
    });
    seriesTypes.bar = BarSeries;
    defaultPlotOptions.scatter = merge(defaultSeriesOptions, {
        lineWidth: 0,
        tooltip: {
            headerFormat: '<span style="font-size: 10px; color:{series.color}">{series.name}</span><br/>',
            pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>",
            followPointer: true
        },
        stickyTracking: false
    });
    var ScatterSeries = extendClass(Series, {
        type: "scatter",
        sorted: false,
        requireSorting: false,
        noSharedTooltip: true,
        trackerGroups: [ "markerGroup" ],
        drawTracker: ColumnSeries.prototype.drawTracker,
        setTooltipPoints: noop
    });
    seriesTypes.scatter = ScatterSeries;
    defaultPlotOptions.pie = merge(defaultSeriesOptions, {
        borderColor: "#FFFFFF",
        borderWidth: 1,
        center: [ null, null ],
        clip: false,
        colorByPoint: true,
        dataLabels: {
            distance: 30,
            enabled: true,
            formatter: function() {
                return this.point.name;
            }
        },
        ignoreHiddenPoint: true,
        legendType: "point",
        marker: null,
        size: null,
        showInLegend: false,
        slicedOffset: 10,
        states: {
            hover: {
                brightness: .1,
                shadow: false
            }
        },
        stickyTracking: false,
        tooltip: {
            followPointer: true
        }
    });
    var PiePoint = extendClass(Point, {
        init: function() {
            Point.prototype.init.apply(this, arguments);
            var point = this, toggleSlice;
            if (point.y < 0) {
                point.y = null;
            }
            extend(point, {
                visible: point.visible !== false,
                name: pick(point.name, "Slice")
            });
            toggleSlice = function(e) {
                point.slice(e.type === "select");
            };
            addEvent(point, "select", toggleSlice);
            addEvent(point, "unselect", toggleSlice);
            return point;
        },
        setVisible: function(vis) {
            var point = this, series = point.series, chart = series.chart, method;
            point.visible = point.options.visible = vis = vis === UNDEFINED ? !point.visible : vis;
            series.options.data[inArray(point, series.data)] = point.options;
            method = vis ? "show" : "hide";
            each([ "graphic", "dataLabel", "connector", "shadowGroup" ], function(key) {
                if (point[key]) {
                    point[key][method]();
                }
            });
            if (point.legendItem) {
                chart.legend.colorizeItem(point, vis);
            }
            if (!series.isDirty && series.options.ignoreHiddenPoint) {
                series.isDirty = true;
                chart.redraw();
            }
        },
        slice: function(sliced, redraw, animation) {
            var point = this, series = point.series, chart = series.chart, translation;
            setAnimation(animation, chart);
            redraw = pick(redraw, true);
            point.sliced = point.options.sliced = sliced = defined(sliced) ? sliced : !point.sliced;
            series.options.data[inArray(point, series.data)] = point.options;
            translation = sliced ? point.slicedTranslation : {
                translateX: 0,
                translateY: 0
            };
            point.graphic.animate(translation);
            if (point.shadowGroup) {
                point.shadowGroup.animate(translation);
            }
        }
    });
    var PieSeries = {
        type: "pie",
        isCartesian: false,
        pointClass: PiePoint,
        requireSorting: false,
        noSharedTooltip: true,
        trackerGroups: [ "group", "dataLabelsGroup" ],
        pointAttrToOptions: {
            stroke: "borderColor",
            "stroke-width": "borderWidth",
            fill: "color"
        },
        getColor: noop,
        animate: function(init) {
            var series = this, points = series.points, startAngleRad = series.startAngleRad;
            if (!init) {
                each(points, function(point) {
                    var graphic = point.graphic, args = point.shapeArgs;
                    if (graphic) {
                        graphic.attr({
                            r: series.center[3] / 2,
                            start: startAngleRad,
                            end: startAngleRad
                        });
                        graphic.animate({
                            r: args.r,
                            start: args.start,
                            end: args.end
                        }, series.options.animation);
                    }
                });
                series.animate = null;
            }
        },
        setData: function(data, redraw) {
            Series.prototype.setData.call(this, data, false);
            this.processData();
            this.generatePoints();
            if (pick(redraw, true)) {
                this.chart.redraw();
            }
        },
        generatePoints: function() {
            var i, total = 0, points, len, point, ignoreHiddenPoint = this.options.ignoreHiddenPoint;
            Series.prototype.generatePoints.call(this);
            points = this.points;
            len = points.length;
            for (i = 0; i < len; i++) {
                point = points[i];
                total += ignoreHiddenPoint && !point.visible ? 0 : point.y;
            }
            this.total = total;
            for (i = 0; i < len; i++) {
                point = points[i];
                point.percentage = total > 0 ? point.y / total * 100 : 0;
                point.total = total;
            }
        },
        getCenter: function() {
            var options = this.options, chart = this.chart, slicingRoom = 2 * (options.slicedOffset || 0), handleSlicingRoom, plotWidth = chart.plotWidth - 2 * slicingRoom, plotHeight = chart.plotHeight - 2 * slicingRoom, centerOption = options.center, positions = [ pick(centerOption[0], "50%"), pick(centerOption[1], "50%"), options.size || "100%", options.innerSize || 0 ], smallestSize = mathMin(plotWidth, plotHeight), isPercent;
            return map(positions, function(length, i) {
                isPercent = /%$/.test(length);
                handleSlicingRoom = i < 2 || i === 2 && isPercent;
                return (isPercent ? [ plotWidth, plotHeight, smallestSize, smallestSize ][i] * pInt(length) / 100 : length) + (handleSlicingRoom ? slicingRoom : 0);
            });
        },
        translate: function(positions) {
            this.generatePoints();
            var series = this, cumulative = 0, precision = 1e3, options = series.options, slicedOffset = options.slicedOffset, connectorOffset = slicedOffset + options.borderWidth, start, end, angle, startAngleRad = series.startAngleRad = mathPI / 180 * ((options.startAngle || 0) % 360 - 90), points = series.points, circ = 2 * mathPI, radiusX, radiusY, labelDistance = options.dataLabels.distance, ignoreHiddenPoint = options.ignoreHiddenPoint, i, len = points.length, point;
            if (!positions) {
                series.center = positions = series.getCenter();
            }
            series.getX = function(y, left) {
                angle = math.asin((y - positions[1]) / (positions[2] / 2 + labelDistance));
                return positions[0] + (left ? -1 : 1) * mathCos(angle) * (positions[2] / 2 + labelDistance);
            };
            for (i = 0; i < len; i++) {
                point = points[i];
                start = mathRound((startAngleRad + cumulative * circ) * precision) / precision;
                if (!ignoreHiddenPoint || point.visible) {
                    cumulative += point.percentage / 100;
                }
                end = mathRound((startAngleRad + cumulative * circ) * precision) / precision;
                point.shapeType = "arc";
                point.shapeArgs = {
                    x: positions[0],
                    y: positions[1],
                    r: positions[2] / 2,
                    innerR: positions[3] / 2,
                    start: start,
                    end: end
                };
                angle = (end + start) / 2;
                if (angle > .75 * circ) {
                    angle -= 2 * mathPI;
                }
                point.slicedTranslation = {
                    translateX: mathRound(mathCos(angle) * slicedOffset),
                    translateY: mathRound(mathSin(angle) * slicedOffset)
                };
                radiusX = mathCos(angle) * positions[2] / 2;
                radiusY = mathSin(angle) * positions[2] / 2;
                point.tooltipPos = [ positions[0] + radiusX * .7, positions[1] + radiusY * .7 ];
                point.half = angle < circ / 4 ? 0 : 1;
                point.angle = angle;
                connectorOffset = mathMin(connectorOffset, labelDistance / 2);
                point.labelPos = [ positions[0] + radiusX + mathCos(angle) * labelDistance, positions[1] + radiusY + mathSin(angle) * labelDistance, positions[0] + radiusX + mathCos(angle) * connectorOffset, positions[1] + radiusY + mathSin(angle) * connectorOffset, positions[0] + radiusX, positions[1] + radiusY, labelDistance < 0 ? "center" : point.half ? "right" : "left", angle ];
            }
            this.setTooltipPoints();
        },
        drawGraph: null,
        drawPoints: function() {
            var series = this, chart = series.chart, renderer = chart.renderer, groupTranslation, graphic, shadow = series.options.shadow, shadowGroup, shapeArgs;
            if (shadow && !series.shadowGroup) {
                series.shadowGroup = renderer.g("shadow").add(series.group);
            }
            each(series.points, function(point) {
                graphic = point.graphic;
                shapeArgs = point.shapeArgs;
                shadowGroup = point.shadowGroup;
                if (shadow && !shadowGroup) {
                    shadowGroup = point.shadowGroup = renderer.g("shadow").add(series.shadowGroup);
                }
                groupTranslation = point.sliced ? point.slicedTranslation : {
                    translateX: 0,
                    translateY: 0
                };
                if (shadowGroup) {
                    shadowGroup.attr(groupTranslation);
                }
                if (graphic) {
                    graphic.animate(extend(shapeArgs, groupTranslation));
                } else {
                    point.graphic = graphic = renderer.arc(shapeArgs).setRadialReference(series.center).attr(point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE]).attr({
                        "stroke-linejoin": "round"
                    }).attr(groupTranslation).add(series.group).shadow(shadow, shadowGroup);
                }
                if (point.visible === false) {
                    point.setVisible(false);
                }
            });
        },
        drawDataLabels: function() {
            var series = this, data = series.data, point, chart = series.chart, options = series.options.dataLabels, connectorPadding = pick(options.connectorPadding, 10), connectorWidth = pick(options.connectorWidth, 1), plotWidth = chart.plotWidth, plotHeight = chart.plotHeight, connector, connectorPath, softConnector = pick(options.softConnector, true), distanceOption = options.distance, seriesCenter = series.center, radius = seriesCenter[2] / 2, centerY = seriesCenter[1], outside = distanceOption > 0, dataLabel, dataLabelWidth, labelPos, labelHeight, halves = [ [], [] ], x, y, visibility, rankArr, i, j, overflow = [ 0, 0, 0, 0 ], sort = function(a, b) {
                return b.y - a.y;
            }, sortByAngle = function(points, sign) {
                points.sort(function(a, b) {
                    return a.angle !== undefined && (b.angle - a.angle) * sign;
                });
            };
            if (!series.visible || !options.enabled && !series._hasPointLabels) {
                return;
            }
            Series.prototype.drawDataLabels.apply(series);
            each(data, function(point) {
                if (point.dataLabel) {
                    halves[point.half].push(point);
                }
            });
            i = 0;
            while (!labelHeight && data[i]) {
                labelHeight = data[i] && data[i].dataLabel && (data[i].dataLabel.getBBox().height || 21);
                i++;
            }
            i = 2;
            while (i--) {
                var slots = [], slotsLength, usedSlots = [], points = halves[i], pos, length = points.length, slotIndex;
                sortByAngle(points, i - .5);
                if (distanceOption > 0) {
                    for (pos = centerY - radius - distanceOption; pos <= centerY + radius + distanceOption; pos += labelHeight) {
                        slots.push(pos);
                    }
                    slotsLength = slots.length;
                    if (length > slotsLength) {
                        rankArr = [].concat(points);
                        rankArr.sort(sort);
                        j = length;
                        while (j--) {
                            rankArr[j].rank = j;
                        }
                        j = length;
                        while (j--) {
                            if (points[j].rank >= slotsLength) {
                                points.splice(j, 1);
                            }
                        }
                        length = points.length;
                    }
                    for (j = 0; j < length; j++) {
                        point = points[j];
                        labelPos = point.labelPos;
                        var closest = 9999, distance, slotI;
                        for (slotI = 0; slotI < slotsLength; slotI++) {
                            distance = mathAbs(slots[slotI] - labelPos[1]);
                            if (distance < closest) {
                                closest = distance;
                                slotIndex = slotI;
                            }
                        }
                        if (slotIndex < j && slots[j] !== null) {
                            slotIndex = j;
                        } else if (slotsLength < length - j + slotIndex && slots[j] !== null) {
                            slotIndex = slotsLength - length + j;
                            while (slots[slotIndex] === null) {
                                slotIndex++;
                            }
                        } else {
                            while (slots[slotIndex] === null) {
                                slotIndex++;
                            }
                        }
                        usedSlots.push({
                            i: slotIndex,
                            y: slots[slotIndex]
                        });
                        slots[slotIndex] = null;
                    }
                    usedSlots.sort(sort);
                }
                for (j = 0; j < length; j++) {
                    var slot, naturalY;
                    point = points[j];
                    labelPos = point.labelPos;
                    dataLabel = point.dataLabel;
                    visibility = point.visible === false ? HIDDEN : VISIBLE;
                    naturalY = labelPos[1];
                    if (distanceOption > 0) {
                        slot = usedSlots.pop();
                        slotIndex = slot.i;
                        y = slot.y;
                        if (naturalY > y && slots[slotIndex + 1] !== null || naturalY < y && slots[slotIndex - 1] !== null) {
                            y = naturalY;
                        }
                    } else {
                        y = naturalY;
                    }
                    x = options.justify ? seriesCenter[0] + (i ? -1 : 1) * (radius + distanceOption) : series.getX(slotIndex === 0 || slotIndex === slots.length - 1 ? naturalY : y, i);
                    dataLabel._attr = {
                        visibility: visibility,
                        align: labelPos[6]
                    };
                    dataLabel._pos = {
                        x: x + options.x + ({
                            left: connectorPadding,
                            right: -connectorPadding
                        }[labelPos[6]] || 0),
                        y: y + options.y - 10
                    };
                    dataLabel.connX = x;
                    dataLabel.connY = y;
                    if (this.options.size === null) {
                        dataLabelWidth = dataLabel.width;
                        if (x - dataLabelWidth < connectorPadding) {
                            overflow[3] = mathMax(mathRound(dataLabelWidth - x + connectorPadding), overflow[3]);
                        } else if (x + dataLabelWidth > plotWidth - connectorPadding) {
                            overflow[1] = mathMax(mathRound(x + dataLabelWidth - plotWidth + connectorPadding), overflow[1]);
                        }
                        if (y - labelHeight / 2 < 0) {
                            overflow[0] = mathMax(mathRound(-y + labelHeight / 2), overflow[0]);
                        } else if (y + labelHeight / 2 > plotHeight) {
                            overflow[2] = mathMax(mathRound(y + labelHeight / 2 - plotHeight), overflow[2]);
                        }
                    }
                }
            }
            if (arrayMax(overflow) === 0 || this.verifyDataLabelOverflow(overflow)) {
                this.placeDataLabels();
                if (outside && connectorWidth) {
                    each(this.points, function(point) {
                        connector = point.connector;
                        labelPos = point.labelPos;
                        dataLabel = point.dataLabel;
                        if (dataLabel && dataLabel._pos) {
                            visibility = dataLabel._attr.visibility;
                            x = dataLabel.connX;
                            y = dataLabel.connY;
                            connectorPath = softConnector ? [ M, x + (labelPos[6] === "left" ? 5 : -5), y, "C", x, y, 2 * labelPos[2] - labelPos[4], 2 * labelPos[3] - labelPos[5], labelPos[2], labelPos[3], L, labelPos[4], labelPos[5] ] : [ M, x + (labelPos[6] === "left" ? 5 : -5), y, L, labelPos[2], labelPos[3], L, labelPos[4], labelPos[5] ];
                            if (connector) {
                                connector.animate({
                                    d: connectorPath
                                });
                                connector.attr("visibility", visibility);
                            } else {
                                point.connector = connector = series.chart.renderer.path(connectorPath).attr({
                                    "stroke-width": connectorWidth,
                                    stroke: options.connectorColor || point.color || "#606060",
                                    visibility: visibility
                                }).add(series.group);
                            }
                        } else if (connector) {
                            point.connector = connector.destroy();
                        }
                    });
                }
            }
        },
        verifyDataLabelOverflow: function(overflow) {
            var center = this.center, options = this.options, centerOption = options.center, minSize = options.minSize || 80, newSize = minSize, ret;
            if (centerOption[0] !== null) {
                newSize = mathMax(center[2] - mathMax(overflow[1], overflow[3]), minSize);
            } else {
                newSize = mathMax(center[2] - overflow[1] - overflow[3], minSize);
                center[0] += (overflow[3] - overflow[1]) / 2;
            }
            if (centerOption[1] !== null) {
                newSize = mathMax(mathMin(newSize, center[2] - mathMax(overflow[0], overflow[2])), minSize);
            } else {
                newSize = mathMax(mathMin(newSize, center[2] - overflow[0] - overflow[2]), minSize);
                center[1] += (overflow[0] - overflow[2]) / 2;
            }
            if (newSize < center[2]) {
                center[2] = newSize;
                this.translate(center);
                each(this.points, function(point) {
                    if (point.dataLabel) {
                        point.dataLabel._pos = null;
                    }
                });
                this.drawDataLabels();
            } else {
                ret = true;
            }
            return ret;
        },
        placeDataLabels: function() {
            each(this.points, function(point) {
                var dataLabel = point.dataLabel, _pos;
                if (dataLabel) {
                    _pos = dataLabel._pos;
                    if (_pos) {
                        dataLabel.attr(dataLabel._attr);
                        dataLabel[dataLabel.moved ? "animate" : "attr"](_pos);
                        dataLabel.moved = true;
                    } else if (dataLabel) {
                        dataLabel.attr({
                            y: -999
                        });
                    }
                }
            });
        },
        alignDataLabel: noop,
        drawTracker: ColumnSeries.prototype.drawTracker,
        drawLegendSymbol: AreaSeries.prototype.drawLegendSymbol,
        getSymbol: noop
    };
    PieSeries = extendClass(Series, PieSeries);
    seriesTypes.pie = PieSeries;
    extend(Highcharts, {
        Axis: Axis,
        Chart: Chart,
        Color: Color,
        Legend: Legend,
        Pointer: Pointer,
        Point: Point,
        Tick: Tick,
        Tooltip: Tooltip,
        Renderer: Renderer,
        Series: Series,
        SVGElement: SVGElement,
        SVGRenderer: SVGRenderer,
        arrayMin: arrayMin,
        arrayMax: arrayMax,
        charts: charts,
        dateFormat: dateFormat,
        format: format,
        pathAnim: pathAnim,
        getOptions: getOptions,
        hasBidiBug: hasBidiBug,
        isTouchDevice: isTouchDevice,
        numberFormat: numberFormat,
        seriesTypes: seriesTypes,
        setOptions: setOptions,
        addEvent: addEvent,
        removeEvent: removeEvent,
        createElement: createElement,
        discardElement: discardElement,
        css: css,
        each: each,
        extend: extend,
        map: map,
        merge: merge,
        pick: pick,
        splat: splat,
        extendClass: extendClass,
        pInt: pInt,
        wrap: wrap,
        svg: hasSVG,
        canvas: useCanVG,
        vml: !hasSVG && !useCanVG,
        product: PRODUCT,
        version: VERSION
    });
})();

function addCommas(nStr) {
    nStr += "";
    x = nStr.split(".");
    x1 = x[0];
    x2 = x.length > 1 ? "." + x[1] : "";
    var rgx = /(\d+)(\d{3})/;
    while (rgx.test(x1)) {
        x1 = x1.replace(rgx, "$1" + "," + "$2");
    }
    return x1 + x2;
}

var chart1_options = {
    chart: {
        renderTo: "hmda_chart_1",
        alignTicks: true,
        height: 400,
        plotBackgroundColor: "#FFFFFF",
        plotBorderWidth: null,
        plotShadow: false,
        spacingTop: 20,
        spacingRight: 10,
        spacingBottom: 1,
        spacingLeft: 1,
        marginTop: 100,
        marginBottom: 20,
        type: "column"
    },
    exporting: {
        enabled: false
    },
    title: {
        text: "U.S. Total",
        align: "left",
        verticalAlign: "top",
        floating: false,
        style: {
            color: "#000000",
            fontSize: "18pt",
            fontFamily: '"Avenir Next LT W01 Demi", "Avenir Next Demi", "Avenir Next", "Arial"',
            fontWeight: "600"
        }
    },
    subtitle: {
        text: "Home Mortgage Applications and Originations, 2010-2012",
        align: "left",
        verticalAlign: "top",
        floating: false,
        y: 40,
        style: {
            color: "#333333",
            fontSize: "12pt",
            fontFamily: '"Avenir Next LT W01 Regular", "Avenir Next", "Arial"',
            fontWeight: "400"
        }
    },
    credits: {
        text: "Data are for first-lien, owner-occupied, 1-4 family and manufactured homes.",
        enabled: false
    },
    colors: [ "#43af2a", "#acdc91", "#0071ce", "#7fb8e6", "#d14123", "#e89f91" ],
    legend: {
        align: "right",
        backgroundColor: "#FFFFFF",
        borderWidth: 0,
        borderRadius: 0,
        borderColor: "#FFFFFF",
        floating: false,
        itemStyle: {
            color: "#212121",
            fontSize: "12pt",
            lineHeight: "12pt",
            fontFamily: '"Avenir Next LT W01 Medium Cn", "Avenir Next Light", "Avenir Next", "Arial Condensed", "Arial"',
            fontWeight: "",
            paddingBottom: "8pt"
        },
        layout: "vertical",
        margin: 10,
        padding: 10,
        shadow: false,
        symbolPadding: 5,
        symbolWidth: 20,
        verticalAlign: "middle",
        x: 0,
        y: 0
    },
    tooltip: {
        backgroundColor: "rgba(0, 0, 0, 0.65)",
        borderColor: "#999999",
        borderRadius: 0,
        borderWidth: 0,
        shadow: false,
        style: {
            color: "#ffffff",
            fontSize: "10pt",
            fontFamily: "",
            fontWeight: "",
            padding: 8,
            lineHeight: "12pt"
        },
        formatter: function() {
            var tooltip_suffix = "";
            if (this.point.name != "None") {
                tooltip_suffix = this.point.name;
            }
            var format = '<span style="font-size: 12pt;>' + this.series.name + " in " + this.x + ':<br><span style="font-weight: 700;>' + addCommas(this.y) + "</span></span>";
            return format;
        }
    },
    plotOptions: {
        series: {
            allowPointSelect: true,
            animation: false,
            borderWidth: 0,
            cursor: "pointer",
            marker: {
                radius: 10
            },
            showInLegend: true,
            shadow: false
        },
        pie: {
            dataLabels: {
                enabled: false
            },
            point: {
                events: {
                    legendItemClick: function() {
                        return false;
                    }
                }
            },
            size: "90%"
        },
        column: {
            dataLabels: {
                enabled: false
            },
            grouping: true,
            groupPadding: .1,
            pointPadding: 0,
            stacking: null,
            events: {
                legendItemClick: function() {
                    return false;
                }
            }
        },
        bar: {
            dataLabels: {
                enabled: false
            },
            groupPadding: .1,
            pointPadding: 0,
            stacking: null
        },
        line: {
            lineWidth: 8,
            marker: {
                enabled: false
            }
        },
        area: {
            lineWidth: 8,
            stacking: null,
            marker: {
                enabled: false
            }
        },
        allowPointSelect: false
    },
    xAxis: {
        categories: [ "2010", "2011", "2012" ],
        gridLineWidth: 0,
        labels: {
            style: {
                color: "#212121",
                fontSize: "10pt",
                fontFamily: '"Avenir Next LT W01 Regular", "Avenir Next", "Arial"',
                fontWeight: "400"
            },
            enabled: true,
            y: 20
        },
        lineWidth: 0,
        title: {
            text: null,
            margin: 12,
            style: {
                color: "#101820",
                fontSize: "12pt",
                fontFamily: '"Avenir Next LT W01 Regular", "Avenir Next", "Arial"',
                fontWeight: "400"
            },
            x: -5
        },
        tickLength: 0,
        startOnTick: true,
        endOnTick: true,
        minPadding: 0,
        maxPadding: 0
    },
    yAxis: [ {
        title: {
            text: "Number of applications and originations",
            margin: 10,
            style: {
                color: "#101820",
                fontSize: "12pt",
                fontFamily: '"Avenir Next LT W01 Regular", "Avenir Next", "Arial"',
                fontWeight: "400"
            }
        },
        labels: {
            style: {
                color: "#212121",
                fontSize: "10pt",
                fontFamily: '"Avenir Next LT W01 Regular", "Avenir Next", "Arial"',
                fontWeight: "400"
            },
            format: "{value:,.0f}",
            enabled: true
        },
        gridLineWidth: 1
    }, {
        opposite: true,
        title: {
            text: null
        },
        labels: {
            style: {
                color: "#212121",
                fontSize: "10pt",
                fontFamily: '"Avenir Next LT W01 Regular", "Avenir Next", "Arial"',
                fontWeight: "400"
            },
            format: " {value:,.0f} ",
            enabled: true
        },
        gridLineWidth: 0
    } ],
    series: [ {
        yAxis: 0,
        name: "Home purchase applications",
        type: "column",
        data: [ {
            name: "",
            y: 1498717
        }, {
            name: "",
            y: 1399080
        }, {
            name: "",
            y: 1526319
        } ]
    }, {
        yAxis: 0,
        name: "Home purchase originations",
        type: "column",
        data: [ {
            name: "",
            y: 803307
        }, {
            name: "",
            y: 750463
        }, {
            name: "",
            y: 834181
        } ]
    }, {
        yAxis: 0,
        name: "Home improvement applications",
        type: "column",
        data: [ {
            name: "",
            y: 106065
        }, {
            name: "",
            y: 106314
        }, {
            name: "",
            y: 119091
        } ]
    }, {
        yAxis: 0,
        name: "Home improvement originations",
        type: "column",
        data: [ {
            name: "",
            y: 61688
        }, {
            name: "",
            y: 61818
        }, {
            name: "",
            y: 74849
        } ]
    }, {
        name: "Refinancing applications",
        data: [ {
            name: "",
            y: 3121622
        }, {
            name: "",
            y: 2747268
        }, {
            name: "",
            y: 3742878
        } ]
    }, {
        name: "Refinancing originations",
        data: [ 1827216, 1597456, 2358467 ]
    } ]
};

$(document).ready(function() {
    if ($("#hmda_chart_1").length !== 0) {
        var applicationsOriginationsChart = new Highcharts.Chart(chart1_options);
    }
    if ($("#hmda_chart_1_msa").length !== 0) {
        $("#hmda_chart_1_msa").chosen();
    }
    var chart1DataObj = {
        msa00: {
            name: "U.S. Total",
            data: [ [ 1498717, 1399080, 1526319 ], [ 803307, 750463, 834181 ], [ 106065, 106314, 119091 ], [ 61688, 61818, 74849 ], [ 3121622, 2747268, 3742878 ], [ 1827216, 1597456, 2358467 ] ]
        },
        msa01: {
            name: "Abilene, TX",
            data: [ [ 1843, 1728, 1863 ], [ 1364, 1244, 1439 ], [ 230, 246, 219 ], [ 139, 160, 169 ], [ 1875, 1897, 2307 ], [ 1147, 1174, 1528 ] ]
        },
        msa02: {
            name: "Aguadilla-Isabela, PR",
            data: [ [ 942, 1304, 1167 ], [ 489, 715, 704 ], [ 164, 137, 117 ], [ 88, 85, 70 ], [ 1246, 1208, 1756 ], [ 697, 690, 1047 ] ]
        },
        msa03: {
            name: "Akron, OH",
            data: [ [ 6131, 5569, 6613 ], [ 4673, 4238, 5131 ], [ 376, 344, 427 ], [ 147, 153, 194 ], [ 18108, 15039, 20696 ], [ 10651, 8527, 12544 ] ]
        },
        msa04: {
            name: "Albany-Schenectady-Troy, NY",
            data: [ [ 9159, 8367, 9318 ], [ 6564, 5932, 6799 ], [ 923, 860, 942 ], [ 600, 519, 644 ], [ 18801, 16417, 21463 ], [ 11297, 9384, 13707 ] ]
        },
        msa05: {
            name: "Albany, GA",
            data: [ [ 1154, 1160, 1119 ], [ 740, 638, 683 ], [ 107, 72, 94 ], [ 68, 45, 60 ], [ 2338, 2036, 2547 ], [ 1345, 1107, 1574 ] ]
        },
        msa06: {
            name: "Albuquerque, NM",
            data: [ [ 10377, 9227, 10253 ], [ 7099, 6219, 7036 ], [ 795, 692, 791 ], [ 389, 391, 458 ], [ 25451, 21885, 31732 ], [ 13886, 11845, 18551 ] ]
        },
        msa07: {
            name: "Alexandria, LA",
            data: [ [ 1879, 1865, 1901 ], [ 1074, 1026, 1099 ], [ 210, 209, 213 ], [ 107, 127, 124 ], [ 2745, 2693, 3056 ], [ 1530, 1404, 1697 ] ]
        },
        msa08: {
            name: "Allentown-Bethlehem-Easton, PA-NJ",
            data: [ [ 8121, 7096, 7781 ], [ 5884, 5164, 5646 ], [ 1058, 1001, 1023 ], [ 697, 689, 696 ], [ 25077, 20508, 26809 ], [ 14216, 11266, 15923 ] ]
        },
        msa09: {
            name: "Altoona, PA",
            data: [ [ 988, 934, 1042 ], [ 749, 710, 775 ], [ 252, 253, 354 ], [ 166, 178, 259 ], [ 2351, 2275, 2883 ], [ 1452, 1398, 1972 ] ]
        },
        msa10: {
            name: "Amarillo, TX",
            data: [ [ 3102, 2996, 3412 ], [ 2249, 2136, 2526 ], [ 122, 92, 124 ], [ 47, 48, 68 ], [ 3932, 3613, 4799 ], [ 2254, 1942, 2802 ] ]
        },
        msa11: {
            name: "Ames, IA",
            data: [ [ 948, 874, 985 ], [ 740, 690, 763 ], [ 144, 123, 122 ], [ 124, 105, 99 ], [ 2378, 2108, 2743 ], [ 1728, 1511, 2102 ] ]
        },
        msa12: {
            name: "Anchorage, AK",
            data: [ [ 5966, 5407, 5927 ], [ 4571, 4338, 4706 ], [ 304, 248, 318 ], [ 163, 152, 200 ], [ 12668, 10678, 15160 ], [ 8025, 6757, 9916 ] ]
        },
        msa13: {
            name: "Ann Arbor, MI",
            data: [ [ 3418, 3588, 3979 ], [ 2398, 2518, 2820 ], [ 106, 130, 165 ], [ 59, 68, 109 ], [ 9448, 8928, 13860 ], [ 6391, 5931, 9822 ] ]
        },
        msa14: {
            name: "Anniston-Oxford-Jacksonville, AL",
            data: [ [ 1044, 1071, 1174 ], [ 593, 567, 619 ], [ 112, 100, 135 ], [ 46, 56, 79 ], [ 2277, 2047, 2405 ], [ 1156, 977, 1297 ] ]
        },
        msa15: {
            name: "Appleton, WI",
            data: [ [ 2423, 2384, 2764 ], [ 1918, 1879, 2182 ], [ 507, 543, 571 ], [ 407, 439, 470 ], [ 11286, 8939, 12160 ], [ 8215, 6201, 8870 ] ]
        },
        msa16: {
            name: "Asheville, NC",
            data: [ [ 4315, 4598, 5669 ], [ 2731, 2663, 3211 ], [ 273, 244, 278 ], [ 139, 128, 149 ], [ 11657, 10514, 12862 ], [ 6887, 6025, 7724 ] ]
        },
        msa17: {
            name: "Athens-Clarke County, GA",
            data: [ [ 1355, 1231, 1422 ], [ 931, 854, 991 ], [ 99, 80, 93 ], [ 48, 43, 54 ], [ 3872, 3662, 4685 ], [ 2263, 2203, 3021 ] ]
        },
        msa18: {
            name: "Atlanta-Sandy Springs-Roswell, GA",
            data: [ [ 62753, 60346, 66352 ], [ 41330, 39159, 44010 ], [ 1941, 1914, 2106 ], [ 991, 923, 1034 ], [ 129313, 120016, 180315 ], [ 67637, 66421, 110133 ] ]
        },
        msa19: {
            name: "Atlantic City-Hammonton, NJ",
            data: [ [ 2479, 2063, 2185 ], [ 1620, 1311, 1359 ], [ 365, 317, 340 ], [ 202, 190, 176 ], [ 7864, 6265, 7850 ], [ 3992, 3077, 4072 ] ]
        },
        msa20: {
            name: "Auburn-Opelika, AL",
            data: [ [ 1752, 1874, 2102 ], [ 1303, 1244, 1359 ], [ 88, 81, 90 ], [ 54, 46, 59 ], [ 3026, 2737, 3952 ], [ 1672, 1450, 2421 ] ]
        },
        msa21: {
            name: "Augusta-Richmond County, GA-SC",
            data: [ [ 6308, 6267, 6397 ], [ 4603, 4266, 4391 ], [ 337, 354, 354 ], [ 164, 159, 180 ], [ 12131, 10758, 13734 ], [ 6481, 5803, 7791 ] ]
        },
        msa22: {
            name: "Austin-Round Rock, TX",
            data: [ [ 26560, 26049, 31974 ], [ 18588, 18063, 22768 ], [ 1116, 1004, 1099 ], [ 669, 588, 606 ], [ 43887, 39578, 53815 ], [ 26118, 23592, 34513 ] ]
        },
        msa23: {
            name: "Bakersfield, CA",
            data: [ [ 9918, 8611, 8734 ], [ 6825, 6109, 6208 ], [ 211, 208, 161 ], [ 86, 100, 83 ], [ 9325, 7870, 16954 ], [ 4729, 3952, 10527 ] ]
        },
        msa24: {
            name: "Baltimore-Columbia-Towson, MD",
            data: [ [ 28655, 26483, 29620 ], [ 21068, 19547, 21938 ], [ 2439, 2240, 2242 ], [ 1568, 1368, 1449 ], [ 92870, 76191, 102579 ], [ 55584, 44740, 65209 ] ]
        },
        msa25: {
            name: "Bangor, ME",
            data: [ [ 1359, 1167, 1343 ], [ 958, 850, 969 ], [ 203, 217, 228 ], [ 131, 145, 143 ], [ 3245, 2758, 3396 ], [ 1777, 1542, 2010 ] ]
        },
        msa26: {
            name: "Barnstable Town, MA",
            data: [ [ 1872, 1795, 2157 ], [ 1353, 1308, 1562 ], [ 420, 404, 611 ], [ 332, 286, 467 ], [ 8626, 7110, 9747 ], [ 5524, 4455, 6660 ] ]
        },
        msa27: {
            name: "Baton Rouge, LA",
            data: [ [ 10688, 10031, 12694 ], [ 6587, 5943, 7855 ], [ 833, 625, 782 ], [ 428, 338, 421 ], [ 19851, 17878, 23620 ], [ 11143, 9279, 12855 ] ]
        },
        msa28: {
            name: "Battle Creek, MI",
            data: [ [ 1118, 1008, 1246 ], [ 782, 724, 841 ], [ 120, 110, 110 ], [ 67, 60, 60 ], [ 2429, 2442, 3294 ], [ 1462, 1488, 2093 ] ]
        },
        msa29: {
            name: "Bay City, MI",
            data: [ [ 932, 913, 1060 ], [ 632, 634, 747 ], [ 90, 113, 118 ], [ 46, 69, 72 ], [ 2136, 2081, 3175 ], [ 1322, 1339, 2188 ] ]
        },
        msa30: {
            name: "Beaumont-Port Arthur, TX",
            data: [ [ 3449, 3517, 3846 ], [ 2043, 2014, 2309 ], [ 690, 607, 626 ], [ 388, 334, 360 ], [ 4073, 4073, 4389 ], [ 2237, 2180, 2518 ] ]
        },
        msa31: {
            name: "Bellingham, WA",
            data: [ [ 2311, 2029, 2379 ], [ 1647, 1469, 1758 ], [ 249, 291, 408 ], [ 158, 208, 291 ], [ 7721, 5973, 8488 ], [ 5035, 3752, 5621 ] ]
        },
        msa32: {
            name: "Bend-Redmond, OR",
            data: [ [ 2421, 2148, 2665 ], [ 1674, 1504, 1949 ], [ 78, 57, 218 ], [ 49, 26, 163 ], [ 4463, 3900, 6790 ], [ 2525, 2301, 4527 ] ]
        },
        msa33: {
            name: "Billings, MT",
            data: [ [ 2322, 2185, 2431 ], [ 1818, 1691, 1917 ], [ 234, 216, 272 ], [ 172, 167, 226 ], [ 5186, 3935, 5379 ], [ 3585, 2719, 3839 ] ]
        },
        msa34: {
            name: "Binghamton, NY",
            data: [ [ 1845, 1877, 1961 ], [ 1301, 1311, 1398 ], [ 274, 275, 387 ], [ 190, 192, 250 ], [ 3262, 2841, 3710 ], [ 1735, 1497, 2202 ] ]
        },
        msa35: {
            name: "Birmingham-Hoover, AL",
            data: [ [ 13127, 12744, 14904 ], [ 8008, 7771, 9112 ], [ 796, 916, 1043 ], [ 375, 429, 474 ], [ 31586, 24570, 33816 ], [ 15624, 11878, 18308 ] ]
        },
        msa36: {
            name: "Bismarck, ND",
            data: [ [ 1941, 2091, 2397 ], [ 1653, 1675, 2005 ], [ 125, 160, 206 ], [ 92, 124, 183 ], [ 3771, 2568, 3954 ], [ 2822, 1917, 3181 ] ]
        },
        msa37: {
            name: "Blacksburg-Christiansburg-Radford, VA",
            data: [ [ 1276, 1385, 1545 ], [ 918, 930, 1042 ], [ 263, 146, 134 ], [ 217, 95, 90 ], [ 3292, 2714, 3367 ], [ 2005, 1678, 2206 ] ]
        },
        msa38: {
            name: "Bloomington, IN",
            data: [ [ 1958, 1782, 1925 ], [ 1291, 1194, 1363 ], [ 162, 158, 273 ], [ 95, 104, 201 ], [ 4867, 4449, 5684 ], [ 2969, 2704, 3722 ] ]
        },
        msa39: {
            name: "Boise City, ID",
            data: [ [ 9529, 8675, 9657 ], [ 6937, 6552, 7489 ], [ 336, 297, 292 ], [ 170, 146, 180 ], [ 16595, 12284, 24937 ], [ 9415, 7162, 16674 ] ]
        },
        msa40: {
            name: "Boulder, CO",
            data: [ [ 3977, 3795, 4803 ], [ 2991, 2733, 3654 ], [ 189, 215, 185 ], [ 123, 125, 140 ], [ 14809, 11811, 17276 ], [ 10342, 8215, 12720 ] ]
        },
        msa41: {
            name: "Bowling Green, KY",
            data: [ [ 1231, 1204, 1375 ], [ 876, 851, 1049 ], [ 117, 126, 138 ], [ 73, 87, 99 ], [ 3024, 2960, 3233 ], [ 1812, 1823, 2077 ] ]
        },
        msa42: {
            name: "Bremerton-Silverdale, WA",
            data: [ [ 2983, 2579, 2884 ], [ 2198, 1949, 2125 ], [ 201, 210, 275 ], [ 123, 122, 188 ], [ 9683, 8337, 11860 ], [ 5894, 5016, 7657 ] ]
        },
        msa43: {
            name: "Bridgeport-Stamford-Norwalk, CT",
            data: [ [ 10030, 9012, 9821 ], [ 6954, 6251, 6798 ], [ 847, 956, 916 ], [ 518, 579, 605 ], [ 32630, 27690, 35347 ], [ 20211, 17185, 23173 ] ]
        },
        msa44: {
            name: "Brownsville-Harlingen, TX",
            data: [ [ 1999, 1961, 1915 ], [ 1222, 1194, 1229 ], [ 437, 476, 535 ], [ 90, 100, 111 ], [ 2724, 3070, 3503 ], [ 970, 1215, 1537 ] ]
        },
        msa45: {
            name: "Brunswick, GA",
            data: [ [ 889, 921, 1015 ], [ 582, 570, 655 ], [ 60, 67, 45 ], [ 30, 31, 28 ], [ 2220, 2022, 2472 ], [ 1198, 1065, 1416 ] ]
        },
        msa46: {
            name: "Buffalo-Cheektowaga-Niagara Falls, NY",
            data: [ [ 9704, 8898, 9937 ], [ 7971, 7331, 8131 ], [ 548, 519, 760 ], [ 305, 321, 476 ], [ 14515, 13653, 15862 ], [ 7695, 7666, 9514 ] ]
        },
        msa47: {
            name: "Burlington-South Burlington, VT",
            data: [ [ 2356, 2275, 2597 ], [ 1809, 1740, 2024 ], [ 639, 620, 658 ], [ 479, 465, 507 ], [ 8005, 6643, 9347 ], [ 5667, 4476, 6851 ] ]
        },
        msa48: {
            name: "Burlington, NC",
            data: [ [ 1397, 1512, 1788 ], [ 933, 881, 956 ], [ 80, 67, 78 ], [ 41, 42, 36 ], [ 3454, 3198, 3843 ], [ 1978, 1805, 2241 ] ]
        },
        msa49: {
            name: "Canton-Massillon, OH",
            data: [ [ 3240, 2956, 3491 ], [ 2463, 2250, 2668 ], [ 220, 207, 248 ], [ 87, 78, 117 ], [ 9421, 7860, 10615 ], [ 5248, 4431, 6431 ] ]
        },
        msa50: {
            name: "Cape Coral-Fort Myers, FL",
            data: [ [ 7341, 6126, 6483 ], [ 4569, 3953, 4223 ], [ 187, 198, 267 ], [ 56, 70, 125 ], [ 7644, 7315, 15003 ], [ 3481, 3878, 9187 ] ]
        },
        msa51: {
            name: "Cape Girardeau, MO-IL",
            data: [ [ 1018, 1009, 1059 ], [ 742, 709, 733 ], [ 95, 99, 104 ], [ 53, 66, 84 ], [ 2328, 1994, 2561 ], [ 1470, 1258, 1778 ] ]
        },
        msa52: {
            name: "Carson City, NV",
            data: [ [ 405, 463, 490 ], [ 309, 340, 365 ], [ 13, 16, 13 ], [ 9, 4, 8 ], [ 1017, 700, 1498 ], [ 605, 407, 1028 ] ]
        },
        msa53: {
            name: "Casper, WY",
            data: [ [ 1346, 1383, 1714 ], [ 1055, 1047, 1341 ], [ 117, 93, 125 ], [ 81, 69, 102 ], [ 1987, 1598, 2177 ], [ 1271, 1003, 1504 ] ]
        },
        msa54: {
            name: "Cedar Rapids, IA",
            data: [ [ 4328, 3787, 3306 ], [ 3451, 2971, 2645 ], [ 344, 275, 282 ], [ 263, 206, 226 ], [ 10569, 8408, 9993 ], [ 7508, 5787, 7121 ] ]
        },
        msa55: {
            name: "Champaign-Urbana, IL",
            data: [ [ 2175, 2064, 2419 ], [ 1703, 1561, 1927 ], [ 209, 183, 206 ], [ 164, 116, 155 ], [ 6833, 5415, 6943 ], [ 4926, 3868, 5038 ] ]
        },
        msa56: {
            name: "Charleston-North Charleston, SC",
            data: [ [ 10551, 10477, 12153 ], [ 6692, 6575, 7510 ], [ 356, 382, 446 ], [ 201, 235, 278 ], [ 17670, 15120, 21750 ], [ 9320, 8013, 12981 ] ]
        },
        msa57: {
            name: "Charleston, WV",
            data: [ [ 3444, 3919, 4070 ], [ 2025, 2023, 2096 ], [ 557, 585, 622 ], [ 331, 341, 376 ], [ 5527, 5194, 5750 ], [ 3075, 3001, 3481 ] ]
        },
        msa58: {
            name: "Charlotte-Concord-Gastonia, NC-SC",
            data: [ [ 22692, 21830, 25947 ], [ 15899, 14934, 17882 ], [ 914, 1e3, 1241 ], [ 505, 521, 719 ], [ 55207, 48321, 65152 ], [ 31406, 27006, 39405 ] ]
        },
        msa59: {
            name: "Charlottesville, VA",
            data: [ [ 2181, 2041, 2433 ], [ 1634, 1450, 1725 ], [ 161, 183, 199 ], [ 97, 95, 137 ], [ 6257, 5246, 6994 ], [ 3820, 3174, 4536 ] ]
        },
        msa60: {
            name: "Chattanooga, TN-GA",
            data: [ [ 5818, 5912, 6921 ], [ 3841, 3570, 4164 ], [ 298, 318, 342 ], [ 164, 162, 195 ], [ 11844, 10229, 13898 ], [ 6255, 5461, 7963 ] ]
        },
        msa61: {
            name: "Cheyenne, WY",
            data: [ [ 1506, 1674, 1760 ], [ 1187, 1224, 1408 ], [ 105, 131, 114 ], [ 78, 94, 81 ], [ 3160, 2512, 3737 ], [ 1930, 1583, 2556 ] ]
        },
        msa62: {
            name: "Chico, CA",
            data: [ [ 1838, 1774, 1858 ], [ 1248, 1271, 1362 ], [ 137, 96, 114 ], [ 80, 62, 72 ], [ 4953, 3973, 6228 ], [ 2756, 2168, 3929 ] ]
        },
        msa63: {
            name: "Cincinnati, OH-KY-IN",
            data: [ [ 23722, 21461, 24389 ], [ 17211, 15284, 17561 ], [ 1429, 1307, 2131 ], [ 713, 657, 1376 ], [ 85201, 69433, 94445 ], [ 53592, 42595, 62033 ] ]
        },
        msa64: {
            name: "Clarksville, TN-KY",
            data: [ [ 4041, 4632, 4776 ], [ 3069, 3554, 3593 ], [ 210, 190, 224 ], [ 103, 95, 123 ], [ 5957, 6242, 8269 ], [ 2960, 3301, 4730 ] ]
        },
        msa65: {
            name: "Cleveland-Elyria, OH",
            data: [ [ 17336, 15474, 18739 ], [ 13178, 11677, 14446 ], [ 1343, 1399, 1731 ], [ 521, 569, 723 ], [ 49016, 43719, 60923 ], [ 27914, 24032, 35700 ] ]
        },
        msa66: {
            name: "Cleveland, TN",
            data: [ [ 1131, 1265, 1442 ], [ 700, 726, 800 ], [ 90, 77, 106 ], [ 47, 39, 58 ], [ 2734, 2323, 2943 ], [ 1580, 1281, 1763 ] ]
        },
        msa67: {
            name: "Coeur d&apos;Alene, ID",
            data: [ [ 1989, 1906, 1745 ], [ 1443, 1385, 1266 ], [ 174, 109, 130 ], [ 91, 61, 76 ], [ 5021, 3678, 5423 ], [ 2816, 2109, 3255 ] ]
        },
        msa68: {
            name: "College Station-Bryan, TX",
            data: [ [ 2290, 2068, 2460 ], [ 1629, 1443, 1691 ], [ 108, 138, 128 ], [ 56, 76, 72 ], [ 2806, 2492, 2914 ], [ 1741, 1517, 1871 ] ]
        },
        msa69: {
            name: "Colorado Springs, CO",
            data: [ [ 10403, 9647, 10606 ], [ 7943, 7374, 8346 ], [ 410, 395, 570 ], [ 246, 213, 384 ], [ 23591, 21571, 31869 ], [ 15807, 13823, 22190 ] ]
        },
        msa70: {
            name: "Columbia, MO",
            data: [ [ 2145, 2009, 2419 ], [ 1646, 1527, 1915 ], [ 179, 130, 327 ], [ 133, 100, 258 ], [ 5134, 4043, 5590 ], [ 3549, 2759, 4146 ] ]
        },
        msa71: {
            name: "Columbia, SC",
            data: [ [ 9782, 8501, 9807 ], [ 6379, 5378, 6450 ], [ 409, 473, 516 ], [ 196, 250, 332 ], [ 18818, 16694, 22135 ], [ 10217, 9040, 13129 ] ]
        },
        msa72: {
            name: "Columbus, GA-AL",
            data: [ [ 2874, 2820, 2807 ], [ 2058, 2017, 2018 ], [ 148, 102, 154 ], [ 80, 49, 70 ], [ 5646, 5188, 7062 ], [ 2850, 2637, 4051 ] ]
        },
        msa73: {
            name: "Columbus, IN",
            data: [ [ 951, 1128, 1259 ], [ 703, 839, 946 ], [ 90, 63, 88 ], [ 68, 45, 62 ], [ 2710, 2228, 2907 ], [ 1739, 1391, 1962 ] ]
        },
        msa74: {
            name: "Columbus, OH",
            data: [ [ 22048, 19677, 23596 ], [ 15594, 13982, 17427 ], [ 895, 810, 1503 ], [ 452, 397, 987 ], [ 62374, 51898, 70938 ], [ 37715, 30489, 45012 ] ]
        },
        msa75: {
            name: "Corpus Christi, TX",
            data: [ [ 4184, 4117, 4778 ], [ 2840, 2613, 3358 ], [ 395, 353, 311 ], [ 182, 158, 157 ], [ 4968, 4993, 5438 ], [ 2626, 2704, 3194 ] ]
        },
        msa76: {
            name: "Corvallis, OR",
            data: [ [ 752, 711, 786 ], [ 571, 519, 584 ], [ 61, 76, 94 ], [ 34, 39, 68 ], [ 2451, 1965, 2742 ], [ 1622, 1255, 1857 ] ]
        },
        msa77: {
            name: "Crestview-Fort Walton Beach-Destin, FL",
            data: [ [ 2387, 3010, 2988 ], [ 1708, 2148, 2100 ], [ 57, 72, 63 ], [ 36, 39, 31 ], [ 3965, 3668, 6268 ], [ 2310, 2187, 3953 ] ]
        },
        msa78: {
            name: "Cumberland, MD-WV",
            data: [ [ 578, 540, 638 ], [ 407, 372, 485 ], [ 168, 122, 132 ], [ 133, 101, 101 ], [ 1731, 1437, 1799 ], [ 988, 855, 1166 ] ]
        },
        msa79: {
            name: "Dalton, GA",
            data: [ [ 1207, 1094, 1172 ], [ 737, 604, 629 ], [ 68, 67, 84 ], [ 34, 33, 38 ], [ 2006, 1784, 2383 ], [ 871, 878, 1280 ] ]
        },
        msa80: {
            name: "Danville, IL",
            data: [ [ 508, 515, 508 ], [ 328, 305, 323 ], [ 129, 128, 133 ], [ 86, 65, 74 ], [ 1220, 1153, 1327 ], [ 625, 567, 717 ] ]
        },
        msa81: {
            name: "Davenport-Moline-Rock Island, IA-IL",
            data: [ [ 4823, 4334, 4847 ], [ 3693, 3249, 3718 ], [ 587, 550, 640 ], [ 406, 386, 456 ], [ 12974, 9860, 13514 ], [ 8961, 6407, 9544 ] ]
        },
        msa82: {
            name: "Dayton, OH",
            data: [ [ 8051, 7087, 8311 ], [ 5988, 5221, 6127 ], [ 389, 485, 721 ], [ 184, 208, 483 ], [ 24035, 21381, 28777 ], [ 14687, 12728, 18006 ] ]
        },
        msa83: {
            name: "Decatur, AL",
            data: [ [ 1776, 1814, 2021 ], [ 1052, 965, 1086 ], [ 100, 223, 146 ], [ 44, 124, 65 ], [ 3971, 3397, 4243 ], [ 1892, 1639, 2205 ] ]
        },
        msa84: {
            name: "Decatur, IL",
            data: [ [ 979, 1017, 1124 ], [ 808, 821, 930 ], [ 160, 82, 177 ], [ 108, 46, 145 ], [ 2265, 1796, 2711 ], [ 1588, 1214, 1983 ] ]
        },
        msa85: {
            name: "Deltona-Daytona Beach-Ormond Beach, FL",
            data: [ [ 4449, 4178, 4664 ], [ 2860, 2623, 2931 ], [ 199, 167, 202 ], [ 75, 47, 63 ], [ 6653, 6003, 11958 ], [ 2838, 2824, 6893 ] ]
        },
        msa86: {
            name: "Denver-Aurora-Lakewood, CO",
            data: [ [ 40735, 38620, 47308 ], [ 29768, 27699, 35286 ], [ 1429, 1398, 1799 ], [ 858, 888, 1224 ], [ 105844, 85587, 128143 ], [ 70254, 53687, 87383 ] ]
        },
        msa87: {
            name: "Des Moines-West Des Moines, IA",
            data: [ [ 8076, 7623, 8831 ], [ 6192, 5843, 6917 ], [ 718, 637, 666 ], [ 459, 419, 476 ], [ 22140, 19377, 25783 ], [ 14474, 12583, 18111 ] ]
        },
        msa88: {
            name: "Dothan, AL",
            data: [ [ 1540, 1467, 1535 ], [ 982, 943, 947 ], [ 144, 118, 127 ], [ 71, 70, 80 ], [ 3107, 2774, 3522 ], [ 1647, 1515, 2120 ] ]
        },
        msa89: {
            name: "Dover, DE",
            data: [ [ 2002, 1774, 2084 ], [ 1369, 1194, 1435 ], [ 176, 141, 147 ], [ 96, 84, 80 ], [ 4331, 3734, 5262 ], [ 2186, 1945, 3163 ] ]
        },
        msa90: {
            name: "Dubuque, IA",
            data: [ [ 1348, 1233, 1302 ], [ 1122, 1031, 1099 ], [ 54, 69, 47 ], [ 32, 49, 36 ], [ 4400, 3387, 4722 ], [ 3534, 2676, 3867 ] ]
        },
        msa91: {
            name: "Duluth, MN-WI",
            data: [ [ 2417, 2382, 2675 ], [ 1803, 1848, 2039 ], [ 462, 406, 505 ], [ 297, 260, 340 ], [ 8524, 6781, 8645 ], [ 5134, 4021, 5543 ] ]
        },
        msa92: {
            name: "Durham-Chapel Hill, NC",
            data: [ [ 5914, 5434, 5959 ], [ 4187, 3729, 4235 ], [ 232, 233, 280 ], [ 128, 147, 154 ], [ 13925, 13038, 15621 ], [ 8867, 8022, 9817 ] ]
        },
        msa93: {
            name: "Eau Claire, WI",
            data: [ [ 1573, 1412, 1713 ], [ 1209, 1075, 1334 ], [ 296, 259, 368 ], [ 224, 186, 297 ], [ 6241, 4898, 6355 ], [ 4214, 3475, 4740 ] ]
        },
        msa94: {
            name: "El Centro, CA",
            data: [ [ 1735, 1561, 1437 ], [ 1214, 1143, 1020 ], [ 34, 20, 31 ], [ 10, 5, 8 ], [ 1124, 1069, 2392 ], [ 467, 543, 1401 ] ]
        },
        msa95: {
            name: "El Paso, TX",
            data: [ [ 8070, 7865, 8833 ], [ 5502, 5168, 5855 ], [ 810, 664, 685 ], [ 380, 310, 306 ], [ 9606, 9726, 11703 ], [ 4465, 4545, 5853 ] ]
        },
        msa96: {
            name: "Elizabethtown-Fort Knox, KY",
            data: [ [ 2157, 1604, 1573 ], [ 1474, 1011, 1028 ], [ 121, 108, 114 ], [ 69, 65, 74 ], [ 3172, 3016, 4185 ], [ 1789, 1670, 2574 ] ]
        },
        msa97: {
            name: "Elkhart-Goshen, IN",
            data: [ [ 1913, 1825, 2091 ], [ 1321, 1351, 1576 ], [ 92, 103, 137 ], [ 59, 68, 102 ], [ 4894, 4294, 5422 ], [ 2686, 2492, 3394 ] ]
        },
        msa98: {
            name: "Elmira, NY",
            data: [ [ 776, 824, 834 ], [ 584, 614, 621 ], [ 171, 185, 207 ], [ 128, 144, 157 ], [ 1327, 1134, 1314 ], [ 807, 702, 906 ] ]
        },
        msa99: {
            name: "Erie, PA",
            data: [ [ 2601, 2313, 2514 ], [ 2029, 1773, 1986 ], [ 489, 517, 568 ], [ 347, 307, 379 ], [ 5160, 4732, 6027 ], [ 2866, 2699, 3728 ] ]
        },
        msa100: {
            name: "Eugene, OR",
            data: [ [ 3542, 2963, 3295 ], [ 2420, 2078, 2350 ], [ 251, 173, 304 ], [ 150, 105, 200 ], [ 10788, 8614, 11853 ], [ 6492, 4989, 7622 ] ]
        },
        msa101: {
            name: "Evansville, IN-KY",
            data: [ [ 4297, 4047, 4126 ], [ 3122, 2815, 2902 ], [ 343, 436, 531 ], [ 196, 274, 361 ], [ 10790, 9244, 11065 ], [ 6628, 5496, 7206 ] ]
        },
        msa102: {
            name: "Fairbanks, AK",
            data: [ [ 1289, 1132, 1268 ], [ 1065, 899, 996 ], [ 95, 86, 127 ], [ 48, 52, 77 ], [ 1919, 1917, 2793 ], [ 1225, 1303, 1934 ] ]
        },
        msa103: {
            name: "Fargo, ND-MN",
            data: [ [ 2983, 2636, 3482 ], [ 2494, 2237, 2981 ], [ 187, 190, 215 ], [ 144, 153, 166 ], [ 6148, 5268, 6840 ], [ 4197, 3639, 5040 ] ]
        },
        msa104: {
            name: "Farmington, NM",
            data: [ [ 999, 1323, 1478 ], [ 637, 581, 722 ], [ 60, 72, 77 ], [ 41, 39, 45 ], [ 1750, 1458, 1970 ], [ 983, 795, 1175 ] ]
        },
        msa105: {
            name: "Fayetteville-Springdale-Rogers, AR-MO",
            data: [ [ 6421, 6411, 7344 ], [ 4518, 4420, 5217 ], [ 232, 182, 255 ], [ 94, 107, 169 ], [ 11765, 9421, 14771 ], [ 7080, 5622, 9783 ] ]
        },
        msa106: {
            name: "Fayetteville, NC",
            data: [ [ 5195, 4648, 4301 ], [ 3990, 3348, 2915 ], [ 235, 277, 323 ], [ 118, 142, 162 ], [ 8788, 9297, 11010 ], [ 4629, 4970, 6476 ] ]
        },
        msa107: {
            name: "Flagstaff, AZ",
            data: [ [ 1012, 1148, 1285 ], [ 688, 723, 828 ], [ 53, 50, 37 ], [ 20, 24, 17 ], [ 2888, 2212, 3244 ], [ 1684, 1284, 2056 ] ]
        },
        msa108: {
            name: "Flint, MI",
            data: [ [ 3576, 3258, 3878 ], [ 2255, 2086, 2548 ], [ 185, 190, 206 ], [ 68, 60, 69 ], [ 5817, 5697, 10659 ], [ 3244, 3213, 6806 ] ]
        },
        msa109: {
            name: "Florence-Muscle Shoals, AL",
            data: [ [ 1485, 1392, 1580 ], [ 963, 953, 1128 ], [ 111, 129, 122 ], [ 71, 84, 86 ], [ 3364, 3067, 3603 ], [ 1860, 1752, 2301 ] ]
        },
        msa110: {
            name: "Florence, SC",
            data: [ [ 1824, 2005, 2254 ], [ 1086, 971, 1146 ], [ 110, 117, 131 ], [ 54, 62, 82 ], [ 3468, 2999, 3422 ], [ 1700, 1548, 1936 ] ]
        },
        msa111: {
            name: "Fond du Lac, WI",
            data: [ [ 869, 724, 898 ], [ 672, 550, 686 ], [ 166, 157, 225 ], [ 137, 129, 188 ], [ 4681, 3721, 5181 ], [ 3473, 2562, 3795 ] ]
        },
        msa112: {
            name: "Fort Collins, CO",
            data: [ [ 4784, 4463, 5723 ], [ 3502, 3273, 4295 ], [ 208, 198, 281 ], [ 135, 136, 207 ], [ 12260, 10020, 14585 ], [ 8431, 6731, 10439 ] ]
        },
        msa113: {
            name: "Fort Smith, AR-OK",
            data: [ [ 3254, 3387, 3389 ], [ 2118, 1920, 1941 ], [ 370, 256, 320 ], [ 184, 169, 185 ], [ 5172, 4502, 5465 ], [ 3001, 2532, 3268 ] ]
        },
        msa114: {
            name: "Fort Wayne, IN",
            data: [ [ 4933, 4859, 5389 ], [ 3865, 3724, 4195 ], [ 357, 295, 354 ], [ 198, 169, 230 ], [ 12889, 10942, 14863 ], [ 8443, 6820, 10170 ] ]
        },
        msa115: {
            name: "Fresno, CA",
            data: [ [ 8922, 8608, 7886 ], [ 6248, 6134, 5689 ], [ 311, 297, 253 ], [ 149, 171, 153 ], [ 12786, 10774, 20353 ], [ 6994, 5793, 12608 ] ]
        },
        msa116: {
            name: "Gadsden, AL",
            data: [ [ 812, 950, 1016 ], [ 454, 550, 572 ], [ 74, 76, 92 ], [ 40, 44, 48 ], [ 2071, 1588, 2067 ], [ 1045, 799, 1158 ] ]
        },
        msa117: {
            name: "Gainesville, FL",
            data: [ [ 2191, 2188, 2537 ], [ 1468, 1352, 1511 ], [ 146, 100, 101 ], [ 61, 46, 47 ], [ 4361, 3487, 4926 ], [ 2303, 1942, 3050 ] ]
        },
        msa118: {
            name: "Gainesville, GA",
            data: [ [ 1535, 1595, 1513 ], [ 998, 1088, 1038 ], [ 53, 45, 61 ], [ 22, 22, 27 ], [ 3698, 3587, 4928 ], [ 1854, 1992, 2957 ] ]
        },
        msa119: {
            name: "Glens Falls, NY",
            data: [ [ 1183, 1019, 1189 ], [ 761, 661, 771 ], [ 234, 203, 248 ], [ 139, 133, 164 ], [ 2117, 2030, 2405 ], [ 1001, 981, 1294 ] ]
        },
        msa120: {
            name: "Goldsboro, NC",
            data: [ [ 1090, 997, 1140 ], [ 737, 614, 686 ], [ 83, 91, 87 ], [ 43, 57, 52 ], [ 1959, 2027, 2538 ], [ 1158, 1263, 1619 ] ]
        },
        msa121: {
            name: "Grand Forks, ND-MN",
            data: [ [ 1104, 1071, 1216 ], [ 858, 850, 938 ], [ 122, 108, 141 ], [ 95, 78, 110 ], [ 2065, 1771, 2535 ], [ 1387, 1189, 1861 ] ]
        },
        msa122: {
            name: "Grand Junction, CO",
            data: [ [ 2012, 1896, 2376 ], [ 1473, 1385, 1861 ], [ 158, 144, 148 ], [ 85, 90, 99 ], [ 5576, 3677, 5823 ], [ 3598, 2210, 4055 ] ]
        },
        msa123: {
            name: "Grand Rapids-Wyoming, MI",
            data: [ [ 7999, 8057, 10175 ], [ 5637, 5688, 7242 ], [ 475, 532, 625 ], [ 266, 300, 366 ], [ 21889, 18733, 26328 ], [ 14291, 11860, 17688 ] ]
        },
        msa124: {
            name: "Great Falls, MT",
            data: [ [ 1107, 1002, 1147 ], [ 874, 776, 900 ], [ 183, 156, 195 ], [ 124, 101, 133 ], [ 2514, 2238, 3190 ], [ 1661, 1380, 2189 ] ]
        },
        msa125: {
            name: "Greeley, CO",
            data: [ [ 4567, 4431, 5409 ], [ 3204, 2978, 3731 ], [ 119, 129, 141 ], [ 73, 66, 84 ], [ 7700, 6414, 10075 ], [ 4822, 3915, 6690 ] ]
        },
        msa126: {
            name: "Green Bay, WI",
            data: [ [ 3172, 2810, 3260 ], [ 2468, 2204, 2582 ], [ 392, 390, 501 ], [ 299, 301, 427 ], [ 16957, 11676, 15763 ], [ 12235, 8083, 11711 ] ]
        },
        msa127: {
            name: "Greensboro-High Point, NC",
            data: [ [ 7076, 6787, 7652 ], [ 4766, 4337, 4714 ], [ 327, 312, 393 ], [ 175, 181, 232 ], [ 17519, 16357, 19072 ], [ 9930, 9092, 11389 ] ]
        },
        msa128: {
            name: "Greenville-Anderson-Mauldin, SC",
            data: [ [ 7390, 7829, 9383 ], [ 4823, 4779, 5814 ], [ 350, 359, 463 ], [ 217, 209, 275 ], [ 15238, 13831, 17652 ], [ 8643, 7925, 11047 ] ]
        },
        msa129: {
            name: "Greenville, NC",
            data: [ [ 2059, 1923, 2065 ], [ 1383, 1113, 1108 ], [ 87, 116, 94 ], [ 60, 58, 55 ], [ 3305, 3047, 3717 ], [ 1956, 1826, 2305 ] ]
        },
        msa130: {
            name: "Guayama, PR",
            data: [ [ 443, 519, 435 ], [ 242, 269, 268 ], [ 60, 43, 54 ], [ 27, 18, 32 ], [ 392, 300, 438 ], [ 179, 165, 264 ] ]
        },
        msa131: {
            name: "Gulfport-Biloxi-Pascagoula, MS",
            data: [ [ 2356, 2192, 2148 ], [ 1411, 1344, 1328 ], [ 282, 195, 148 ], [ 139, 91, 64 ], [ 4725, 3916, 4794 ], [ 2077, 1718, 2416 ] ]
        },
        msa132: {
            name: "Hagerstown-Martinsburg, MD-WV",
            data: [ [ 3152, 2939, 3029 ], [ 2180, 2051, 2118 ], [ 305, 227, 262 ], [ 178, 135, 145 ], [ 6693, 5571, 7984 ], [ 3530, 2931, 4820 ] ]
        },
        msa133: {
            name: "Hanford-Corcoran, CA",
            data: [ [ 1181, 1029, 1167 ], [ 864, 765, 883 ], [ 59, 42, 42 ], [ 34, 16, 21 ], [ 1626, 1448, 2594 ], [ 815, 722, 1542 ] ]
        },
        msa134: {
            name: "Harrisburg-Carlisle, PA",
            data: [ [ 6319, 5585, 6014 ], [ 4733, 4119, 4558 ], [ 783, 764, 1094 ], [ 537, 522, 765 ], [ 16586, 14227, 17664 ], [ 10157, 8537, 11140 ] ]
        },
        msa135: {
            name: "Harrisonburg, VA",
            data: [ [ 1e3, 937, 1085 ], [ 753, 701, 768 ], [ 100, 88, 107 ], [ 69, 61, 80 ], [ 2761, 2293, 2955 ], [ 1783, 1403, 1976 ] ]
        },
        msa136: {
            name: "Hartford-West Hartford-East Hartford, CT",
            data: [ [ 12076, 10431, 11887 ], [ 8908, 7514, 8855 ], [ 1507, 1521, 1785 ], [ 1035, 1073, 1319 ], [ 38040, 30833, 42035 ], [ 23165, 18454, 26944 ] ]
        },
        msa137: {
            name: "Hattiesburg, MS",
            data: [ [ 1848, 1709, 1852 ], [ 1081, 928, 1030 ], [ 106, 63, 79 ], [ 51, 42, 43 ], [ 2825, 2195, 2728 ], [ 1514, 1222, 1676 ] ]
        },
        msa138: {
            name: "Hickory-Lenoir-Morganton, NC",
            data: [ [ 2849, 2928, 3464 ], [ 1878, 1779, 1924 ], [ 208, 249, 324 ], [ 122, 140, 175 ], [ 7333, 6967, 8055 ], [ 4295, 4028, 4857 ] ]
        },
        msa139: {
            name: "Hinesville, GA",
            data: [ [ 665, 927, 840 ], [ 501, 699, 631 ], [ 34, 22, 40 ], [ 16, 11, 17 ], [ 1303, 1350, 1589 ], [ 601, 670, 848 ] ]
        },
        msa140: {
            name: "Hot Springs, AR",
            data: [ [ 1277, 1234, 1485 ], [ 735, 658, 717 ], [ 121, 75, 95 ], [ 46, 33, 51 ], [ 2513, 2074, 2891 ], [ 1302, 1052, 1572 ] ]
        },
        msa141: {
            name: "Houma-Thibodaux, LA",
            data: [ [ 2345, 2494, 3095 ], [ 1329, 1207, 1574 ], [ 332, 324, 318 ], [ 205, 199, 192 ], [ 4746, 4192, 4626 ], [ 2776, 2423, 2871 ] ]
        },
        msa142: {
            name: "Houston-The Woodlands-Sugar Land, TX",
            data: [ [ 70951, 67827, 81288 ], [ 48948, 45710, 56818 ], [ 3187, 3103, 3254 ], [ 1353, 1461, 1398 ], [ 91536, 93713, 115023 ], [ 50369, 52841, 68906 ] ]
        },
        msa143: {
            name: "Huntington-Ashland, WV-KY-OH",
            data: [ [ 2776, 2867, 2861 ], [ 1716, 1642, 1617 ], [ 561, 573, 667 ], [ 324, 336, 384 ], [ 5701, 5294, 5679 ], [ 3178, 2960, 3344 ] ]
        },
        msa144: {
            name: "Huntsville, AL",
            data: [ [ 7072, 6702, 7013 ], [ 5147, 4745, 5094 ], [ 279, 657, 373 ], [ 145, 404, 174 ], [ 15751, 13194, 17996 ], [ 8534, 6819, 10279 ] ]
        },
        msa145: {
            name: "Idaho Falls, ID",
            data: [ [ 1521, 1362, 1503 ], [ 1201, 1057, 1143 ], [ 102, 90, 134 ], [ 68, 46, 101 ], [ 3985, 2948, 4046 ], [ 2352, 1667, 2560 ] ]
        },
        msa146: {
            name: "Indianapolis-Carmel-Anderson, IN",
            data: [ [ 23777, 23320, 25691 ], [ 17050, 16558, 19246 ], [ 1043, 1165, 1781 ], [ 573, 615, 1157 ], [ 67131, 54926, 72203 ], [ 40409, 32973, 47009 ] ]
        },
        msa147: {
            name: "Iowa City, IA",
            data: [ [ 2301, 2153, 2268 ], [ 1839, 1763, 1857 ], [ 237, 169, 207 ], [ 203, 142, 166 ], [ 4860, 3825, 5081 ], [ 3461, 2646, 3850 ] ]
        },
        msa148: {
            name: "Ithaca, NY",
            data: [ [ 786, 697, 764 ], [ 624, 557, 648 ], [ 146, 124, 171 ], [ 118, 107, 142 ], [ 1140, 971, 1191 ], [ 804, 680, 905 ] ]
        },
        msa149: {
            name: "Jackson, MI",
            data: [ [ 1218, 1119, 1389 ], [ 843, 784, 978 ], [ 170, 165, 159 ], [ 85, 93, 84 ], [ 2886, 2656, 4531 ], [ 1663, 1456, 2860 ] ]
        },
        msa150: {
            name: "Jackson, MS",
            data: [ [ 4912, 4631, 5286 ], [ 3318, 3040, 3328 ], [ 320, 218, 240 ], [ 146, 129, 123 ], [ 11109, 8761, 11406 ], [ 6413, 4908, 7149 ] ]
        },
        msa151: {
            name: "Jackson, TN",
            data: [ [ 1154, 1157, 1252 ], [ 785, 763, 792 ], [ 63, 43, 55 ], [ 28, 28, 35 ], [ 2332, 1904, 2553 ], [ 1256, 971, 1440 ] ]
        },
        msa152: {
            name: "Jacksonville, FL",
            data: [ [ 18322, 16705, 18747 ], [ 11693, 10626, 12022 ], [ 918, 596, 677 ], [ 503, 313, 395 ], [ 26937, 22509, 37570 ], [ 13310, 12015, 22639 ] ]
        },
        msa153: {
            name: "Jacksonville, NC",
            data: [ [ 3872, 2997, 2786 ], [ 3061, 2347, 2129 ], [ 128, 112, 129 ], [ 79, 65, 76 ], [ 4159, 4359, 5956 ], [ 2233, 2412, 3593 ] ]
        },
        msa154: {
            name: "Janesville-Beloit, WI",
            data: [ [ 1381, 1261, 1568 ], [ 1031, 943, 1193 ], [ 153, 151, 174 ], [ 95, 94, 121 ], [ 5518, 4614, 6009 ], [ 3640, 2910, 4076 ] ]
        },
        msa155: {
            name: "Jefferson City, MO",
            data: [ [ 1681, 1534, 1728 ], [ 1196, 1076, 1231 ], [ 303, 270, 347 ], [ 247, 209, 271 ], [ 4046, 3482, 4792 ], [ 2897, 2333, 3404 ] ]
        },
        msa156: {
            name: "Johnson City, TN",
            data: [ [ 2120, 2305, 2739 ], [ 1350, 1324, 1506 ], [ 200, 193, 225 ], [ 129, 123, 157 ], [ 4076, 3615, 4461 ], [ 2349, 2025, 2687 ] ]
        },
        msa157: {
            name: "Johnstown, PA",
            data: [ [ 1152, 1051, 973 ], [ 885, 802, 738 ], [ 414, 382, 398 ], [ 282, 253, 271 ], [ 2353, 2210, 2940 ], [ 1391, 1309, 1831 ] ]
        },
        msa158: {
            name: "Jonesboro, AR",
            data: [ [ 1523, 1508, 1639 ], [ 1025, 1007, 1106 ], [ 122, 104, 104 ], [ 66, 59, 68 ], [ 2232, 2066, 2656 ], [ 1338, 1259, 1698 ] ]
        },
        msa159: {
            name: "Joplin, MO",
            data: [ [ 2034, 2378, 2278 ], [ 1361, 1584, 1502 ], [ 152, 116, 167 ], [ 61, 65, 91 ], [ 3842, 3091, 4039 ], [ 2180, 1719, 2551 ] ]
        },
        msa160: {
            name: "Kalamazoo-Portage, MI",
            data: [ [ 2970, 3002, 3629 ], [ 2205, 2210, 2745 ], [ 209, 234, 205 ], [ 113, 123, 99 ], [ 7678, 6894, 10298 ], [ 4851, 4276, 7057 ] ]
        },
        msa161: {
            name: "Kankakee, IL",
            data: [ [ 827, 815, 821 ], [ 551, 560, 558 ], [ 124, 164, 175 ], [ 87, 103, 119 ], [ 2936, 2274, 3171 ], [ 1805, 1209, 2012 ] ]
        },
        msa162: {
            name: "Kansas City, MO-KS",
            data: [ [ 24023, 21813, 25431 ], [ 17793, 16498, 19668 ], [ 1501, 1332, 1896 ], [ 878, 844, 1265 ], [ 67338, 55302, 74435 ], [ 42950, 33398, 49106 ] ]
        },
        msa163: {
            name: "Kennewick-Richland, WA",
            data: [ [ 4703, 3912, 3679 ], [ 3566, 2989, 2915 ], [ 334, 265, 290 ], [ 212, 163, 194 ], [ 8053, 7326, 9357 ], [ 4929, 4535, 6227 ] ]
        },
        msa164: {
            name: "Killeen-Temple, TX",
            data: [ [ 6184, 5546, 5809 ], [ 4634, 3944, 4126 ], [ 209, 271, 302 ], [ 116, 165, 151 ], [ 5875, 5946, 8337 ], [ 3417, 3301, 4794 ] ]
        },
        msa165: {
            name: "Kingsport-Bristol-Bristol, TN-VA",
            data: [ [ 3074, 3221, 3746 ], [ 1934, 1770, 2027 ], [ 345, 383, 390 ], [ 201, 250, 248 ], [ 5961, 5226, 6538 ], [ 3259, 2802, 3696 ] ]
        },
        msa166: {
            name: "Kingston, NY",
            data: [ [ 1311, 1116, 1115 ], [ 915, 730, 799 ], [ 144, 155, 136 ], [ 88, 93, 90 ], [ 2903, 2644, 3159 ], [ 1413, 1276, 1673 ] ]
        },
        msa167: {
            name: "Knoxville, TN",
            data: [ [ 8908, 9439, 9940 ], [ 6005, 5446, 6239 ], [ 633, 572, 703 ], [ 377, 381, 472 ], [ 19944, 16141, 22457 ], [ 11954, 9195, 13544 ] ]
        },
        msa168: {
            name: "Kokomo, IN",
            data: [ [ 941, 831, 1067 ], [ 699, 603, 772 ], [ 58, 72, 88 ], [ 33, 50, 64 ], [ 2234, 1985, 3251 ], [ 1175, 1069, 1970 ] ]
        },
        msa169: {
            name: "La Crosse-Onalaska, WI-MN",
            data: [ [ 1355, 1236, 1517 ], [ 1017, 929, 1195 ], [ 197, 169, 241 ], [ 147, 128, 216 ], [ 5481, 4809, 6032 ], [ 4054, 3471, 4684 ] ]
        },
        msa170: {
            name: "Lafayette, LA",
            data: [ [ 3965, 3721, 4604 ], [ 2336, 2158, 2753 ], [ 259, 221, 275 ], [ 145, 125, 170 ], [ 6175, 5352, 6376 ], [ 3545, 2881, 3786 ] ]
        },
        msa171: {
            name: "Lake Charles, LA",
            data: [ [ 2170, 2180, 2651 ], [ 1303, 1243, 1587 ], [ 203, 207, 230 ], [ 102, 94, 125 ], [ 3651, 3362, 3705 ], [ 2078, 1891, 2244 ] ]
        },
        msa172: {
            name: "Lake Havasu City-Kingman, AZ",
            data: [ [ 1948, 1595, 1894 ], [ 1297, 1066, 1278 ], [ 124, 88, 120 ], [ 38, 36, 50 ], [ 3221, 2897, 4858 ], [ 1563, 1484, 2953 ] ]
        },
        msa173: {
            name: "Lakeland-Winter Haven, FL",
            data: [ [ 5788, 4889, 5424 ], [ 3623, 3050, 3264 ], [ 342, 269, 270 ], [ 169, 128, 129 ], [ 6519, 5487, 10289 ], [ 2942, 2688, 6070 ] ]
        },
        msa174: {
            name: "Lancaster, PA",
            data: [ [ 5318, 4706, 5309 ], [ 4036, 3547, 4097 ], [ 644, 625, 621 ], [ 491, 449, 450 ], [ 13363, 10844, 14222 ], [ 8165, 6307, 9166 ] ]
        },
        msa175: {
            name: "Lansing-East Lansing, MI",
            data: [ [ 4164, 3890, 4605 ], [ 2923, 2759, 3337 ], [ 321, 294, 353 ], [ 184, 179, 216 ], [ 10861, 8971, 13753 ], [ 6523, 5333, 8939 ] ]
        },
        msa176: {
            name: "Laredo, TX",
            data: [ [ 1636, 1515, 1792 ], [ 1092, 1003, 1217 ], [ 108, 106, 92 ], [ 20, 26, 31 ], [ 1735, 1625, 1990 ], [ 617, 649, 869 ] ]
        },
        msa177: {
            name: "Las Cruces, NM",
            data: [ [ 2146, 1961, 2165 ], [ 1447, 1174, 1326 ], [ 140, 123, 118 ], [ 50, 64, 54 ], [ 4002, 3609, 4452 ], [ 2229, 2005, 2657 ] ]
        },
        msa178: {
            name: "Las Vegas-Henderson-Paradise, NV",
            data: [ [ 30537, 25651, 25546 ], [ 20805, 17787, 17277 ], [ 337, 349, 435 ], [ 114, 128, 154 ], [ 22089, 17244, 45429 ], [ 12503, 9853, 30045 ] ]
        },
        msa179: {
            name: "Lawrence, KS",
            data: [ [ 1214, 999, 1169 ], [ 939, 789, 915 ], [ 77, 73, 152 ], [ 47, 49, 116 ], [ 3067, 2462, 3292 ], [ 2077, 1642, 2302 ] ]
        },
        msa180: {
            name: "Lawton, OK",
            data: [ [ 1720, 1414, 1440 ], [ 1345, 1094, 1118 ], [ 130, 75, 45 ], [ 61, 44, 18 ], [ 2111, 2034, 2379 ], [ 1130, 1076, 1395 ] ]
        },
        msa181: {
            name: "Lebanon, PA",
            data: [ [ 1373, 1232, 1306 ], [ 1025, 935, 1012 ], [ 170, 183, 207 ], [ 116, 131, 162 ], [ 3384, 2937, 3745 ], [ 2025, 1788, 2440 ] ]
        },
        msa182: {
            name: "Lewiston-Auburn, ME",
            data: [ [ 1024, 912, 1022 ], [ 715, 639, 715 ], [ 156, 163, 150 ], [ 100, 117, 103 ], [ 2524, 2233, 2956 ], [ 1363, 1180, 1731 ] ]
        },
        msa183: {
            name: "Lewiston, ID-WA",
            data: [ [ 693, 641, 688 ], [ 520, 438, 482 ], [ 100, 93, 84 ], [ 63, 56, 54 ], [ 2087, 1624, 2305 ], [ 1237, 951, 1444 ] ]
        },
        msa184: {
            name: "Lexington-Fayette, KY",
            data: [ [ 5895, 5911, 6954 ], [ 4190, 3829, 4651 ], [ 296, 242, 290 ], [ 162, 122, 194 ], [ 15008, 13011, 17690 ], [ 9006, 7827, 11417 ] ]
        },
        msa185: {
            name: "Lima, OH",
            data: [ [ 830, 782, 853 ], [ 576, 552, 614 ], [ 63, 41, 59 ], [ 22, 20, 32 ], [ 2715, 2272, 3104 ], [ 1660, 1374, 2025 ] ]
        },
        msa186: {
            name: "Lincoln, NE",
            data: [ [ 3574, 3238, 3952 ], [ 2888, 2690, 3279 ], [ 297, 275, 337 ], [ 223, 205, 235 ], [ 11008, 8875, 12040 ], [ 8040, 6367, 8904 ] ]
        },
        msa187: {
            name: "Little Rock-North Little Rock-Conway, AR",
            data: [ [ 10379, 9585, 10374 ], [ 7455, 6515, 7197 ], [ 662, 576, 619 ], [ 305, 285, 368 ], [ 18243, 14538, 20501 ], [ 10506, 8108, 12564 ] ]
        },
        msa188: {
            name: "Logan, UT-ID",
            data: [ [ 1400, 1310, 1411 ], [ 1067, 970, 1108 ], [ 104, 85, 101 ], [ 74, 50, 66 ], [ 3970, 2941, 4147 ], [ 2663, 1906, 2988 ] ]
        },
        msa189: {
            name: "Longview, TX",
            data: [ [ 2518, 2703, 2704 ], [ 1563, 1554, 1627 ], [ 287, 226, 279 ], [ 190, 128, 170 ], [ 2201, 2332, 2442 ], [ 1257, 1318, 1369 ] ]
        },
        msa190: {
            name: "Longview, WA",
            data: [ [ 1039, 872, 1056 ], [ 645, 558, 687 ], [ 83, 64, 93 ], [ 46, 39, 57 ], [ 3227, 2566, 3671 ], [ 1843, 1429, 2177 ] ]
        },
        msa191: {
            name: "Louisville/Jefferson County, KY-IN",
            data: [ [ 15798, 14822, 17429 ], [ 10854, 10021, 12033 ], [ 1422, 1344, 1573 ], [ 825, 817, 971 ], [ 44849, 37534, 49054 ], [ 25348, 21089, 29755 ] ]
        },
        msa192: {
            name: "Lubbock, TX",
            data: [ [ 3295, 2883, 3426 ], [ 2596, 2235, 2704 ], [ 233, 181, 148 ], [ 114, 88, 82 ], [ 3627, 3292, 4224 ], [ 2218, 1982, 2718 ] ]
        },
        msa193: {
            name: "Lynchburg, VA",
            data: [ [ 2418, 2199, 2432 ], [ 1708, 1573, 1628 ], [ 276, 248, 221 ], [ 183, 147, 139 ], [ 5982, 5235, 6068 ], [ 3778, 3123, 3882 ] ]
        },
        msa194: {
            name: "Macon, GA",
            data: [ [ 1600, 1480, 1583 ], [ 967, 875, 955 ], [ 122, 129, 127 ], [ 57, 74, 62 ], [ 3799, 3738, 4407 ], [ 1814, 1913, 2545 ] ]
        },
        msa195: {
            name: "Madera, CA",
            data: [ [ 1483, 1425, 1193 ], [ 1014, 948, 831 ], [ 50, 47, 37 ], [ 23, 22, 21 ], [ 1823, 1652, 3255 ], [ 863, 833, 1958 ] ]
        },
        msa196: {
            name: "Madison, WI",
            data: [ [ 6424, 5880, 7213 ], [ 4839, 4517, 5699 ], [ 1014, 1160, 1344 ], [ 790, 865, 1096 ], [ 30252, 25426, 33479 ], [ 21592, 17969, 25002 ] ]
        },
        msa197: {
            name: "Manchester-Nashua, NH",
            data: [ [ 4198, 3960, 4750 ], [ 3028, 2857, 3481 ], [ 387, 399, 458 ], [ 228, 236, 290 ], [ 14839, 12348, 16853 ], [ 8917, 7262, 10593 ] ]
        },
        msa198: {
            name: "Manhattan, KS",
            data: [ [ 1544, 1496, 1711 ], [ 1076, 1044, 1284 ], [ 134, 125, 157 ], [ 101, 90, 130 ], [ 2417, 2255, 2917 ], [ 1498, 1395, 1982 ] ]
        },
        msa199: {
            name: "Mankato-North Mankato, MN",
            data: [ [ 899, 893, 997 ], [ 685, 670, 801 ], [ 80, 68, 87 ], [ 48, 43, 70 ], [ 3027, 2509, 3345 ], [ 2039, 1696, 2412 ] ]
        },
        msa200: {
            name: "Mansfield, OH",
            data: [ [ 829, 813, 939 ], [ 584, 615, 719 ], [ 103, 96, 132 ], [ 63, 58, 83 ], [ 2149, 1920, 2828 ], [ 1232, 1110, 1749 ] ]
        },
        msa201: {
            name: "Mayag?ez, PR",
            data: [ [ 357, 461, 390 ], [ 177, 249, 206 ], [ 50, 40, 24 ], [ 23, 24, 14 ], [ 444, 414, 605 ], [ 226, 206, 314 ] ]
        },
        msa202: {
            name: "McAllen-Edinburg-Mission, TX",
            data: [ [ 4305, 3827, 3774 ], [ 2572, 2144, 2183 ], [ 638, 537, 525 ], [ 136, 126, 132 ], [ 4989, 5494, 5583 ], [ 1718, 2040, 2373 ] ]
        },
        msa203: {
            name: "Medford, OR",
            data: [ [ 2100, 1964, 2460 ], [ 1437, 1326, 1695 ], [ 117, 83, 118 ], [ 64, 50, 82 ], [ 4829, 4059, 6782 ], [ 2716, 2203, 4228 ] ]
        },
        msa204: {
            name: "Memphis, TN-MS-AR",
            data: [ [ 12291, 10836, 11997 ], [ 9093, 7872, 8817 ], [ 513, 470, 525 ], [ 220, 201, 229 ], [ 26194, 21777, 30167 ], [ 13699, 10896, 17418 ] ]
        },
        msa205: {
            name: "Merced, CA",
            data: [ [ 3088, 2462, 2135 ], [ 2040, 1676, 1429 ], [ 69, 72, 45 ], [ 46, 40, 17 ], [ 1936, 1849, 4772 ], [ 915, 932, 2885 ] ]
        },
        msa206: {
            name: "Michigan City-La Porte, IN",
            data: [ [ 929, 818, 924 ], [ 645, 594, 647 ], [ 115, 164, 151 ], [ 65, 92, 87 ], [ 3021, 2610, 3338 ], [ 1476, 1386, 1938 ] ]
        },
        msa207: {
            name: "Midland, TX",
            data: [ [ 1995, 2731, 3501 ], [ 1426, 1986, 2430 ], [ 129, 117, 141 ], [ 62, 61, 76 ], [ 1967, 1883, 2168 ], [ 1082, 1039, 1292 ] ]
        },
        msa208: {
            name: "Milwaukee-Waukesha-West Allis, WI",
            data: [ [ 12739, 11727, 14451 ], [ 9633, 9060, 11272 ], [ 1647, 1343, 1753 ], [ 1068, 955, 1321 ], [ 61161, 46852, 64574 ], [ 42075, 31173, 45462 ] ]
        },
        msa209: {
            name: "Minneapolis-St. Paul-Bloomington, MN-WI",
            data: [ [ 38512, 37820, 44980 ], [ 29178, 29380, 35696 ], [ 2859, 2484, 3148 ], [ 1710, 1534, 2154 ], [ 130279, 101198, 153903 ], [ 81867, 62168, 105027 ] ]
        },
        msa210: {
            name: "Missoula, MT",
            data: [ [ 1148, 1023, 1138 ], [ 838, 766, 849 ], [ 112, 89, 85 ], [ 87, 64, 59 ], [ 3438, 2629, 3847 ], [ 2267, 1714, 2674 ] ]
        },
        msa211: {
            name: "Mobile, AL",
            data: [ [ 4153, 3810, 3881 ], [ 2578, 2397, 2376 ], [ 250, 223, 227 ], [ 84, 63, 84 ], [ 8741, 7090, 8409 ], [ 4073, 3113, 4276 ] ]
        },
        msa212: {
            name: "Modesto, CA",
            data: [ [ 6944, 5927, 5403 ], [ 4845, 4225, 3939 ], [ 154, 144, 168 ], [ 71, 64, 93 ], [ 6854, 5532, 13033 ], [ 3833, 2993, 8521 ] ]
        },
        msa213: {
            name: "Monroe, LA",
            data: [ [ 2283, 2119, 2113 ], [ 1293, 1210, 1254 ], [ 146, 118, 135 ], [ 66, 59, 67 ], [ 3052, 2957, 3491 ], [ 1739, 1583, 1979 ] ]
        },
        msa214: {
            name: "Monroe, MI",
            data: [ [ 1544, 1609, 1685 ], [ 985, 1076, 1160 ], [ 76, 66, 105 ], [ 39, 32, 58 ], [ 3288, 2978, 5571 ], [ 1795, 1696, 3640 ] ]
        },
        msa215: {
            name: "Montgomery, AL",
            data: [ [ 3626, 3501, 3830 ], [ 2376, 2119, 2456 ], [ 155, 157, 179 ], [ 59, 72, 82 ], [ 8716, 7428, 10425 ], [ 4484, 3628, 5622 ] ]
        },
        msa216: {
            name: "Morgantown, WV",
            data: [ [ 1643, 1670, 1794 ], [ 1039, 1063, 1124 ], [ 159, 169, 212 ], [ 91, 101, 142 ], [ 2721, 2197, 2514 ], [ 1557, 1351, 1591 ] ]
        },
        msa217: {
            name: "Morristown, TN",
            data: [ [ 1338, 1532, 1641 ], [ 761, 752, 807 ], [ 132, 125, 166 ], [ 64, 73, 112 ], [ 3050, 2611, 3165 ], [ 1617, 1353, 1692 ] ]
        },
        msa218: {
            name: "Mount Vernon-Anacortes, WA",
            data: [ [ 1240, 1088, 1326 ], [ 869, 777, 948 ], [ 110, 92, 127 ], [ 69, 55, 73 ], [ 4142, 3306, 4519 ], [ 2546, 1975, 2810 ] ]
        },
        msa219: {
            name: "Muncie, IN",
            data: [ [ 817, 713, 827 ], [ 599, 504, 570 ], [ 90, 104, 162 ], [ 48, 67, 94 ], [ 2144, 1936, 2338 ], [ 1184, 999, 1370 ] ]
        },
        msa220: {
            name: "Muskegon, MI",
            data: [ [ 1360, 1462, 1636 ], [ 924, 1009, 1107 ], [ 120, 107, 105 ], [ 59, 47, 46 ], [ 3483, 3233, 4549 ], [ 1883, 1838, 2846 ] ]
        },
        msa221: {
            name: "Myrtle Beach-Conway-North Myrtle Beach, SC-NC",
            data: [ [ 3361, 3333, 3966 ], [ 2057, 1935, 2432 ], [ 188, 164, 189 ], [ 134, 96, 127 ], [ 6827, 5937, 8035 ], [ 3359, 3049, 4498 ] ]
        },
        msa222: {
            name: "Napa, CA",
            data: [ [ 1399, 1311, 1519 ], [ 902, 885, 958 ], [ 88, 104, 67 ], [ 48, 66, 43 ], [ 3892, 3220, 5109 ], [ 2250, 1836, 3153 ] ]
        },
        msa223: {
            name: "Naples-Immokalee-Marco Island, FL",
            data: [ [ 3388, 3080, 3541 ], [ 2113, 1962, 2301 ], [ 72, 88, 116 ], [ 31, 36, 53 ], [ 5064, 4491, 7350 ], [ 2483, 2393, 4207 ] ]
        },
        msa224: {
            name: "Nashville-Davidson--Murfreesboro--Franklin, TN",
            data: [ [ 21661, 21235, 26499 ], [ 15719, 15053, 18970 ], [ 1023, 994, 1165 ], [ 563, 539, 641 ], [ 49395, 44203, 60175 ], [ 27673, 23862, 35351 ] ]
        },
        msa225: {
            name: "New Haven-Milford, CT",
            data: [ [ 7633, 6502, 6891 ], [ 5339, 4494, 4991 ], [ 943, 900, 872 ], [ 585, 538, 552 ], [ 22591, 19263, 25079 ], [ 13078, 11022, 15443 ] ]
        },
        msa226: {
            name: "New Orleans-Metairie, LA",
            data: [ [ 10535, 11049, 12719 ], [ 6582, 7080, 8348 ], [ 1211, 1103, 1131 ], [ 430, 399, 506 ], [ 26731, 25733, 29011 ], [ 13775, 12707, 15204 ] ]
        },
        msa227: {
            name: "Niles-Benton Harbor, MI",
            data: [ [ 1185, 1157, 1384 ], [ 850, 802, 951 ], [ 259, 270, 268 ], [ 141, 133, 147 ], [ 4045, 3843, 4606 ], [ 2343, 2140, 2845 ] ]
        },
        msa228: {
            name: "North Port-Sarasota-Bradenton, FL",
            data: [ [ 7174, 6839, 8278 ], [ 4614, 4500, 5609 ], [ 264, 187, 303 ], [ 100, 95, 144 ], [ 11207, 10065, 18046 ], [ 5719, 5582, 11135 ] ]
        },
        msa229: {
            name: "Norwich-New London, CT",
            data: [ [ 2510, 2133, 2348 ], [ 1742, 1516, 1720 ], [ 449, 398, 474 ], [ 323, 271, 348 ], [ 8020, 6527, 9015 ], [ 4591, 3772, 5694 ] ]
        },
        msa230: {
            name: "Ocala, FL",
            data: [ [ 2886, 2793, 3058 ], [ 1755, 1739, 1889 ], [ 160, 114, 167 ], [ 48, 42, 63 ], [ 4526, 3859, 6617 ], [ 1992, 1857, 3830 ] ]
        },
        msa231: {
            name: "Ocean City, NJ",
            data: [ [ 743, 707, 714 ], [ 492, 474, 493 ], [ 203, 167, 204 ], [ 134, 97, 128 ], [ 3320, 2716, 3263 ], [ 1726, 1448, 1814 ] ]
        },
        msa232: {
            name: "Odessa, TX",
            data: [ [ 1510, 1681, 2431 ], [ 928, 1009, 1472 ], [ 168, 124, 114 ], [ 55, 47, 54 ], [ 1232, 1056, 1179 ], [ 596, 520, 638 ] ]
        },
        msa233: {
            name: "Ogden-Clearfield, UT",
            data: [ [ 7469, 6731, 8639 ], [ 5628, 4909, 6640 ], [ 845, 641, 827 ], [ 627, 437, 580 ], [ 22600, 15507, 26076 ], [ 15335, 9813, 18585 ] ]
        },
        msa234: {
            name: "Oklahoma City, OK",
            data: [ [ 18003, 17578, 20054 ], [ 13117, 12532, 14503 ], [ 1603, 1241, 1637 ], [ 745, 643, 949 ], [ 28216, 25124, 31514 ], [ 15962, 14605, 19635 ] ]
        },
        msa235: {
            name: "Olympia-Tumwater, WA",
            data: [ [ 3558, 3049, 3289 ], [ 2632, 2264, 2482 ], [ 171, 162, 213 ], [ 100, 98, 132 ], [ 10107, 8097, 11882 ], [ 6387, 4995, 7815 ] ]
        },
        msa236: {
            name: "Omaha-Council Bluffs, NE-IA",
            data: [ [ 10932, 10193, 11906 ], [ 8994, 8278, 9745 ], [ 968, 962, 1149 ], [ 609, 611, 780 ], [ 34252, 25749, 36147 ], [ 23303, 17060, 25287 ] ]
        },
        msa237: {
            name: "Orlando-Kissimmee-Sanford, FL",
            data: [ [ 25645, 23212, 25351 ], [ 16062, 14627, 16149 ], [ 662, 457, 666 ], [ 248, 175, 299 ], [ 27270, 24398, 53516 ], [ 13174, 13173, 33032 ] ]
        },
        msa238: {
            name: "Oshkosh-Neenah, WI",
            data: [ [ 1625, 1531, 1758 ], [ 1224, 1167, 1365 ], [ 256, 268, 326 ], [ 197, 204, 248 ], [ 6896, 5750, 7539 ], [ 4749, 3837, 5319 ] ]
        },
        msa239: {
            name: "Owensboro, KY",
            data: [ [ 1441, 1588, 1868 ], [ 998, 1006, 1270 ], [ 139, 180, 209 ], [ 87, 114, 135 ], [ 2766, 2527, 2988 ], [ 1664, 1549, 1913 ] ]
        },
        msa240: {
            name: "Oxnard-Thousand Oaks-Ventura, CA",
            data: [ [ 8618, 7608, 8355 ], [ 5839, 5252, 5928 ], [ 608, 800, 578 ], [ 408, 501, 395 ], [ 27497, 23869, 37336 ], [ 17481, 15189, 24919 ] ]
        },
        msa241: {
            name: "Palm Bay-Melbourne-Titusville, FL",
            data: [ [ 5530, 5273, 6382 ], [ 3871, 3562, 4360 ], [ 184, 176, 216 ], [ 82, 73, 94 ], [ 8855, 8167, 16672 ], [ 4333, 4450, 9931 ] ]
        },
        msa242: {
            name: "Panama City, FL",
            data: [ [ 1837, 2048, 2207 ], [ 1085, 1158, 1254 ], [ 216, 175, 163 ], [ 92, 105, 84 ], [ 3191, 2556, 4199 ], [ 1509, 1297, 2313 ] ]
        },
        msa243: {
            name: "Parkersburg-Vienna, WV",
            data: [ [ 1484, 1717, 1687 ], [ 995, 1114, 1074 ], [ 217, 203, 209 ], [ 141, 131, 159 ], [ 2888, 2419, 3141 ], [ 1606, 1493, 2088 ] ]
        },
        msa244: {
            name: "Pensacola-Ferry Pass-Brent, FL",
            data: [ [ 4638, 4813, 5392 ], [ 3289, 3314, 3682 ], [ 200, 192, 164 ], [ 86, 114, 79 ], [ 8519, 7472, 11652 ], [ 4453, 4131, 7056 ] ]
        },
        msa245: {
            name: "Peoria, IL",
            data: [ [ 4186, 4142, 4902 ], [ 3447, 3437, 4065 ], [ 532, 500, 565 ], [ 348, 307, 397 ], [ 11228, 9209, 11831 ], [ 7583, 5968, 8259 ] ]
        },
        msa246: {
            name: "Phoenix-Mesa-Scottsdale, AZ",
            data: [ [ 64274, 60051, 61729 ], [ 45347, 42699, 43646 ], [ 1237, 1210, 1514 ], [ 502, 534, 803 ], [ 80038, 62892, 148129 ], [ 48038, 37827, 101112 ] ]
        },
        msa247: {
            name: "Pine Bluff, AR",
            data: [ [ 948, 877, 911 ], [ 485, 396, 381 ], [ 82, 57, 70 ], [ 40, 25, 35 ], [ 1331, 973, 1270 ], [ 668, 461, 639 ] ]
        },
        msa248: {
            name: "Pittsburgh, PA",
            data: [ [ 22993, 21476, 23936 ], [ 17570, 16241, 18379 ], [ 4266, 4352, 5326 ], [ 2739, 2681, 3477 ], [ 54008, 49988, 61958 ], [ 31085, 29182, 38787 ] ]
        },
        msa249: {
            name: "Pittsfield, MA",
            data: [ [ 1166, 1084, 1245 ], [ 834, 727, 872 ], [ 424, 313, 397 ], [ 313, 210, 292 ], [ 3292, 2459, 3670 ], [ 2104, 1435, 2363 ] ]
        },
        msa250: {
            name: "Pocatello, ID",
            data: [ [ 1094, 994, 1031 ], [ 799, 734, 678 ], [ 66, 55, 73 ], [ 41, 29, 40 ], [ 2705, 2184, 2832 ], [ 1587, 1280, 1767 ] ]
        },
        msa251: {
            name: "Ponce, PR",
            data: [ [ 1267, 1601, 1258 ], [ 694, 966, 745 ], [ 149, 148, 99 ], [ 72, 54, 60 ], [ 1244, 999, 1434 ], [ 723, 576, 892 ] ]
        },
        msa252: {
            name: "Port St. Lucie, FL",
            data: [ [ 4612, 3927, 4527 ], [ 2882, 2554, 3032 ], [ 206, 165, 269 ], [ 83, 81, 101 ], [ 5426, 5004, 10219 ], [ 2425, 2555, 6129 ] ]
        },
        msa253: {
            name: "Portland-South Portland, ME",
            data: [ [ 6211, 5541, 6450 ], [ 4293, 3911, 4580 ], [ 1263, 820, 1111 ], [ 907, 537, 758 ], [ 20670, 16550, 21764 ], [ 12437, 9571, 13858 ] ]
        },
        msa254: {
            name: "Portland-Vancouver-Hillsboro, OR-WA",
            data: [ [ 27881, 24696, 29767 ], [ 19348, 17693, 21956 ], [ 1476, 1273, 2301 ], [ 780, 697, 1599 ], [ 87120, 66358, 96808 ], [ 54397, 39789, 62656 ] ]
        },
        msa255: {
            name: "Prescott, AZ",
            data: [ [ 2401, 2460, 2858 ], [ 1621, 1662, 1904 ], [ 116, 73, 97 ], [ 49, 32, 47 ], [ 5320, 4468, 7428 ], [ 2836, 2567, 4793 ] ]
        },
        msa256: {
            name: "Providence-Warwick, RI-MA",
            data: [ [ 13903, 12587, 13662 ], [ 9631, 8776, 9660 ], [ 1743, 1692, 2031 ], [ 1186, 1151, 1496 ], [ 46374, 37942, 53155 ], [ 28440, 22867, 34896 ] ]
        },
        msa257: {
            name: "Provo-Orem, UT",
            data: [ [ 6715, 6420, 7616 ], [ 5033, 4741, 5895 ], [ 259, 253, 277 ], [ 163, 149, 190 ], [ 16976, 11659, 19991 ], [ 11406, 7434, 14255 ] ]
        },
        msa258: {
            name: "Pueblo, CO",
            data: [ [ 1893, 1639, 1536 ], [ 1410, 1158, 1109 ], [ 124, 108, 112 ], [ 66, 55, 58 ], [ 4097, 3824, 4679 ], [ 2437, 2034, 2796 ] ]
        },
        msa259: {
            name: "Punta Gorda, FL",
            data: [ [ 1307, 1241, 1475 ], [ 835, 787, 963 ], [ 50, 41, 77 ], [ 27, 21, 33 ], [ 2569, 2252, 4091 ], [ 1221, 1192, 2572 ] ]
        },
        msa260: {
            name: "Racine, WI",
            data: [ [ 1520, 1460, 1598 ], [ 1157, 1115, 1260 ], [ 154, 137, 179 ], [ 93, 92, 116 ], [ 7655, 6079, 8150 ], [ 5059, 4001, 5807 ] ]
        },
        msa261: {
            name: "Raleigh, NC",
            data: [ [ 16756, 15576, 18497 ], [ 12305, 11046, 13474 ], [ 560, 523, 629 ], [ 301, 327, 398 ], [ 42847, 37681, 49785 ], [ 28072, 23378, 32882 ] ]
        },
        msa262: {
            name: "Rapid City, SD",
            data: [ [ 1559, 1644, 2034 ], [ 1127, 1303, 1569 ], [ 158, 155, 293 ], [ 114, 95, 199 ], [ 3393, 2945, 4188 ], [ 2171, 1971, 2830 ] ]
        },
        msa263: {
            name: "Reading, PA",
            data: [ [ 3779, 3218, 3552 ], [ 2918, 2521, 2768 ], [ 410, 352, 526 ], [ 256, 215, 348 ], [ 9908, 9092, 10931 ], [ 5727, 5209, 6722 ] ]
        },
        msa264: {
            name: "Redding, CA",
            data: [ [ 1691, 1499, 1676 ], [ 1152, 967, 1177 ], [ 104, 97, 99 ], [ 46, 47, 58 ], [ 4018, 3293, 5552 ], [ 2240, 1793, 3500 ] ]
        },
        msa265: {
            name: "Reno, NV",
            data: [ [ 5992, 5342, 5286 ], [ 4277, 3960, 4014 ], [ 138, 143, 134 ], [ 69, 80, 70 ], [ 7487, 6114, 12902 ], [ 4489, 3668, 8832 ] ]
        },
        msa266: {
            name: "Richmond, VA",
            data: [ [ 14114, 13927, 15407 ], [ 10476, 10139, 11477 ], [ 1297, 1083, 1232 ], [ 740, 581, 693 ], [ 38548, 32059, 44056 ], [ 22512, 18315, 27749 ] ]
        },
        msa267: {
            name: "Riverside-San Bernardino-Ontario, CA",
            data: [ [ 62042, 51651, 48921 ], [ 4e4, 34182, 32824 ], [ 1553, 1489, 1652 ], [ 777, 768, 979 ], [ 68529, 63967, 126078 ], [ 38129, 35302, 77689 ] ]
        },
        msa268: {
            name: "Roanoke, VA",
            data: [ [ 2899, 2986, 3038 ], [ 2154, 2091, 2190 ], [ 547, 245, 295 ], [ 434, 136, 181 ], [ 7898, 6758, 8601 ], [ 4796, 3950, 5444 ] ]
        },
        msa269: {
            name: "Rochester, MN",
            data: [ [ 2511, 2466, 2988 ], [ 1926, 1905, 2382 ], [ 218, 189, 172 ], [ 142, 125, 125 ], [ 7270, 5812, 7869 ], [ 4812, 3748, 5629 ] ]
        },
        msa270: {
            name: "Rochester, NY",
            data: [ [ 10169, 9886, 10557 ], [ 7890, 7770, 8455 ], [ 650, 706, 860 ], [ 402, 482, 590 ], [ 14800, 14108, 16748 ], [ 8588, 8186, 10520 ] ]
        },
        msa271: {
            name: "Rockford, IL",
            data: [ [ 3086, 2404, 2825 ], [ 2228, 1728, 2091 ], [ 234, 220, 227 ], [ 117, 109, 119 ], [ 11747, 9350, 12341 ], [ 7622, 5694, 8046 ] ]
        },
        msa272: {
            name: "Rocky Mount, NC",
            data: [ [ 1048, 1235, 1267 ], [ 591, 589, 595 ], [ 76, 74, 109 ], [ 34, 34, 53 ], [ 2455, 2099, 2564 ], [ 1300, 1066, 1450 ] ]
        },
        msa273: {
            name: "Rome, GA",
            data: [ [ 529, 549, 643 ], [ 366, 365, 463 ], [ 23, 28, 30 ], [ 12, 15, 8 ], [ 1396, 1333, 1893 ], [ 673, 720, 1067 ] ]
        },
        msa274: {
            name: "Sacramento--Roseville--Arden-Arcade, CA",
            data: [ [ 28632, 27059, 27805 ], [ 19645, 18933, 19687 ], [ 1473, 1366, 1575 ], [ 848, 802, 1077 ], [ 59245, 47e3, 91921 ], [ 36046, 27011, 58856 ] ]
        },
        msa275: {
            name: "Saginaw, MI",
            data: [ [ 1461, 1522, 1632 ], [ 993, 1076, 1157 ], [ 120, 133, 177 ], [ 57, 79, 107 ], [ 3547, 3203, 5027 ], [ 2181, 2030, 3388 ] ]
        },
        msa276: {
            name: "Salem, OR",
            data: [ [ 3615, 2919, 3533 ], [ 2401, 2011, 2406 ], [ 286, 236, 241 ], [ 145, 119, 149 ], [ 12067, 9158, 12269 ], [ 6940, 5107, 7433 ] ]
        },
        msa277: {
            name: "Salinas, CA",
            data: [ [ 4028, 3468, 3056 ], [ 2537, 2250, 2045 ], [ 154, 158, 207 ], [ 75, 84, 145 ], [ 6769, 6258, 9941 ], [ 3942, 3671, 6165 ] ]
        },
        msa278: {
            name: "Salisbury, MD-DE",
            data: [ [ 1033, 899, 946 ], [ 722, 584, 595 ], [ 110, 95, 92 ], [ 60, 54, 45 ], [ 2563, 2351, 2806 ], [ 1318, 1209, 1590 ] ]
        },
        msa279: {
            name: "Salt Lake City, UT",
            data: [ [ 14349, 13291, 16808 ], [ 10546, 9740, 12789 ], [ 897, 784, 937 ], [ 562, 505, 580 ], [ 41741, 28518, 47167 ], [ 27568, 17808, 33002 ] ]
        },
        msa280: {
            name: "San Angelo, TX",
            data: [ [ 1064, 1051, 1299 ], [ 841, 848, 995 ], [ 133, 134, 101 ], [ 67, 74, 53 ], [ 1370, 1322, 1559 ], [ 775, 833, 983 ] ]
        },
        msa281: {
            name: "San Antonio-New Braunfels, TX",
            data: [ [ 28244, 26043, 31061 ], [ 19280, 16998, 20188 ], [ 2237, 2278, 2261 ], [ 997, 1040, 1017 ], [ 34171, 35515, 46011 ], [ 18398, 19469, 26524 ] ]
        },
        msa282: {
            name: "San Diego-Carlsbad, CA",
            data: [ [ 36672, 32413, 35090 ], [ 24340, 21922, 24210 ], [ 1760, 1736, 2060 ], [ 1151, 1115, 1489 ], [ 91820, 83530, 133141 ], [ 58482, 52460, 89664 ] ]
        },
        msa283: {
            name: "San Germ?n, PR",
            data: [ [ 702, 982, 738 ], [ 379, 541, 402 ], [ 89, 62, 58 ], [ 42, 30, 34 ], [ 635, 674, 889 ], [ 345, 345, 521 ] ]
        },
        msa284: {
            name: "San Jose-Sunnyvale-Santa Clara, CA",
            data: [ [ 20716, 18660, 19556 ], [ 13855, 12608, 13866 ], [ 1425, 1484, 1844 ], [ 973, 942, 1386 ], [ 89586, 78023, 109633 ], [ 60887, 52861, 80882 ] ]
        },
        msa285: {
            name: "San Juan-Carolina-Caguas, PR",
            data: [ [ 15323, 19314, 15730 ], [ 8688, 11251, 9207 ], [ 1887, 1336, 1229 ], [ 1063, 730, 737 ], [ 17374, 13452, 22169 ], [ 9318, 7001, 13439 ] ]
        },
        msa286: {
            name: "San Luis Obispo-Paso Robles-Arroyo Grande, CA",
            data: [ [ 2448, 2594, 2807 ], [ 1689, 1818, 2026 ], [ 233, 200, 227 ], [ 138, 138, 162 ], [ 8997, 7264, 11189 ], [ 5473, 4468, 7416 ] ]
        },
        msa287: {
            name: "Santa Cruz-Watsonville, CA",
            data: [ [ 2087, 2051, 2282 ], [ 1318, 1346, 1521 ], [ 182, 162, 230 ], [ 113, 100, 146 ], [ 8141, 7116, 10732 ], [ 5132, 4595, 7246 ] ]
        },
        msa288: {
            name: "Santa Fe, NM",
            data: [ [ 1381, 1321, 1464 ], [ 835, 766, 871 ], [ 107, 87, 105 ], [ 54, 61, 58 ], [ 4750, 4096, 5686 ], [ 2551, 2187, 3115 ] ]
        },
        msa289: {
            name: "Santa Rosa, CA",
            data: [ [ 4686, 4430, 4800 ], [ 3220, 3099, 3414 ], [ 339, 406, 430 ], [ 213, 258, 303 ], [ 15296, 12410, 19552 ], [ 9839, 7958, 13403 ] ]
        },
        msa290: {
            name: "Savannah, GA",
            data: [ [ 4146, 4301, 4493 ], [ 3043, 3036, 3297 ], [ 151, 135, 142 ], [ 67, 64, 74 ], [ 7967, 7276, 9149 ], [ 4036, 3851, 5264 ] ]
        },
        msa291: {
            name: "Scranton--Wilkes-Barre--Hazleton, PA",
            data: [ [ 4181, 4024, 4057 ], [ 2851, 2785, 2823 ], [ 1004, 918, 1089 ], [ 655, 590, 706 ], [ 11016, 10016, 12109 ], [ 5659, 5083, 6856 ] ]
        },
        msa292: {
            name: "Sebastian-Vero Beach, FL",
            data: [ [ 1196, 1084, 1378 ], [ 816, 721, 929 ], [ 57, 63, 86 ], [ 21, 26, 40 ], [ 2110, 1956, 3405 ], [ 1051, 1026, 2054 ] ]
        },
        msa293: {
            name: "Sheboygan, WI",
            data: [ [ 839, 727, 1003 ], [ 645, 582, 800 ], [ 206, 186, 257 ], [ 146, 144, 197 ], [ 4801, 3801, 4865 ], [ 3351, 2597, 3515 ] ]
        },
        msa294: {
            name: "Sherman-Denison, TX",
            data: [ [ 1186, 1178, 1359 ], [ 715, 677, 799 ], [ 83, 51, 82 ], [ 34, 25, 34 ], [ 1592, 1759, 1924 ], [ 837, 914, 1050 ] ]
        },
        msa295: {
            name: "Shreveport-Bossier City, LA",
            data: [ [ 5802, 5130, 5527 ], [ 3809, 3221, 3635 ], [ 277, 353, 484 ], [ 104, 168, 191 ], [ 7480, 6900, 9249 ], [ 4004, 3570, 5287 ] ]
        },
        msa296: {
            name: "Sioux City, IA-NE-SD",
            data: [ [ 1741, 1512, 1624 ], [ 1217, 1009, 1177 ], [ 189, 152, 220 ], [ 121, 95, 151 ], [ 3330, 3112, 4094 ], [ 1914, 1822, 2537 ] ]
        },
        msa297: {
            name: "Sioux Falls, SD",
            data: [ [ 3626, 3209, 3968 ], [ 2850, 2574, 3246 ], [ 285, 260, 363 ], [ 200, 159, 278 ], [ 9459, 7496, 10888 ], [ 6048, 4756, 7454 ] ]
        },
        msa298: {
            name: "South Bend-Mishawaka, IN-MI",
            data: [ [ 2476, 2375, 2661 ], [ 1875, 1805, 2089 ], [ 209, 206, 268 ], [ 104, 102, 165 ], [ 8117, 6986, 8963 ], [ 4601, 4006, 5583 ] ]
        },
        msa299: {
            name: "Spartanburg, SC",
            data: [ [ 3526, 4121, 4774 ], [ 1897, 1748, 2260 ], [ 141, 156, 184 ], [ 70, 91, 91 ], [ 5962, 5391, 6724 ], [ 3008, 2765, 3840 ] ]
        },
        msa300: {
            name: "Spokane-Spokane Valley, WA",
            data: [ [ 5366, 4631, 5210 ], [ 4016, 3455, 3893 ], [ 705, 483, 753 ], [ 485, 285, 458 ], [ 16032, 12641, 17606 ], [ 9565, 7410, 10785 ] ]
        },
        msa301: {
            name: "Springfield, IL",
            data: [ [ 2767, 2645, 2917 ], [ 2270, 2181, 2434 ], [ 444, 310, 520 ], [ 379, 239, 431 ], [ 9708, 7277, 10260 ], [ 7786, 5384, 8066 ] ]
        },
        msa302: {
            name: "Springfield, MA",
            data: [ [ 6110, 5504, 5999 ], [ 4375, 3887, 4292 ], [ 1079, 1025, 1197 ], [ 734, 719, 876 ], [ 16054, 13092, 17281 ], [ 9770, 7936, 11092 ] ]
        },
        msa303: {
            name: "Springfield, MO",
            data: [ [ 5370, 4813, 5424 ], [ 4007, 3411, 3939 ], [ 287, 231, 268 ], [ 166, 138, 159 ], [ 13508, 10513, 14048 ], [ 8465, 6468, 9317 ] ]
        },
        msa304: {
            name: "Springfield, OH",
            data: [ [ 1083, 978, 1149 ], [ 753, 685, 797 ], [ 76, 84, 122 ], [ 29, 44, 68 ], [ 3098, 2636, 3600 ], [ 1722, 1437, 2057 ] ]
        },
        msa305: {
            name: "St. Cloud, MN",
            data: [ [ 1632, 1687, 1960 ], [ 1240, 1310, 1550 ], [ 136, 107, 138 ], [ 97, 78, 98 ], [ 6025, 4477, 6329 ], [ 4061, 2923, 4576 ] ]
        },
        msa306: {
            name: "St. George, UT",
            data: [ [ 1879, 1980, 2152 ], [ 1331, 1422, 1609 ], [ 61, 41, 85 ], [ 36, 22, 55 ], [ 3580, 2783, 4647 ], [ 2175, 1665, 3156 ] ]
        },
        msa307: {
            name: "St. Joseph, MO-KS",
            data: [ [ 1009, 1034, 1153 ], [ 699, 727, 804 ], [ 150, 131, 189 ], [ 94, 78, 124 ], [ 2752, 2281, 2854 ], [ 1567, 1229, 1703 ] ]
        },
        msa308: {
            name: "St. Louis, MO-IL",
            data: [ [ 31150, 28608, 32133 ], [ 22975, 20780, 23316 ], [ 2483, 2242, 2647 ], [ 1543, 1291, 1719 ], [ 112775, 87527, 119177 ], [ 77096, 57350, 82386 ] ]
        },
        msa309: {
            name: "State College, PA",
            data: [ [ 1308, 1248, 1448 ], [ 1024, 977, 1132 ], [ 205, 185, 227 ], [ 152, 146, 181 ], [ 3485, 2989, 3844 ], [ 2329, 1942, 2662 ] ]
        },
        msa310: {
            name: "Stockton-Lodi, CA",
            data: [ [ 9767, 8282, 7708 ], [ 6628, 5727, 5505 ], [ 197, 219, 187 ], [ 94, 83, 108 ], [ 9497, 8383, 18334 ], [ 5135, 4565, 11597 ] ]
        },
        msa311: {
            name: "Sumter, SC",
            data: [ [ 1054, 1e3, 989 ], [ 581, 576, 518 ], [ 60, 88, 72 ], [ 28, 42, 41 ], [ 1844, 1613, 1885 ], [ 887, 847, 1078 ] ]
        },
        msa312: {
            name: "Syracuse, NY",
            data: [ [ 6094, 5940, 6630 ], [ 4784, 4570, 5077 ], [ 458, 510, 665 ], [ 326, 342, 480 ], [ 9511, 9162, 10677 ], [ 5704, 5378, 6895 ] ]
        },
        msa313: {
            name: "Tallahassee, FL",
            data: [ [ 3410, 3049, 3336 ], [ 2185, 1899, 2080 ], [ 205, 140, 193 ], [ 99, 82, 125 ], [ 6335, 5325, 7882 ], [ 3499, 2920, 4743 ] ]
        },
        msa314: {
            name: "Tampa-St. Petersburg-Clearwater, FL",
            data: [ [ 29118, 28217, 32076 ], [ 18877, 18272, 21032 ], [ 966, 976, 1390 ], [ 374, 404, 650 ], [ 41028, 36142, 65477 ], [ 20251, 18825, 39087 ] ]
        },
        msa315: {
            name: "Terre Haute, IN",
            data: [ [ 1706, 1611, 1538 ], [ 1161, 1092, 1089 ], [ 225, 260, 320 ], [ 143, 152, 182 ], [ 3779, 3297, 4094 ], [ 2014, 1738, 2384 ] ]
        },
        msa316: {
            name: "Texarkana, TX-AR",
            data: [ [ 1416, 1426, 1432 ], [ 898, 848, 884 ], [ 121, 125, 206 ], [ 55, 53, 88 ], [ 1513, 1584, 1832 ], [ 830, 893, 1076 ] ]
        },
        msa317: {
            name: "Toledo, OH",
            data: [ [ 5066, 4931, 5469 ], [ 3686, 3568, 4018 ], [ 337, 292, 367 ], [ 158, 123, 182 ], [ 14770, 12974, 18123 ], [ 8386, 7299, 11234 ] ]
        },
        msa318: {
            name: "Topeka, KS",
            data: [ [ 2690, 2569, 2494 ], [ 1925, 1819, 1818 ], [ 259, 255, 337 ], [ 180, 181, 253 ], [ 6161, 5389, 6170 ], [ 3648, 3249, 3960 ] ]
        },
        msa319: {
            name: "Trenton, NJ",
            data: [ [ 3159, 2818, 3042 ], [ 2221, 1894, 2133 ], [ 346, 387, 359 ], [ 206, 233, 235 ], [ 10895, 9809, 12287 ], [ 6186, 5736, 7716 ] ]
        },
        msa320: {
            name: "Tucson, AZ",
            data: [ [ 11358, 11387, 12347 ], [ 7645, 7871, 8678 ], [ 451, 529, 602 ], [ 207, 296, 362 ], [ 23700, 17860, 30473 ], [ 14088, 10749, 20051 ] ]
        },
        msa321: {
            name: "Tulsa, OK",
            data: [ [ 11960, 11258, 13243 ], [ 8598, 7562, 9161 ], [ 1290, 986, 1239 ], [ 614, 523, 691 ], [ 21408, 17903, 22681 ], [ 12044, 10086, 13637 ] ]
        },
        msa322: {
            name: "Tuscaloosa, AL",
            data: [ [ 2324, 2469, 2660 ], [ 1611, 1688, 1742 ], [ 104, 112, 118 ], [ 54, 60, 72 ], [ 4836, 3705, 5286 ], [ 2751, 2017, 3339 ] ]
        },
        msa323: {
            name: "Tyler, TX",
            data: [ [ 2724, 2515, 2915 ], [ 1677, 1632, 1847 ], [ 273, 191, 281 ], [ 154, 109, 149 ], [ 3166, 3019, 3606 ], [ 1826, 1718, 2104 ] ]
        },
        msa324: {
            name: "Utica-Rome, NY",
            data: [ [ 2045, 2098, 2248 ], [ 1548, 1527, 1696 ], [ 286, 276, 500 ], [ 198, 195, 383 ], [ 3858, 3721, 4147 ], [ 2396, 2201, 2737 ] ]
        },
        msa325: {
            name: "Valdosta, GA",
            data: [ [ 1231, 1057, 1236 ], [ 915, 742, 835 ], [ 95, 79, 90 ], [ 66, 51, 54 ], [ 2387, 2450, 2725 ], [ 1429, 1539, 1709 ] ]
        },
        msa326: {
            name: "Vallejo-Fairfield, CA",
            data: [ [ 6335, 5583, 5567 ], [ 4333, 3834, 3617 ], [ 155, 162, 147 ], [ 83, 85, 89 ], [ 8382, 7138, 15043 ], [ 4876, 4009, 9607 ] ]
        },
        msa327: {
            name: "Victoria, TX",
            data: [ [ 1103, 1180, 1460 ], [ 743, 774, 979 ], [ 92, 126, 119 ], [ 39, 66, 65 ], [ 1249, 1058, 1184 ], [ 695, 587, 687 ] ]
        },
        msa328: {
            name: "Vineland-Bridgeton, NJ",
            data: [ [ 1033, 848, 811 ], [ 707, 588, 558 ], [ 211, 184, 191 ], [ 117, 112, 101 ], [ 2754, 2263, 2644 ], [ 1334, 1042, 1408 ] ]
        },
        msa329: {
            name: "Virginia Beach-Norfolk-Newport News, VA-NC",
            data: [ [ 18180, 18789, 20392 ], [ 14247, 14381, 15759 ], [ 2401, 1431, 1605 ], [ 1853, 837, 993 ], [ 49458, 45313, 61948 ], [ 29222, 26673, 39412 ] ]
        },
        msa330: {
            name: "Visalia-Porterville, CA",
            data: [ [ 3244, 3060, 2997 ], [ 2357, 2228, 2185 ], [ 166, 142, 118 ], [ 76, 73, 62 ], [ 4685, 4122, 8262 ], [ 2302, 2049, 5092 ] ]
        },
        msa331: {
            name: "Waco, TX",
            data: [ [ 2506, 2475, 2709 ], [ 1844, 1718, 1834 ], [ 204, 210, 233 ], [ 107, 111, 131 ], [ 2534, 2569, 3041 ], [ 1495, 1483, 1789 ] ]
        },
        msa332: {
            name: "Warner Robins, GA",
            data: [ [ 1927, 1685, 1698 ], [ 1520, 1267, 1287 ], [ 107, 75, 64 ], [ 61, 50, 29 ], [ 3316, 3202, 4367 ], [ 1913, 1950, 2793 ] ]
        },
        msa333: {
            name: "Waterloo-Cedar Falls, IA",
            data: [ [ 2507, 2207, 2301 ], [ 1993, 1703, 1846 ], [ 197, 169, 152 ], [ 144, 124, 104 ], [ 5159, 4228, 5102 ], [ 3554, 2803, 3714 ] ]
        },
        msa334: {
            name: "Wausau, WI",
            data: [ [ 1242, 1188, 1335 ], [ 892, 884, 1032 ], [ 247, 239, 458 ], [ 181, 195, 377 ], [ 5534, 4054, 5707 ], [ 3789, 2663, 4132 ] ]
        },
        msa335: {
            name: "Wenatchee, WA",
            data: [ [ 1042, 955, 1198 ], [ 708, 696, 868 ], [ 178, 110, 160 ], [ 118, 76, 127 ], [ 3402, 2794, 3556 ], [ 2093, 1638, 2259 ] ]
        },
        msa336: {
            name: "Wheeling, WV-OH",
            data: [ [ 1258, 1131, 1258 ], [ 840, 759, 907 ], [ 245, 198, 255 ], [ 154, 121, 162 ], [ 2162, 1902, 2234 ], [ 1165, 1089, 1427 ] ]
        },
        msa337: {
            name: "Wichita Falls, TX",
            data: [ [ 1705, 1324, 1431 ], [ 1377, 1039, 1078 ], [ 106, 109, 99 ], [ 65, 75, 67 ], [ 1775, 1635, 2116 ], [ 1146, 1042, 1426 ] ]
        },
        msa338: {
            name: "Wichita, KS",
            data: [ [ 8013, 6930, 7533 ], [ 5752, 5052, 5558 ], [ 740, 639, 855 ], [ 473, 453, 613 ], [ 16099, 12517, 15030 ], [ 9967, 7487, 9936 ] ]
        },
        msa339: {
            name: "Williamsport, PA",
            data: [ [ 1019, 1048, 1007 ], [ 774, 795, 812 ], [ 201, 189, 309 ], [ 148, 139, 227 ], [ 2056, 1964, 2457 ], [ 1191, 1124, 1597 ] ]
        },
        msa340: {
            name: "Wilmington, NC",
            data: [ [ 3980, 4027, 4687 ], [ 2532, 2383, 2769 ], [ 243, 232, 237 ], [ 127, 133, 149 ], [ 11617, 9883, 12759 ], [ 6519, 5391, 7563 ] ]
        },
        msa341: {
            name: "Winchester, VA-WV",
            data: [ [ 1675, 1475, 1647 ], [ 1192, 1053, 1232 ], [ 120, 101, 129 ], [ 78, 69, 88 ], [ 3316, 2844, 4337 ], [ 1969, 1747, 2923 ] ]
        },
        msa342: {
            name: "Winston-Salem, NC",
            data: [ [ 4847, 4683, 4907 ], [ 3299, 3202, 3229 ], [ 299, 356, 426 ], [ 186, 226, 240 ], [ 12371, 11274, 13052 ], [ 7130, 6383, 7750 ] ]
        },
        msa343: {
            name: "Worcester, MA-CT",
            data: [ [ 8148, 7205, 8471 ], [ 5663, 5106, 5988 ], [ 1135, 1219, 1420 ], [ 786, 821, 1022 ], [ 26828, 21075, 30844 ], [ 17045, 13346, 20518 ] ]
        },
        msa344: {
            name: "Yakima, WA",
            data: [ [ 1929, 1693, 1809 ], [ 1347, 1167, 1248 ], [ 288, 245, 229 ], [ 153, 137, 136 ], [ 5032, 4697, 6194 ], [ 2684, 2509, 3586 ] ]
        },
        msa345: {
            name: "York-Hanover, PA",
            data: [ [ 5105, 4423, 4708 ], [ 3846, 3330, 3582 ], [ 622, 456, 516 ], [ 443, 330, 359 ], [ 13225, 11115, 14429 ], [ 7746, 6313, 8813 ] ]
        },
        msa346: {
            name: "Youngstown-Warren-Boardman, OH-PA",
            data: [ [ 3812, 3601, 3978 ], [ 2821, 2657, 2868 ], [ 711, 655, 701 ], [ 375, 347, 397 ], [ 11835, 9853, 12557 ], [ 6159, 5086, 6803 ] ]
        },
        msa347: {
            name: "Yuba City, CA",
            data: [ [ 2157, 2002, 1842 ], [ 1494, 1386, 1354 ], [ 72, 56, 42 ], [ 29, 26, 17 ], [ 2456, 2112, 4720 ], [ 1279, 1094, 2781 ] ]
        },
        msa348: {
            name: "Yuma, AZ",
            data: [ [ 1834, 1592, 1896 ], [ 1419, 1233, 1418 ], [ 84, 58, 58 ], [ 33, 32, 27 ], [ 2714, 2151, 3835 ], [ 1391, 1094, 2304 ] ]
        }
    };
    var $home_purchase_checkbox = $("#home_purchase_checkbox");
    $home_purchase_checkbox.click(function() {
        var series1 = applicationsOriginationsChart.series[0];
        var series2 = applicationsOriginationsChart.series[1];
        if (series1.visible) {
            series1.hide();
            series2.hide();
            $home_purchase_checkbox.removeAttr("checked");
        } else {
            series1.show();
            series2.show();
            $home_purchase_checkbox.attr("checked");
        }
    });
    var $home_improvements_checkbox = $("#home_improvements_checkbox");
    $home_improvements_checkbox.click(function() {
        var series1 = applicationsOriginationsChart.series[2];
        var series2 = applicationsOriginationsChart.series[3];
        if (series1.visible) {
            series1.hide();
            series2.hide();
            $home_improvements_checkbox.removeAttr("checked");
        } else {
            series1.show();
            series2.show();
            $home_improvements_checkbox.attr("checked");
        }
    });
    var $refinancing_checkbox = $("#refinancing_checkbox");
    $refinancing_checkbox.click(function() {
        var series1 = applicationsOriginationsChart.series[4];
        var series2 = applicationsOriginationsChart.series[5];
        if (series1.visible) {
            series1.hide();
            series2.hide();
            $refinancing_checkbox.removeAttr("checked");
        } else {
            series1.show();
            series2.show();
            $refinancing_checkbox.attr("checked");
        }
    });
    var $msa = $("#hmda_chart_1_msa");
    $msa.change(function() {
        var msaID = $msa.val();
        var msaName = chart1DataObj[msaID].name.replace("&apos;", "’");
        applicationsOriginationsChart.setTitle({
            text: msaName
        });
        for (var i = 0; i < 6; i++) {
            applicationsOriginationsChart.series[i].setData(chart1DataObj[msaID].data[i]);
        }
    });
});

var chart2_options = {
    chart: {
        renderTo: "hmda_chart_2",
        alignTicks: true,
        height: 400,
        plotBackgroundColor: "#FFFFFF",
        plotBorderWidth: null,
        plotShadow: false,
        spacingTop: 20,
        spacingRight: 10,
        spacingBottom: 1,
        spacingLeft: 1,
        marginTop: 100,
        marginBottom: 20,
        type: "column"
    },
    exporting: {
        enabled: false
    },
    title: {
        text: "U.S. Total",
        align: "left",
        verticalAlign: "top",
        floating: false,
        style: {
            color: "#000000",
            fontSize: "18pt",
            fontFamily: '"Avenir Next LT W01 Demi", "Avenir Next Demi", "Avenir Next", "Arial"',
            fontWeight: "600"
        }
    },
    subtitle: {
        text: "Loan Originations by Type, 2010-2012",
        align: "left",
        verticalAlign: "top",
        floating: false,
        y: 40,
        style: {
            color: "#333333",
            fontSize: "12pt",
            fontFamily: '"Avenir Next LT W01 Regular", "Avenir Next", "Arial"',
            fontWeight: "400"
        }
    },
    credits: {
        text: "Data are for first-lien, owner-occupied, 1-4 family and manufactured homes.",
        enabled: false
    },
    colors: [ "#43af2a", "#acdc91", "#0071ce", "#7fb8e6", "#d14123", "#e89f91" ],
    legend: {
        align: "right",
        backgroundColor: "#FFFFFF",
        borderWidth: 0,
        borderRadius: 0,
        borderColor: "#FFFFFF",
        floating: false,
        itemStyle: {
            color: "#212121",
            fontSize: "12pt",
            lineHeight: "12pt",
            fontFamily: '"Avenir Next LT W01 Medium Cn", "Avenir Next Light", "Avenir Next", "Arial Condensed", "Arial"',
            fontWeight: "",
            paddingBottom: "8pt"
        },
        layout: "vertical",
        margin: 10,
        padding: 10,
        shadow: false,
        symbolPadding: 5,
        symbolWidth: 20,
        verticalAlign: "middle",
        x: 0,
        y: 0
    },
    tooltip: {
        backgroundColor: "rgba(0, 0, 0, 0.65)",
        borderColor: "#999999",
        borderRadius: 0,
        borderWidth: 0,
        shadow: false,
        style: {
            color: "#ffffff",
            fontSize: "10pt",
            fontFamily: "",
            fontWeight: "",
            padding: 8,
            lineHeight: "12pt"
        },
        formatter: function() {
            var format = '<span style="font-size: 12pt;>' + this.series.name + " originations in " + this.x + ':<br><span style="font-weight: 700;>' + addCommas(this.y) + "</span></span>";
            return format;
        }
    },
    plotOptions: {
        series: {
            allowPointSelect: true,
            animation: false,
            borderWidth: 0,
            cursor: "pointer",
            marker: {
                radius: 10
            },
            showInLegend: true,
            shadow: false
        },
        pie: {
            dataLabels: {
                enabled: false
            },
            point: {
                events: {
                    legendItemClick: function() {
                        return false;
                    }
                }
            },
            size: "90%"
        },
        column: {
            dataLabels: {
                enabled: false
            },
            grouping: true,
            groupPadding: .1,
            pointPadding: 0,
            stacking: null,
            events: {
                legendItemClick: function() {
                    return false;
                }
            }
        },
        bar: {
            dataLabels: {
                enabled: false
            },
            groupPadding: .1,
            pointPadding: 0,
            stacking: null
        },
        line: {
            lineWidth: 8,
            marker: {
                enabled: false
            }
        },
        area: {
            lineWidth: 8,
            stacking: null,
            marker: {
                enabled: false
            }
        },
        allowPointSelect: false
    },
    xAxis: {
        categories: [ "2010", "2011", "2012" ],
        gridLineWidth: 0,
        labels: {
            style: {
                color: "#212121",
                fontSize: "10pt",
                fontFamily: '"Avenir Next LT W01 Regular", "Avenir Next", "Arial"',
                fontWeight: "400"
            },
            enabled: true,
            y: 20
        },
        lineWidth: 0,
        title: {
            text: null,
            margin: 12,
            style: {
                color: "#101820",
                fontSize: "12pt",
                fontFamily: '"Avenir Next LT W01 Regular", "Avenir Next", "Arial"',
                fontWeight: "400"
            },
            x: -5
        },
        tickLength: 0,
        startOnTick: true,
        endOnTick: true,
        minPadding: 0,
        maxPadding: 0
    },
    yAxis: [ {
        title: {
            text: "Number of originations per year",
            margin: 10,
            style: {
                color: "#101820",
                fontSize: "12pt",
                fontFamily: '"Avenir Next LT W01 Regular", "Avenir Next", "Arial"',
                fontWeight: "400"
            }
        },
        labels: {
            style: {
                color: "#212121",
                fontSize: "10pt",
                fontFamily: '"Avenir Next LT W01 Regular", "Avenir Next", "Arial"',
                fontWeight: "400"
            },
            format: "{value:,.0f}",
            enabled: true
        },
        gridLineWidth: 1
    }, {
        opposite: true,
        title: {
            text: null
        },
        labels: {
            style: {
                color: "#212121",
                fontSize: "10pt",
                fontFamily: '"Avenir Next LT W01 Regular", "Avenir Next", "Arial"',
                fontWeight: "400"
            },
            format: " {value:,.0f} ",
            enabled: true
        },
        gridLineWidth: 0
    } ],
    series: [ {
        name: "Conventional",
        data: [ {
            name: "",
            y: 5672054
        }, {
            name: "",
            y: 5165911
        }, {
            name: "",
            y: 6899675
        } ]
    }, {
        yAxis: 0,
        name: "FHA",
        data: [ {
            name: "",
            y: 1411414
        }, {
            name: "",
            y: 1076844
        }, {
            name: "",
            y: 1188570
        } ]
    }, {
        yAxis: 0,
        name: "VA",
        data: [ {
            name: "",
            y: 230464
        }, {
            name: "",
            y: 291423
        }, {
            name: "",
            y: 425751
        } ]
    }, {
        yAxis: 0,
        name: "RHS",
        data: [ {
            name: "",
            y: 104683
        }, {
            name: "",
            y: 128221
        }, {
            name: "",
            y: 141789
        } ]
    } ]
};

$(document).ready(function() {
    if ($("#hmda_chart_2").length !== 0) {
        var originationsByTypeChart = new Highcharts.Chart(chart2_options);
    }
    if ($("#hmda_chart_2_msa").length !== 0) {
        $("#hmda_chart_2_msa").chosen();
    }
    var chart2DataObj = {
        msa00: {
            name: "U.S. Total",
            data: [ [ 5672054, 5165911, 6899675 ], [ 1411414, 1076844, 1188570 ], [ 230464, 291423, 425751 ], [ 104683, 128221, 141789 ] ]
        },
        msa01: {
            name: "Abilene, TX",
            data: [ [ 3958, 4055, 4503 ], [ 1417, 1108, 1299 ], [ 1149, 1189, 1658 ], [ 74, 97, 65 ] ]
        },
        msa02: {
            name: "Aguadilla-Isabela, PR",
            data: [ [ 1924, 2061, 2846 ], [ 1007, 994, 1026 ], [ 142, 215, 214 ], [ 553, 869, 775 ] ]
        },
        msa03: {
            name: "Akron, OH",
            data: [ [ 29202, 25890, 35282 ], [ 9867, 6754, 8515 ], [ 938, 1067, 1651 ], [ 79, 159, 157 ] ]
        },
        msa04: {
            name: "Albany-Schenectady-Troy, NY",
            data: [ [ 34764, 31350, 41431 ], [ 11169, 8285, 8707 ], [ 1168, 1436, 2093 ], [ 243, 408, 642 ] ]
        },
        msa05: {
            name: "Albany, GA",
            data: [ [ 3287, 3104, 3858 ], [ 1841, 1279, 1344 ], [ 553, 574, 812 ], [ 71, 101, 63 ] ]
        },
        msa06: {
            name: "Albuquerque, NM",
            data: [ [ 35520, 32345, 44664 ], [ 17507, 11905, 14875 ], [ 4765, 5840, 9048 ], [ 205, 169, 234 ] ]
        },
        msa07: {
            name: "Alexandria, LA",
            data: [ [ 5054, 4965, 5592 ], [ 1554, 1246, 1205 ], [ 327, 484, 708 ], [ 610, 629, 585 ] ]
        },
        msa08: {
            name: "Allentown-Bethlehem-Easton, PA-NJ",
            data: [ [ 40623, 34419, 44506 ], [ 13062, 9262, 10593 ], [ 1103, 1399, 2052 ], [ 265, 644, 727 ] ]
        },
        msa09: {
            name: "Altoona, PA",
            data: [ [ 4468, 4325, 5768 ], [ 1242, 1084, 1053 ], [ 198, 232, 347 ], [ 50, 107, 117 ] ]
        },
        msa10: {
            name: "Amarillo, TX",
            data: [ [ 7362, 6919, 9391 ], [ 3695, 3048, 3173 ], [ 601, 808, 1065 ], [ 48, 52, 102 ] ]
        },
        msa11: {
            name: "Ames, IA",
            data: [ [ 4997, 4501, 5910 ], [ 843, 598, 514 ], [ 117, 149, 213 ], [ 105, 163, 177 ] ]
        },
        msa12: {
            name: "Anchorage, AK",
            data: [ [ 19248, 16215, 21879 ], [ 7211, 5365, 6341 ], [ 4904, 5594, 7683 ], [ 334, 406, 324 ] ]
        },
        msa13: {
            name: "Ann Arbor, MI",
            data: [ [ 18345, 17705, 27025 ], [ 3042, 2644, 2747 ], [ 231, 426, 612 ], [ 202, 388, 371 ] ]
        },
        msa14: {
            name: "Anniston-Oxford-Jacksonville, AL",
            data: [ [ 3149, 3015, 3831 ], [ 1612, 1188, 1096 ], [ 389, 506, 638 ], [ 78, 109, 144 ] ]
        },
        msa15: {
            name: "Appleton, WI",
            data: [ [ 21008, 17759, 23329 ], [ 3155, 1913, 2676 ], [ 435, 547, 841 ], [ 158, 166, 171 ] ]
        },
        msa16: {
            name: "Asheville, NC",
            data: [ [ 21169, 20036, 24786 ], [ 3542, 2444, 2507 ], [ 653, 862, 1524 ], [ 638, 830, 1076 ] ]
        },
        msa17: {
            name: "Athens-Clarke County, GA",
            data: [ [ 6115, 6149, 8151 ], [ 2154, 1546, 1633 ], [ 217, 254, 360 ], [ 82, 124, 122 ] ]
        },
        msa18: {
            name: "Atlanta-Sandy Springs-Roswell, GA",
            data: [ [ 191636, 196566, 288629 ], [ 95962, 72841, 88422 ], [ 14175, 16373, 23939 ], [ 2192, 2999, 2960 ] ]
        },
        msa19: {
            name: "Atlantic City-Hammonton, NJ",
            data: [ [ 11824, 9484, 11830 ], [ 4060, 2830, 2993 ], [ 379, 464, 648 ], [ 259, 445, 511 ] ]
        },
        msa20: {
            name: "Auburn-Opelika, AL",
            data: [ [ 4750, 4502, 6621 ], [ 2113, 1562, 1727 ], [ 940, 1271, 1481 ], [ 92, 97, 154 ] ]
        },
        msa21: {
            name: "Augusta-Richmond County, GA-SC",
            data: [ [ 16508, 15484, 18192 ], [ 8097, 5818, 6046 ], [ 5106, 5924, 8087 ], [ 313, 381, 522 ] ]
        },
        msa22: {
            name: "Austin-Round Rock, TX",
            data: [ [ 87281, 82816, 110450 ], [ 21883, 17434, 21796 ], [ 5271, 6143, 9780 ], [ 2503, 2481, 2749 ] ]
        },
        msa23: {
            name: "Bakersfield, CA",
            data: [ [ 14099, 12549, 25340 ], [ 14641, 11601, 13522 ], [ 1980, 2249, 3275 ], [ 374, 451, 530 ] ]
        },
        msa24: {
            name: "Baltimore-Columbia-Towson, MD",
            data: [ [ 142301, 123798, 160876 ], [ 49965, 34100, 41522 ], [ 9664, 12075, 19845 ], [ 254, 596, 794 ] ]
        },
        msa25: {
            name: "Bangor, ME",
            data: [ [ 5336, 4851, 6089 ], [ 1592, 1161, 1144 ], [ 366, 400, 537 ], [ 379, 267, 319 ] ]
        },
        msa26: {
            name: "Barnstable Town, MA",
            data: [ [ 15832, 13576, 18815 ], [ 1879, 1215, 1390 ], [ 280, 400, 743 ], [ 136, 167, 256 ] ]
        },
        msa27: {
            name: "Baton Rouge, LA",
            data: [ [ 32785, 30035, 40224 ], [ 12361, 9101, 11241 ], [ 1214, 1778, 2591 ], [ 3170, 3180, 4171 ] ]
        },
        msa28: {
            name: "Battle Creek, MI",
            data: [ [ 4444, 4383, 5875 ], [ 1180, 958, 1217 ], [ 169, 327, 341 ], [ 185, 164, 211 ] ]
        },
        msa29: {
            name: "Bay City, MI",
            data: [ [ 3798, 3964, 5947 ], [ 1144, 873, 1062 ], [ 122, 179, 207 ], [ 94, 133, 144 ] ]
        },
        msa30: {
            name: "Beaumont-Port Arthur, TX",
            data: [ [ 9517, 9325, 10093 ], [ 2703, 2575, 2965 ], [ 473, 595, 703 ], [ 187, 230, 287 ] ]
        },
        msa31: {
            name: "Bellingham, WA",
            data: [ [ 13850, 11135, 15499 ], [ 2465, 1370, 1889 ], [ 567, 768, 1117 ], [ 239, 449, 440 ] ]
        },
        msa32: {
            name: "Bend-Redmond, OR",
            data: [ [ 8037, 7468, 13135 ], [ 2254, 1468, 1766 ], [ 509, 644, 1034 ], [ 410, 356, 377 ] ]
        },
        msa33: {
            name: "Billings, MT",
            data: [ [ 9073, 7748, 10435 ], [ 3332, 2123, 2218 ], [ 732, 783, 1115 ], [ 180, 259, 296 ] ]
        },
        msa34: {
            name: "Binghamton, NY",
            data: [ [ 5904, 5405, 7339 ], [ 2260, 2092, 1960 ], [ 274, 317, 408 ], [ 169, 179, 201 ] ]
        },
        msa35: {
            name: "Birmingham-Hoover, AL",
            data: [ [ 45200, 38857, 54750 ], [ 20456, 15056, 17003 ], [ 2407, 2870, 3956 ], [ 1453, 1525, 1948 ] ]
        },
        msa36: {
            name: "Bismarck, ND",
            data: [ [ 7728, 6337, 9884 ], [ 2201, 1517, 1211 ], [ 363, 529, 707 ], [ 112, 152, 124 ] ]
        },
        msa37: {
            name: "Blacksburg-Christiansburg-Radford, VA",
            data: [ [ 5889, 5114, 6357 ], [ 1404, 1033, 1094 ], [ 218, 352, 419 ], [ 460, 449, 514 ] ]
        },
        msa38: {
            name: "Bloomington, IN",
            data: [ [ 8761, 8271, 10660 ], [ 1960, 1340, 1525 ], [ 270, 425, 614 ], [ 351, 355, 369 ] ]
        },
        msa39: {
            name: "Boise City, ID",
            data: [ [ 26689, 22482, 43765 ], [ 13218, 8979, 10083 ], [ 2736, 3098, 4884 ], [ 339, 557, 497 ] ]
        },
        msa40: {
            name: "Boulder, CO",
            data: [ [ 28255, 24130, 34980 ], [ 3808, 2219, 2858 ], [ 367, 542, 932 ], [ 1, 3, 8 ] ]
        },
        msa41: {
            name: "Bowling Green, KY",
            data: [ [ 5227, 5375, 6120 ], [ 1636, 1232, 1229 ], [ 186, 271, 368 ], [ 84, 173, 254 ] ]
        },
        msa42: {
            name: "Bremerton-Silverdale, WA",
            data: [ [ 14128, 11802, 15984 ], [ 3152, 1959, 2542 ], [ 3416, 3917, 5862 ], [ 386, 535, 601 ] ]
        },
        msa43: {
            name: "Bridgeport-Stamford-Norwalk, CT",
            data: [ [ 62432, 55189, 69498 ], [ 8387, 5980, 6373 ], [ 357, 493, 757 ], [ 14, 11, 32 ] ]
        },
        msa44: {
            name: "Brownsville-Harlingen, TX",
            data: [ [ 4693, 5392, 5703 ], [ 2301, 2139, 2525 ], [ 389, 453, 596 ], [ 59, 32, 6 ] ]
        },
        msa45: {
            name: "Brunswick, GA",
            data: [ [ 3501, 3257, 4053 ], [ 1070, 881, 864 ], [ 368, 460, 605 ], [ 40, 78, 109 ] ]
        },
        msa46: {
            name: "Buffalo-Cheektowaga-Niagara Falls, NY",
            data: [ [ 25189, 23723, 29468 ], [ 13768, 12520, 12603 ], [ 1626, 1969, 2438 ], [ 155, 176, 171 ] ]
        },
        msa47: {
            name: "Burlington-South Burlington, VT",
            data: [ [ 16853, 14427, 19634 ], [ 1500, 932, 987 ], [ 348, 463, 765 ], [ 254, 397, 598 ] ]
        },
        msa48: {
            name: "Burlington, NC",
            data: [ [ 5403, 5372, 6507 ], [ 1964, 1509, 1628 ], [ 338, 402, 525 ], [ 178, 222, 282 ] ]
        },
        msa49: {
            name: "Canton-Massillon, OH",
            data: [ [ 14504, 12894, 17389 ], [ 5600, 4021, 4920 ], [ 496, 668, 1037 ], [ 79, 199, 224 ] ]
        },
        msa50: {
            name: "Cape Coral-Fort Myers, FL",
            data: [ [ 14544, 14719, 27665 ], [ 7231, 5161, 5377 ], [ 950, 1232, 1870 ], [ 553, 428, 376 ] ]
        },
        msa51: {
            name: "Cape Girardeau, MO-IL",
            data: [ [ 4168, 3912, 5109 ], [ 1094, 744, 642 ], [ 182, 181, 278 ], [ 262, 298, 290 ] ]
        },
        msa52: {
            name: "Carson City, NV",
            data: [ [ 1646, 1306, 2538 ], [ 612, 481, 627 ], [ 99, 140, 235 ], [ 1, 3, 2 ] ]
        },
        msa53: {
            name: "Casper, WY",
            data: [ [ 3761, 3227, 4673 ], [ 1756, 1460, 1615 ], [ 263, 341, 444 ], [ 77, 165, 231 ] ]
        },
        msa54: {
            name: "Cedar Rapids, IA",
            data: [ [ 21137, 18016, 19712 ], [ 4539, 2458, 2509 ], [ 579, 663, 1009 ], [ 208, 297, 343 ] ]
        },
        msa55: {
            name: "Champaign-Urbana, IL",
            data: [ [ 13432, 10934, 14129 ], [ 1951, 1440, 1296 ], [ 340, 419, 676 ], [ 287, 414, 587 ] ]
        },
        msa56: {
            name: "Charleston-North Charleston, SC",
            data: [ [ 28475, 26553, 37329 ], [ 10889, 7957, 8678 ], [ 5036, 5892, 8616 ], [ 390, 400, 495 ] ]
        },
        msa57: {
            name: "Charleston, WV",
            data: [ [ 11197, 11624, 12935 ], [ 3017, 2467, 2282 ], [ 439, 632, 806 ], [ 306, 340, 372 ] ]
        },
        msa58: {
            name: "Charlotte-Concord-Gastonia, NC-SC",
            data: [ [ 89509, 83859, 113284 ], [ 30959, 22439, 26233 ], [ 4564, 5405, 8215 ], [ 1591, 1909, 2614 ] ]
        },
        msa59: {
            name: "Charlottesville, VA",
            data: [ [ 11077, 9814, 12906 ], [ 2277, 1391, 1604 ], [ 675, 738, 1194 ], [ 121, 246, 320 ] ]
        },
        msa60: {
            name: "Chattanooga, TN-GA",
            data: [ [ 17864, 17154, 23546 ], [ 8888, 6397, 7188 ], [ 932, 1296, 1853 ], [ 536, 805, 896 ] ]
        },
        msa61: {
            name: "Cheyenne, WY",
            data: [ [ 4657, 4192, 5936 ], [ 2043, 1576, 1560 ], [ 1259, 1427, 2117 ], [ 7, 23, 43 ] ]
        },
        msa62: {
            name: "Chico, CA",
            data: [ [ 8380, 7001, 10637 ], [ 2226, 1895, 2194 ], [ 343, 395, 662 ], [ 63, 53, 70 ] ]
        },
        msa63: {
            name: "Cincinnati, OH-KY-IN",
            data: [ [ 142834, 119966, 162038 ], [ 33991, 24036, 29981 ], [ 3914, 4905, 7441 ], [ 1129, 1830, 2475 ] ]
        },
        msa64: {
            name: "Clarksville, TN-KY",
            data: [ [ 6477, 6117, 7688 ], [ 3214, 2321, 2526 ], [ 6520, 9430, 11256 ], [ 129, 146, 245 ] ]
        },
        msa65: {
            name: "Cleveland-Elyria, OH",
            data: [ [ 81411, 75232, 103299 ], [ 25234, 18238, 23854 ], [ 2425, 3077, 4716 ], [ 238, 323, 393 ] ]
        },
        msa66: {
            name: "Cleveland, TN",
            data: [ [ 4005, 3816, 4991 ], [ 1991, 1452, 1569 ], [ 146, 240, 324 ], [ 140, 203, 228 ] ]
        },
        msa67: {
            name: "Coeur d&apos;Alene, ID",
            data: [ [ 8105, 6250, 8533 ], [ 2396, 1667, 1731 ], [ 624, 815, 1105 ], [ 409, 516, 526 ] ]
        },
        msa68: {
            name: "College Station-Bryan, TX",
            data: [ [ 6137, 5674, 6755 ], [ 2122, 1613, 1684 ], [ 331, 383, 591 ], [ 40, 64, 106 ] ]
        },
        msa69: {
            name: "Colorado Springs, CO",
            data: [ [ 33661, 28574, 39185 ], [ 10853, 7593, 9313 ], [ 13841, 16790, 25366 ], [ 45, 66, 101 ] ]
        },
        msa70: {
            name: "Columbia, MO",
            data: [ [ 9770, 8264, 11571 ], [ 2248, 1431, 1818 ], [ 461, 480, 837 ], [ 307, 393, 429 ] ]
        },
        msa71: {
            name: "Columbia, SC",
            data: [ [ 27995, 25645, 34836 ], [ 12169, 8308, 8951 ], [ 4805, 5404, 7414 ], [ 832, 979, 1168 ] ]
        },
        msa72: {
            name: "Columbus, GA-AL",
            data: [ [ 5979, 5711, 7571 ], [ 3951, 2680, 2909 ], [ 3652, 4324, 5542 ], [ 74, 98, 140 ] ]
        },
        msa73: {
            name: "Columbus, IN",
            data: [ [ 5023, 4474, 5798 ], [ 1031, 869, 1073 ], [ 168, 207, 264 ], [ 39, 144, 89 ] ]
        },
        msa74: {
            name: "Columbus, OH",
            data: [ [ 100991, 88604, 120640 ], [ 33332, 22689, 30383 ], [ 4131, 4998, 7279 ], [ 624, 962, 1161 ] ]
        },
        msa75: {
            name: "Corpus Christi, TX",
            data: [ [ 9577, 9949, 11299 ], [ 3988, 3231, 3448 ], [ 1537, 1683, 2414 ], [ 93, 75, 75 ] ]
        },
        msa76: {
            name: "Corvallis, OR",
            data: [ [ 4664, 3911, 5330 ], [ 675, 438, 464 ], [ 128, 173, 288 ], [ 24, 43, 49 ] ]
        },
        msa77: {
            name: "Crestview-Fort Walton Beach-Destin, FL",
            data: [ [ 5465, 5150, 7506 ], [ 1385, 1023, 1062 ], [ 3373, 4602, 6442 ], [ 240, 349, 393 ] ]
        },
        msa78: {
            name: "Cumberland, MD-WV",
            data: [ [ 2993, 2570, 3161 ], [ 806, 589, 624 ], [ 123, 170, 244 ], [ 83, 98, 292 ] ]
        },
        msa79: {
            name: "Dalton, GA",
            data: [ [ 2737, 2900, 3925 ], [ 1856, 1267, 1362 ], [ 135, 93, 124 ], [ 195, 200, 175 ] ]
        },
        msa80: {
            name: "Danville, IL",
            data: [ [ 2227, 2047, 2378 ], [ 483, 468, 380 ], [ 136, 129, 148 ], [ 50, 89, 176 ] ]
        },
        msa81: {
            name: "Davenport-Moline-Rock Island, IA-IL",
            data: [ [ 24237, 19069, 26619 ], [ 6073, 4091, 3968 ], [ 942, 1231, 1692 ], [ 192, 395, 440 ] ]
        },
        msa82: {
            name: "Dayton, OH",
            data: [ [ 38276, 34447, 45736 ], [ 11399, 8240, 10149 ], [ 3491, 4039, 5965 ], [ 168, 384, 575 ] ]
        },
        msa83: {
            name: "Decatur, AL",
            data: [ [ 5683, 5555, 6741 ], [ 2682, 1945, 2063 ], [ 379, 521, 738 ], [ 91, 141, 224 ] ]
        },
        msa84: {
            name: "Decatur, IL",
            data: [ [ 4419, 3597, 5557 ], [ 1243, 1067, 1132 ], [ 209, 237, 288 ], [ 37, 75, 93 ] ]
        },
        msa85: {
            name: "Deltona-Daytona Beach-Ormond Beach, FL",
            data: [ [ 10065, 10030, 19774 ], [ 5624, 4210, 4641 ], [ 1082, 1282, 2035 ], [ 303, 320, 261 ] ]
        },
        msa86: {
            name: "Denver-Aurora-Lakewood, CO",
            data: [ [ 177353, 152983, 223960 ], [ 62322, 42310, 57805 ], [ 9098, 12433, 19169 ], [ 115, 153, 209 ] ]
        },
        msa87: {
            name: "Des Moines-West Des Moines, IA",
            data: [ [ 37523, 35329, 48372 ], [ 13062, 9132, 9614 ], [ 1212, 1674, 2378 ], [ 262, 347, 420 ] ]
        },
        msa88: {
            name: "Dothan, AL",
            data: [ [ 4537, 4390, 5417 ], [ 2034, 1504, 1477 ], [ 785, 826, 1210 ], [ 135, 167, 227 ] ]
        },
        msa89: {
            name: "Dover, DE",
            data: [ [ 5503, 4918, 6740 ], [ 2921, 1870, 2007 ], [ 1490, 1664, 2723 ], [ 246, 420, 701 ] ]
        },
        msa90: {
            name: "Dubuque, IA",
            data: [ [ 8855, 7434, 9987 ], [ 1404, 769, 736 ], [ 177, 186, 249 ], [ 54, 56, 101 ] ]
        },
        msa91: {
            name: "Duluth, MN-WI",
            data: [ [ 14638, 12626, 16078 ], [ 3325, 2224, 2450 ], [ 544, 666, 998 ], [ 130, 182, 221 ] ]
        },
        msa92: {
            name: "Durham-Chapel Hill, NC",
            data: [ [ 25999, 24637, 29403 ], [ 6092, 4445, 4586 ], [ 991, 1274, 1760 ], [ 171, 247, 317 ] ]
        },
        msa93: {
            name: "Eau Claire, WI",
            data: [ [ 11828, 9905, 13171 ], [ 1485, 930, 1024 ], [ 268, 332, 428 ], [ 176, 138, 184 ] ]
        },
        msa94: {
            name: "El Centro, CA",
            data: [ [ 1463, 1620, 3028 ], [ 2403, 1815, 2101 ], [ 401, 401, 621 ], [ 317, 505, 539 ] ]
        },
        msa95: {
            name: "El Paso, TX",
            data: [ [ 15189, 14715, 17094 ], [ 8711, 7504, 8992 ], [ 4595, 5755, 6730 ], [ 338, 304, 419 ] ]
        },
        msa96: {
            name: "Elizabethtown-Fort Knox, KY",
            data: [ [ 4757, 4159, 5004 ], [ 1590, 1090, 1053 ], [ 2336, 2014, 3158 ], [ 99, 211, 333 ] ]
        },
        msa97: {
            name: "Elkhart-Goshen, IN",
            data: [ [ 7900, 7499, 9800 ], [ 2742, 2122, 2273 ], [ 209, 236, 347 ], [ 114, 276, 302 ] ]
        },
        msa98: {
            name: "Elmira, NY",
            data: [ [ 2876, 2676, 3162 ], [ 738, 705, 628 ], [ 117, 153, 174 ], [ 62, 69, 75 ] ]
        },
        msa99: {
            name: "Erie, PA",
            data: [ [ 10239, 9462, 12064 ], [ 2727, 2311, 2351 ], [ 469, 500, 736 ], [ 57, 68, 51 ] ]
        },
        msa100: {
            name: "Eugene, OR",
            data: [ [ 17430, 13893, 19333 ], [ 4880, 3278, 3867 ], [ 1085, 1396, 1968 ], [ 248, 355, 456 ] ]
        },
        msa101: {
            name: "Evansville, IN-KY",
            data: [ [ 18907, 17273, 21336 ], [ 5168, 3591, 3327 ], [ 654, 749, 954 ], [ 647, 699, 574 ] ]
        },
        msa102: {
            name: "Fairbanks, AK",
            data: [ [ 3218, 2985, 4254 ], [ 1102, 854, 882 ], [ 1256, 1462, 1984 ], [ 65, 88, 75 ] ]
        },
        msa103: {
            name: "Fargo, ND-MN",
            data: [ [ 11386, 10573, 14233 ], [ 4086, 2753, 3223 ], [ 614, 712, 1146 ], [ 67, 85, 122 ] ]
        },
        msa104: {
            name: "Farmington, NM",
            data: [ [ 2414, 2735, 3386 ], [ 1599, 1083, 1409 ], [ 306, 336, 513 ], [ 151, 114, 159 ] ]
        },
        msa105: {
            name: "Fayetteville-Springdale-Rogers, AR-MO",
            data: [ [ 19476, 17288, 26302 ], [ 8165, 6080, 7264 ], [ 1272, 1407, 2200 ], [ 1197, 1388, 1773 ] ]
        },
        msa106: {
            name: "Fayetteville, NC",
            data: [ [ 7355, 7312, 8008 ], [ 3893, 2762, 2444 ], [ 11365, 12208, 14314 ], [ 342, 400, 421 ] ]
        },
        msa107: {
            name: "Flagstaff, AZ",
            data: [ [ 4786, 4168, 5814 ], [ 1304, 944, 1113 ], [ 224, 282, 445 ], [ 31, 47, 95 ] ]
        },
        msa108: {
            name: "Flint, MI",
            data: [ [ 9913, 9582, 17774 ], [ 3983, 3409, 4440 ], [ 322, 596, 702 ], [ 927, 917, 1250 ] ]
        },
        msa109: {
            name: "Florence-Muscle Shoals, AL",
            data: [ [ 5708, 5583, 6862 ], [ 1751, 1257, 1317 ], [ 277, 337, 430 ], [ 118, 200, 211 ] ]
        },
        msa110: {
            name: "Florence, SC",
            data: [ [ 5282, 5401, 6572 ], [ 2360, 1713, 1651 ], [ 412, 463, 527 ], [ 188, 125, 221 ] ]
        },
        msa111: {
            name: "Fond du Lac, WI",
            data: [ [ 8690, 6895, 9810 ], [ 1039, 686, 758 ], [ 202, 197, 323 ], [ 67, 65, 82 ] ]
        },
        msa112: {
            name: "Fort Collins, CO",
            data: [ [ 22627, 19560, 28615 ], [ 5654, 3835, 4648 ], [ 921, 1265, 2022 ], [ 118, 161, 245 ] ]
        },
        msa113: {
            name: "Fort Smith, AR-OK",
            data: [ [ 8681, 7943, 9535 ], [ 3773, 2935, 2936 ], [ 753, 933, 1217 ], [ 892, 955, 880 ] ]
        },
        msa114: {
            name: "Fort Wayne, IN",
            data: [ [ 21390, 18703, 25404 ], [ 7975, 6306, 7619 ], [ 932, 1175, 1532 ], [ 388, 625, 646 ] ]
        },
        msa115: {
            name: "Fresno, CA",
            data: [ [ 20771, 18449, 31865 ], [ 12958, 11134, 12125 ], [ 1182, 1610, 2366 ], [ 499, 584, 586 ] ]
        },
        msa116: {
            name: "Gadsden, AL",
            data: [ [ 2847, 2690, 3551 ], [ 1360, 980, 954 ], [ 215, 196, 279 ], [ 74, 141, 169 ] ]
        },
        msa117: {
            name: "Gainesville, FL",
            data: [ [ 7633, 6699, 9187 ], [ 2337, 1619, 1946 ], [ 436, 618, 793 ], [ 124, 179, 246 ] ]
        },
        msa118: {
            name: "Gainesville, GA",
            data: [ [ 5384, 5797, 7833 ], [ 2413, 2006, 2045 ], [ 305, 365, 562 ], [ 58, 161, 84 ] ]
        },
        msa119: {
            name: "Glens Falls, NY",
            data: [ [ 3668, 3586, 4463 ], [ 1404, 1021, 1093 ], [ 191, 231, 289 ], [ 172, 189, 226 ] ]
        },
        msa120: {
            name: "Goldsboro, NC",
            data: [ [ 2571, 2725, 3209 ], [ 962, 744, 838 ], [ 1449, 1490, 1899 ], [ 88, 90, 176 ] ]
        },
        msa121: {
            name: "Grand Forks, ND-MN",
            data: [ [ 3909, 3632, 5291 ], [ 1361, 948, 908 ], [ 310, 411, 549 ], [ 51, 76, 53 ] ]
        },
        msa122: {
            name: "Grand Junction, CO",
            data: [ [ 8095, 5653, 8456 ], [ 3992, 2692, 4296 ], [ 617, 829, 1285 ], [ 198, 228, 325 ] ]
        },
        msa123: {
            name: "Grand Rapids-Wyoming, MI",
            data: [ [ 39745, 35374, 50015 ], [ 9266, 7475, 9615 ], [ 614, 1105, 1463 ], [ 932, 1216, 1331 ] ]
        },
        msa124: {
            name: "Great Falls, MT",
            data: [ [ 3951, 3463, 4968 ], [ 1557, 1124, 1182 ], [ 929, 1032, 1557 ], [ 26, 34, 47 ] ]
        },
        msa125: {
            name: "Greeley, CO",
            data: [ [ 12710, 11153, 16843 ], [ 6486, 4861, 6266 ], [ 995, 1315, 2166 ], [ 294, 604, 855 ] ]
        },
        msa126: {
            name: "Green Bay, WI",
            data: [ [ 29089, 21381, 29229 ], [ 5672, 3151, 3692 ], [ 638, 710, 1095 ], [ 124, 222, 228 ] ]
        },
        msa127: {
            name: "Greensboro-High Point, NC",
            data: [ [ 27618, 26193, 31704 ], [ 9856, 7841, 8095 ], [ 1619, 2054, 2553 ], [ 700, 978, 1100 ] ]
        },
        msa128: {
            name: "Greenville-Anderson-Mauldin, SC",
            data: [ [ 25149, 25291, 33254 ], [ 9293, 6614, 7323 ], [ 1327, 1879, 2613 ], [ 892, 1148, 1444 ] ]
        },
        msa129: {
            name: "Greenville, NC",
            data: [ [ 5813, 5687, 6804 ], [ 2196, 1506, 1427 ], [ 546, 629, 748 ], [ 295, 261, 365 ] ]
        },
        msa130: {
            name: "Guayama, PR",
            data: [ [ 514, 499, 534 ], [ 590, 518, 638 ], [ 29, 63, 62 ], [ 210, 234, 257 ] ]
        },
        msa131: {
            name: "Gulfport-Biloxi-Pascagoula, MS",
            data: [ [ 6883, 5805, 6672 ], [ 2513, 1952, 1713 ], [ 1346, 1385, 2094 ], [ 248, 314, 419 ] ]
        },
        msa132: {
            name: "Hagerstown-Martinsburg, MD-WV",
            data: [ [ 9780, 8342, 11538 ], [ 4073, 2625, 2970 ], [ 1164, 1448, 2076 ], [ 1021, 1439, 1774 ] ]
        },
        msa133: {
            name: "Hanford-Corcoran, CA",
            data: [ [ 2084, 1873, 3323 ], [ 1501, 1202, 1496 ], [ 808, 756, 1173 ], [ 186, 191, 257 ] ]
        },
        msa134: {
            name: "Harrisburg-Carlisle, PA",
            data: [ [ 28486, 25105, 31223 ], [ 8756, 6231, 6639 ], [ 1645, 2023, 2942 ], [ 228, 395, 431 ] ]
        },
        msa135: {
            name: "Harrisonburg, VA",
            data: [ [ 5058, 4453, 5612 ], [ 1130, 675, 836 ], [ 174, 195, 324 ], [ 104, 160, 199 ] ]
        },
        msa136: {
            name: "Hartford-West Hartford-East Hartford, CT",
            data: [ [ 65453, 55444, 74605 ], [ 18024, 12539, 15422 ], [ 1151, 1607, 2394 ], [ 103, 236, 404 ] ]
        },
        msa137: {
            name: "Hattiesburg, MS",
            data: [ [ 5010, 4310, 5294 ], [ 1729, 1200, 1229 ], [ 336, 357, 557 ], [ 350, 292, 328 ] ]
        },
        msa138: {
            name: "Hickory-Lenoir-Morganton, NC",
            data: [ [ 11940, 11890, 14237 ], [ 3424, 2548, 2473 ], [ 514, 683, 990 ], [ 807, 970, 1099 ] ]
        },
        msa139: {
            name: "Hinesville, GA",
            data: [ [ 945, 859, 959 ], [ 653, 520, 449 ], [ 1485, 2266, 2508 ], [ 37, 34, 49 ] ]
        },
        msa140: {
            name: "Hot Springs, AR",
            data: [ [ 4178, 3657, 5010 ], [ 1351, 904, 1001 ], [ 283, 292, 478 ], [ 182, 273, 322 ] ]
        },
        msa141: {
            name: "Houma-Thibodaux, LA",
            data: [ [ 8257, 8181, 9267 ], [ 2801, 1902, 2219 ], [ 178, 276, 485 ], [ 497, 480, 705 ] ]
        },
        msa142: {
            name: "Houston-The Woodlands-Sugar Land, TX",
            data: [ [ 185218, 192856, 237881 ], [ 70534, 58748, 69199 ], [ 9622, 11551, 17785 ], [ 970, 1500, 1822 ] ]
        },
        msa143: {
            name: "Huntington-Ashland, WV-KY-OH",
            data: [ [ 10664, 10585, 11682 ], [ 2872, 2180, 1857 ], [ 471, 554, 655 ], [ 249, 353, 358 ] ]
        },
        msa144: {
            name: "Huntsville, AL",
            data: [ [ 23646, 21368, 26956 ], [ 8466, 5528, 6008 ], [ 3771, 4313, 6532 ], [ 1045, 1312, 1433 ] ]
        },
        msa145: {
            name: "Idaho Falls, ID",
            data: [ [ 5753, 4625, 6586 ], [ 2868, 1945, 2039 ], [ 368, 365, 610 ], [ 240, 235, 252 ] ]
        },
        msa146: {
            name: "Indianapolis-Carmel-Anderson, IN",
            data: [ [ 103845, 90905, 119643 ], [ 39419, 30513, 36490 ], [ 5615, 6385, 9240 ], [ 1104, 1754, 1714 ] ]
        },
        msa147: {
            name: "Iowa City, IA",
            data: [ [ 11561, 9674, 12264 ], [ 976, 555, 515 ], [ 194, 253, 334 ], [ 170, 216, 316 ] ]
        },
        msa148: {
            name: "Ithaca, NY",
            data: [ [ 3085, 2735, 3339 ], [ 450, 323, 349 ], [ 64, 63, 80 ], [ 19, 15, 53 ] ]
        },
        msa149: {
            name: "Jackson, MI",
            data: [ [ 5041, 4689, 7866 ], [ 1463, 1055, 1479 ], [ 140, 279, 351 ], [ 221, 250, 305 ] ]
        },
        msa150: {
            name: "Jackson, MS",
            data: [ [ 17713, 14621, 19324 ], [ 6890, 5376, 5805 ], [ 916, 966, 1582 ], [ 699, 724, 821 ] ]
        },
        msa151: {
            name: "Jackson, TN",
            data: [ [ 3398, 2962, 4077 ], [ 1790, 1291, 1397 ], [ 216, 340, 399 ], [ 214, 273, 254 ] ]
        },
        msa152: {
            name: "Jacksonville, FL",
            data: [ [ 41759, 36672, 59787 ], [ 20087, 14339, 15799 ], [ 9131, 10559, 15133 ], [ 706, 1194, 1331 ] ]
        },
        msa153: {
            name: "Jacksonville, NC",
            data: [ [ 3406, 3063, 3500 ], [ 1413, 893, 801 ], [ 8561, 8168, 10125 ], [ 152, 168, 243 ] ]
        },
        msa154: {
            name: "Janesville-Beloit, WI",
            data: [ [ 9690, 8295, 11104 ], [ 1804, 1265, 1481 ], [ 246, 317, 440 ], [ 78, 96, 116 ] ]
        },
        msa155: {
            name: "Jefferson City, MO",
            data: [ [ 8451, 7207, 9888 ], [ 1206, 916, 909 ], [ 292, 346, 538 ], [ 421, 435, 438 ] ]
        },
        msa156: {
            name: "Johnson City, TN",
            data: [ [ 7360, 7029, 8804 ], [ 2228, 1551, 1664 ], [ 460, 729, 916 ], [ 176, 276, 391 ] ]
        },
        msa157: {
            name: "Johnstown, PA",
            data: [ [ 5023, 4653, 5888 ], [ 1165, 988, 815 ], [ 220, 244, 337 ], [ 69, 122, 111 ] ]
        },
        msa158: {
            name: "Jonesboro, AR",
            data: [ [ 3917, 4045, 5156 ], [ 1794, 1368, 1439 ], [ 244, 289, 361 ], [ 351, 301, 315 ] ]
        },
        msa159: {
            name: "Joplin, MO",
            data: [ [ 6374, 6062, 7522 ], [ 2454, 1924, 1504 ], [ 382, 472, 580 ], [ 420, 495, 1022 ] ]
        },
        msa160: {
            name: "Kalamazoo-Portage, MI",
            data: [ [ 13790, 12622, 18678 ], [ 3367, 2905, 3786 ], [ 406, 614, 838 ], [ 463, 598, 731 ] ]
        },
        msa161: {
            name: "Kankakee, IL",
            data: [ [ 5055, 3869, 5544 ], [ 1038, 952, 969 ], [ 173, 222, 257 ], [ 64, 82, 86 ] ]
        },
        msa162: {
            name: "Kansas City, MO-KS",
            data: [ [ 105929, 90172, 122553 ], [ 40978, 29609, 36382 ], [ 6225, 7499, 10762 ], [ 1351, 1907, 2104 ] ]
        },
        msa163: {
            name: "Kennewick-Richland, WA",
            data: [ [ 13504, 12781, 15814 ], [ 6743, 4401, 4402 ], [ 1389, 1513, 2023 ], [ 161, 495, 423 ] ]
        },
        msa164: {
            name: "Killeen-Temple, TX",
            data: [ [ 6657, 6920, 7820 ], [ 3090, 2826, 2833 ], [ 10548, 9228, 12576 ], [ 140, 199, 290 ] ]
        },
        msa165: {
            name: "Kingsport-Bristol-Bristol, TN-VA",
            data: [ [ 10759, 10407, 12902 ], [ 3235, 2299, 2527 ], [ 526, 654, 927 ], [ 254, 292, 289 ] ]
        },
        msa166: {
            name: "Kingston, NY",
            data: [ [ 5342, 4620, 5714 ], [ 1219, 1130, 910 ], [ 138, 193, 236 ], [ 75, 71, 112 ] ]
        },
        msa167: {
            name: "Knoxville, TN",
            data: [ [ 33478, 29774, 39405 ], [ 11851, 8110, 8978 ], [ 1823, 2428, 3725 ], [ 669, 862, 1247 ] ]
        },
        msa168: {
            name: "Kokomo, IN",
            data: [ [ 3528, 3258, 5555 ], [ 1289, 983, 1183 ], [ 186, 210, 349 ], [ 137, 159, 125 ] ]
        },
        msa169: {
            name: "La Crosse-Onalaska, WI-MN",
            data: [ [ 10944, 9680, 12557 ], [ 1017, 661, 764 ], [ 208, 287, 431 ], [ 82, 114, 133 ] ]
        },
        msa170: {
            name: "Lafayette, LA",
            data: [ [ 11302, 10192, 12885 ], [ 3352, 2503, 2816 ], [ 448, 689, 1048 ], [ 1323, 1074, 1215 ] ]
        },
        msa171: {
            name: "Lake Charles, LA",
            data: [ [ 6533, 6451, 7481 ], [ 2331, 1737, 2018 ], [ 266, 414, 563 ], [ 377, 375, 480 ] ]
        },
        msa172: {
            name: "Lake Havasu City-Kingman, AZ",
            data: [ [ 5046, 4588, 7926 ], [ 2111, 1483, 1568 ], [ 674, 781, 1232 ], [ 360, 314, 427 ] ]
        },
        msa173: {
            name: "Lakeland-Winter Haven, FL",
            data: [ [ 10232, 9242, 16998 ], [ 6954, 4625, 4911 ], [ 1357, 1488, 2114 ], [ 840, 1156, 1423 ] ]
        },
        msa174: {
            name: "Lancaster, PA",
            data: [ [ 22995, 19407, 25773 ], [ 7693, 5086, 5419 ], [ 872, 1094, 1565 ], [ 457, 891, 1108 ] ]
        },
        msa175: {
            name: "Lansing-East Lansing, MI",
            data: [ [ 19e3, 16137, 24585 ], [ 4829, 3651, 4529 ], [ 478, 706, 1037 ], [ 669, 932, 1052 ] ]
        },
        msa176: {
            name: "Laredo, TX",
            data: [ [ 2384, 2467, 2866 ], [ 2518, 2056, 2597 ], [ 302, 398, 528 ], [ 4, 3, 0 ] ]
        },
        msa177: {
            name: "Las Cruces, NM",
            data: [ [ 6084, 5562, 6729 ], [ 2899, 2167, 2411 ], [ 1021, 1200, 1619 ], [ 10, 7, 13 ] ]
        },
        msa178: {
            name: "Las Vegas-Henderson-Paradise, NV",
            data: [ [ 35533, 32240, 71034 ], [ 41614, 29118, 34165 ], [ 9144, 9541, 13569 ], [ 94, 113, 118 ] ]
        },
        msa179: {
            name: "Lawrence, KS",
            data: [ [ 5678, 4821, 6459 ], [ 1477, 901, 1077 ], [ 214, 225, 335 ], [ 52, 67, 75 ] ]
        },
        msa180: {
            name: "Lawton, OK",
            data: [ [ 2223, 1836, 2130 ], [ 1534, 1124, 1072 ], [ 2697, 2718, 3115 ], [ 43, 59, 78 ] ]
        },
        msa181: {
            name: "Lebanon, PA",
            data: [ [ 5759, 5284, 6574 ], [ 1787, 1224, 1315 ], [ 474, 494, 711 ], [ 73, 204, 272 ] ]
        },
        msa182: {
            name: "Lewiston-Auburn, ME",
            data: [ [ 4017, 3526, 4620 ], [ 1326, 1144, 1259 ], [ 256, 327, 517 ], [ 283, 247, 281 ] ]
        },
        msa183: {
            name: "Lewiston, ID-WA",
            data: [ [ 3292, 2813, 3793 ], [ 1153, 734, 860 ], [ 254, 256, 398 ], [ 1, , 6 ] ]
        },
        msa184: {
            name: "Lexington-Fayette, KY",
            data: [ [ 25203, 23077, 31603 ], [ 7845, 5798, 6603 ], [ 1087, 1387, 2101 ], [ 422, 680, 889 ] ]
        },
        msa185: {
            name: "Lima, OH",
            data: [ [ 4858, 4164, 5723 ], [ 771, 598, 629 ], [ 142, 126, 220 ], [ 95, 153, 115 ] ]
        },
        msa186: {
            name: "Lincoln, NE",
            data: [ [ 19729, 16552, 22492 ], [ 5394, 3771, 4347 ], [ 855, 1208, 1801 ], [ 52, 119, 107 ] ]
        },
        msa187: {
            name: "Little Rock-North Little Rock-Conway, AR",
            data: [ [ 28409, 23699, 33158 ], [ 13379, 9615, 10028 ], [ 3923, 4441, 6292 ], [ 1839, 1852, 2145 ] ]
        },
        msa188: {
            name: "Logan, UT-ID",
            data: [ [ 6395, 5183, 7021 ], [ 2279, 1283, 1720 ], [ 170, 176, 377 ], [ 434, 620, 703 ] ]
        },
        msa189: {
            name: "Longview, TX",
            data: [ [ 5839, 6130, 6304 ], [ 1582, 1484, 1542 ], [ 262, 323, 410 ], [ 333, 324, 335 ] ]
        },
        msa190: {
            name: "Longview, WA",
            data: [ [ 4796, 3963, 5448 ], [ 1581, 954, 1399 ], [ 382, 434, 670 ], [ 124, 177, 224 ] ]
        },
        msa191: {
            name: "Louisville/Jefferson County, KY-IN",
            data: [ [ 69584, 61825, 82150 ], [ 25027, 17815, 19967 ], [ 3741, 4479, 6609 ], [ 744, 1508, 2089 ] ]
        },
        msa192: {
            name: "Lubbock, TX",
            data: [ [ 7225, 6861, 8819 ], [ 4331, 3198, 3673 ], [ 480, 523, 744 ], [ 47, 79, 66 ] ]
        },
        msa193: {
            name: "Lynchburg, VA",
            data: [ [ 9995, 8733, 10030 ], [ 3254, 2347, 2494 ], [ 586, 750, 1138 ], [ 510, 695, 708 ] ]
        },
        msa194: {
            name: "Macon, GA",
            data: [ [ 5224, 5604, 6805 ], [ 2480, 1894, 1967 ], [ 561, 610, 801 ], [ 94, 101, 106 ] ]
        },
        msa195: {
            name: "Madera, CA",
            data: [ [ 2744, 2660, 4798 ], [ 2080, 1778, 1840 ], [ 245, 293, 449 ], [ 187, 196, 208 ] ]
        },
        msa196: {
            name: "Madison, WI",
            data: [ [ 58220, 50577, 67536 ], [ 5254, 3581, 3803 ], [ 954, 1094, 1645 ], [ 483, 565, 849 ] ]
        },
        msa197: {
            name: "Manchester-Nashua, NH",
            data: [ [ 23888, 20963, 28553 ], [ 6546, 4660, 5696 ], [ 924, 1131, 1806 ], [ 239, 308, 370 ] ]
        },
        msa198: {
            name: "Manhattan, KS",
            data: [ [ 4221, 4014, 5068 ], [ 964, 611, 638 ], [ 1419, 1640, 2290 ], [ 166, 140, 185 ] ]
        },
        msa199: {
            name: "Mankato-North Mankato, MN",
            data: [ [ 5393, 4707, 6054 ], [ 1168, 861, 1190 ], [ 163, 209, 311 ], [ 54, 102, 157 ] ]
        },
        msa200: {
            name: "Mansfield, OH",
            data: [ [ 3609, 3413, 4995 ], [ 1068, 816, 916 ], [ 181, 244, 395 ], [ 102, 139, 144 ] ]
        },
        msa201: {
            name: "Mayag?ez, PR",
            data: [ [ 607, 699, 918 ], [ 592, 618, 539 ], [ 59, 55, 71 ], [ 19, 22, 25 ] ]
        },
        msa202: {
            name: "McAllen-Edinburg-Mission, TX",
            data: [ [ 8876, 9825, 9433 ], [ 4961, 3763, 4314 ], [ 465, 561, 797 ], [ 56, 19, 26 ] ]
        },
        msa203: {
            name: "Medford, OR",
            data: [ [ 8251, 6883, 11609 ], [ 2189, 1519, 2028 ], [ 556, 872, 1294 ], [ 267, 411, 434 ] ]
        },
        msa204: {
            name: "Memphis, TN-MS-AR",
            data: [ [ 36693, 30716, 43546 ], [ 20751, 15213, 17589 ], [ 3506, 4723, 6329 ], [ 1060, 1400, 1689 ] ]
        },
        msa205: {
            name: "Merced, CA",
            data: [ [ 3248, 3108, 6615 ], [ 4220, 3259, 3777 ], [ 361, 397, 568 ], [ 265, 267, 323 ] ]
        },
        msa206: {
            name: "Michigan City-La Porte, IN",
            data: [ [ 4325, 3993, 5150 ], [ 1664, 1387, 1542 ], [ 217, 232, 355 ], [ 45, 52, 38 ] ]
        },
        msa207: {
            name: "Midland, TX",
            data: [ [ 4401, 5148, 6430 ], [ 1985, 2362, 2710 ], [ 270, 299, 460 ], [ 5, 8, 8 ] ]
        },
        msa208: {
            name: "Milwaukee-Waukesha-West Allis, WI",
            data: [ [ 108556, 86990, 120302 ], [ 17497, 11331, 14441 ], [ 2095, 2544, 3786 ], [ 175, 245, 304 ] ]
        },
        msa209: {
            name: "Minneapolis-St. Paul-Bloomington, MN-WI",
            data: [ [ 220304, 183102, 277099 ], [ 56986, 42637, 53906 ], [ 5769, 6718, 11216 ], [ 1346, 2127, 2687 ] ]
        },
        msa210: {
            name: "Missoula, MT",
            data: [ [ 6211, 5039, 7222 ], [ 1331, 768, 707 ], [ 254, 337, 496 ], [ 94, 141, 227 ] ]
        },
        msa211: {
            name: "Mobile, AL",
            data: [ [ 11053, 9562, 11252 ], [ 7088, 5041, 5295 ], [ 1131, 1323, 1924 ], [ 607, 770, 782 ] ]
        },
        msa212: {
            name: "Modesto, CA",
            data: [ [ 11523, 9847, 20306 ], [ 10264, 7770, 9027 ], [ 730, 960, 1443 ], [ 184, 308, 381 ] ]
        },
        msa213: {
            name: "Monroe, LA",
            data: [ [ 5522, 5467, 6450 ], [ 2077, 1574, 1529 ], [ 222, 351, 443 ], [ 758, 654, 617 ] ]
        },
        msa214: {
            name: "Monroe, MI",
            data: [ [ 5886, 5665, 9998 ], [ 1628, 1391, 1700 ], [ 152, 264, 382 ], [ 61, 137, 139 ] ]
        },
        msa215: {
            name: "Montgomery, AL",
            data: [ [ 10917, 9797, 12986 ], [ 5995, 4228, 5171 ], [ 2361, 2607, 3999 ], [ 143, 273, 438 ] ]
        },
        msa216: {
            name: "Morgantown, WV",
            data: [ [ 5582, 5234, 6067 ], [ 1317, 916, 788 ], [ 169, 219, 325 ], [ 142, 182, 197 ] ]
        },
        msa217: {
            name: "Morristown, TN",
            data: [ [ 4823, 4561, 5553 ], [ 1789, 1265, 1197 ], [ 188, 337, 467 ], [ 162, 283, 366 ] ]
        },
        msa218: {
            name: "Mount Vernon-Anacortes, WA",
            data: [ [ 6553, 5438, 7199 ], [ 1662, 945, 1292 ], [ 654, 728, 1102 ], [ 107, 182, 210 ] ]
        },
        msa219: {
            name: "Muncie, IN",
            data: [ [ 3209, 2974, 3750 ], [ 1436, 1122, 1217 ], [ 169, 147, 277 ], [ 68, 80, 117 ] ]
        },
        msa220: {
            name: "Muskegon, MI",
            data: [ [ 5546, 5350, 7524 ], [ 1899, 1693, 1962 ], [ 202, 330, 468 ], [ 182, 323, 335 ] ]
        },
        msa221: {
            name: "Myrtle Beach-Conway-North Myrtle Beach, SC-NC",
            data: [ [ 11630, 10873, 14700 ], [ 3305, 2387, 2712 ], [ 739, 967, 1435 ], [ 252, 287, 400 ] ]
        },
        msa222: {
            name: "Napa, CA",
            data: [ [ 6878, 5985, 8883 ], [ 1603, 1278, 1671 ], [ 97, 159, 295 ], [ 1, 0, 0 ] ]
        },
        msa223: {
            name: "Naples-Immokalee-Marco Island, FL",
            data: [ [ 9818, 9080, 14509 ], [ 2581, 2026, 2034 ], [ 246, 358, 554 ], [ 506, 586, 471 ] ]
        },
        msa224: {
            name: "Nashville-Davidson--Murfreesboro--Franklin, TN",
            data: [ [ 74001, 70062, 95154 ], [ 35788, 27747, 35459 ], [ 4509, 6021, 9251 ], [ 1736, 2056, 2937 ] ]
        },
        msa225: {
            name: "New Haven-Milford, CT",
            data: [ [ 38088, 33804, 43197 ], [ 11398, 8063, 9405 ], [ 653, 826, 1155 ], [ 30, 26, 71 ] ]
        },
        msa226: {
            name: "New Orleans-Metairie, LA",
            data: [ [ 40489, 40623, 47120 ], [ 15700, 13249, 13962 ], [ 1965, 2592, 3955 ], [ 1110, 1607, 1882 ] ]
        },
        msa227: {
            name: "Niles-Benton Harbor, MI",
            data: [ [ 7197, 6844, 8656 ], [ 1357, 1069, 1067 ], [ 182, 278, 301 ], [ 87, 154, 177 ] ]
        },
        msa228: {
            name: "North Port-Sarasota-Bradenton, FL",
            data: [ [ 20932, 19968, 34596 ], [ 6666, 5233, 5888 ], [ 1162, 1674, 2503 ], [ 318, 393, 528 ] ]
        },
        msa229: {
            name: "Norwich-New London, CT",
            data: [ [ 13640, 11331, 15387 ], [ 2946, 2197, 2459 ], [ 913, 896, 1474 ], [ 136, 193, 279 ] ]
        },
        msa230: {
            name: "Ocala, FL",
            data: [ [ 7180, 6504, 11182 ], [ 2817, 2e3, 2116 ], [ 719, 866, 1332 ], [ 651, 1034, 994 ] ]
        },
        msa231: {
            name: "Ocean City, NJ",
            data: [ [ 5345, 4650, 5449 ], [ 1030, 616, 693 ], [ 160, 182, 282 ], [ 83, 161, 192 ] ]
        },
        msa232: {
            name: "Odessa, TX",
            data: [ [ 2667, 2760, 3594 ], [ 1646, 1516, 2024 ], [ 173, 160, 268 ], [ 3, 1, 2 ] ]
        },
        msa233: {
            name: "Ogden-Clearfield, UT",
            data: [ [ 32237, 25171, 39992 ], [ 16930, 9407, 15087 ], [ 3298, 3403, 6212 ], [ 39, 57, 56 ] ]
        },
        msa234: {
            name: "Oklahoma City, OK",
            data: [ [ 46068, 43721, 56372 ], [ 24400, 19432, 20543 ], [ 6671, 7967, 10631 ], [ 507, 603, 746 ] ]
        },
        msa235: {
            name: "Olympia-Tumwater, WA",
            data: [ [ 14790, 11772, 16212 ], [ 3798, 2396, 3189 ], [ 4121, 4180, 6078 ], [ 246, 317, 334 ] ]
        },
        msa236: {
            name: "Omaha-Council Bluffs, NE-IA",
            data: [ [ 53684, 43194, 60712 ], [ 19807, 12999, 14926 ], [ 5370, 6285, 8943 ], [ 197, 375, 433 ] ]
        },
        msa237: {
            name: "Orlando-Kissimmee-Sanford, FL",
            data: [ [ 46530, 45866, 93280 ], [ 30188, 22395, 25065 ], [ 4749, 5801, 8610 ], [ 1594, 1980, 2058 ] ]
        },
        msa238: {
            name: "Oshkosh-Neenah, WI",
            data: [ [ 12364, 10954, 14145 ], [ 2160, 1339, 1731 ], [ 380, 415, 607 ], [ 43, 49, 72 ] ]
        },
        msa239: {
            name: "Owensboro, KY",
            data: [ [ 5429, 5410, 6413 ], [ 1384, 1163, 1327 ], [ 190, 271, 399 ], [ 92, 120, 244 ] ]
        },
        msa240: {
            name: "Oxnard-Thousand Oaks-Ventura, CA",
            data: [ [ 49734, 44266, 65022 ], [ 9280, 7014, 9064 ], [ 1403, 1925, 3383 ], [ 34, 14, 42 ] ]
        },
        msa241: {
            name: "Palm Bay-Melbourne-Titusville, FL",
            data: [ [ 14375, 13838, 27322 ], [ 6067, 4771, 5477 ], [ 2347, 3037, 4783 ], [ 66, 55, 73 ] ]
        },
        msa242: {
            name: "Panama City, FL",
            data: [ [ 4767, 4252, 6432 ], [ 1562, 1247, 1219 ], [ 1286, 1438, 2161 ], [ 315, 402, 408 ] ]
        },
        msa243: {
            name: "Parkersburg-Vienna, WV",
            data: [ [ 5474, 5381, 6670 ], [ 1503, 1193, 1086 ], [ 228, 342, 452 ], [ 126, 161, 150 ] ]
        },
        msa244: {
            name: "Pensacola-Ferry Pass-Brent, FL",
            data: [ [ 11468, 10794, 15604 ], [ 4303, 3161, 3469 ], [ 4795, 5349, 8161 ], [ 619, 732, 791 ] ]
        },
        msa245: {
            name: "Peoria, IL",
            data: [ [ 21637, 18378, 24466 ], [ 4575, 3725, 3630 ], [ 723, 852, 1265 ], [ 389, 608, 658 ] ]
        },
        msa246: {
            name: "Phoenix-Mesa-Scottsdale, AZ",
            data: [ [ 139158, 125702, 258846 ], [ 83178, 60940, 69303 ], [ 13980, 16094, 25333 ], [ 3120, 2477, 3451 ] ]
        },
        msa247: {
            name: "Pine Bluff, AR",
            data: [ [ 2186, 1767, 2233 ], [ 1057, 772, 723 ], [ 219, 171, 274 ], [ 92, 79, 76 ] ]
        },
        msa248: {
            name: "Pittsburgh, PA",
            data: [ [ 98267, 94759, 119512 ], [ 30648, 24166, 25976 ], [ 2827, 3723, 5199 ], [ 919, 1272, 1176 ] ]
        },
        msa249: {
            name: "Pittsfield, MA",
            data: [ [ 7485, 5469, 8022 ], [ 531, 487, 490 ], [ 106, 180, 178 ], [ 11, 92, 149 ] ]
        },
        msa250: {
            name: "Pocatello, ID",
            data: [ [ 3935, 3717, 4808 ], [ 2119, 1224, 1228 ], [ 192, 274, 332 ], [ 46, 61, 53 ] ]
        },
        msa251: {
            name: "Ponce, PR",
            data: [ [ 1572, 1593, 1999 ], [ 1963, 1923, 1895 ], [ 187, 204, 198 ], [ 427, 624, 396 ] ]
        },
        msa252: {
            name: "Port St. Lucie, FL",
            data: [ [ 9252, 9148, 17820 ], [ 5416, 3968, 4779 ], [ 847, 1055, 1554 ], [ 119, 115, 124 ] ]
        },
        msa253: {
            name: "Portland-South Portland, ME",
            data: [ [ 36689, 29669, 39455 ], [ 6593, 4565, 5257 ], [ 1279, 1358, 2257 ], [ 1220, 1338, 1552 ] ]
        },
        msa254: {
            name: "Portland-Vancouver-Hillsboro, OR-WA",
            data: [ [ 148452, 118363, 170285 ], [ 34774, 22724, 29965 ], [ 6162, 7597, 12331 ], [ 1614, 1822, 2506 ] ]
        },
        msa255: {
            name: "Prescott, AZ",
            data: [ [ 8977, 8141, 13390 ], [ 2237, 1712, 1745 ], [ 707, 1010, 1442 ], [ 422, 399, 550 ] ]
        },
        msa256: {
            name: "Providence-Warwick, RI-MA",
            data: [ [ 77358, 66901, 93482 ], [ 21933, 15488, 17171 ], [ 1704, 2123, 3637 ], [ 282, 503, 610 ] ]
        },
        msa257: {
            name: "Provo-Orem, UT",
            data: [ [ 25084, 20356, 32375 ], [ 13495, 7541, 11740 ], [ 970, 1264, 2145 ], [ 1003, 1495, 1964 ] ]
        },
        msa258: {
            name: "Pueblo, CO",
            data: [ [ 5527, 5087, 6349 ], [ 3697, 2468, 2350 ], [ 799, 1256, 1589 ], [ 4, 7, 2 ] ]
        },
        msa259: {
            name: "Punta Gorda, FL",
            data: [ [ 4320, 4065, 7441 ], [ 1344, 978, 1072 ], [ 320, 452, 682 ], [ 25, 39, 16 ] ]
        },
        msa260: {
            name: "Racine, WI",
            data: [ [ 12916, 10577, 14317 ], [ 2270, 1743, 2055 ], [ 355, 430, 616 ], [ 97, 134, 122 ] ]
        },
        msa261: {
            name: "Raleigh, NC",
            data: [ [ 77106, 68715, 91072 ], [ 17412, 12045, 13743 ], [ 4421, 5464, 8018 ], [ 1902, 2307, 2832 ] ]
        },
        msa262: {
            name: "Rapid City, SD",
            data: [ [ 5799, 5315, 7119 ], [ 1425, 1001, 1183 ], [ 1160, 1414, 2303 ], [ 138, 383, 508 ] ]
        },
        msa263: {
            name: "Reading, PA",
            data: [ [ 15980, 14866, 18382 ], [ 6317, 4651, 4915 ], [ 544, 718, 1021 ], [ 157, 372, 529 ] ]
        },
        msa264: {
            name: "Redding, CA",
            data: [ [ 6468, 5419, 8975 ], [ 2103, 1422, 1718 ], [ 436, 597, 976 ], [ 244, 258, 393 ] ]
        },
        msa265: {
            name: "Reno, NV",
            data: [ [ 13471, 11975, 22329 ], [ 7573, 5809, 6319 ], [ 1303, 1383, 2364 ], [ 105, 140, 226 ] ]
        },
        msa266: {
            name: "Richmond, VA",
            data: [ [ 59100, 51842, 69607 ], [ 22828, 17250, 20678 ], [ 5240, 6046, 9294 ], [ 519, 966, 1035 ] ]
        },
        msa267: {
            name: "Riverside-San Bernardino-Ontario, CA",
            data: [ [ 113685, 105404, 181267 ], [ 82760, 64364, 80708 ], [ 13312, 16118, 24257 ], [ 1273, 1473, 1911 ] ]
        },
        msa268: {
            name: "Roanoke, VA",
            data: [ [ 12809, 11180, 14003 ], [ 4726, 3306, 3660 ], [ 780, 1144, 1495 ], [ 413, 536, 591 ] ]
        },
        msa269: {
            name: "Rochester, MN",
            data: [ [ 13610, 11475, 15704 ], [ 2726, 1999, 2366 ], [ 335, 430, 703 ], [ 208, 341, 392 ] ]
        },
        msa270: {
            name: "Rochester, NY",
            data: [ [ 28393, 28060, 34673 ], [ 12382, 10722, 10262 ], [ 1227, 1474, 1821 ], [ 497, 882, 974 ] ]
        },
        msa271: {
            name: "Rockford, IL",
            data: [ [ 19407, 15409, 20475 ], [ 5006, 3447, 4256 ], [ 596, 605, 877 ], [ 25, 44, 41 ] ]
        },
        msa272: {
            name: "Rocky Mount, NC",
            data: [ [ 3693, 3589, 4322 ], [ 1305, 946, 930 ], [ 331, 357, 530 ], [ 175, 205, 256 ] ]
        },
        msa273: {
            name: "Rome, GA",
            data: [ [ 1879, 2118, 2902 ], [ 991, 761, 976 ], [ 119, 107, 179 ], [ 10, 24, 47 ] ]
        },
        msa274: {
            name: "Sacramento--Roseville--Arden-Arcade, CA",
            data: [ [ 104240, 86231, 151901 ], [ 36473, 28847, 37916 ], [ 4690, 6213, 10010 ], [ 486, 880, 1094 ] ]
        },
        msa275: {
            name: "Saginaw, MI",
            data: [ [ 6287, 6029, 9142 ], [ 1722, 1468, 1652 ], [ 121, 268, 342 ], [ 229, 278, 352 ] ]
        },
        msa276: {
            name: "Salem, OR",
            data: [ [ 18147, 13738, 17891 ], [ 5672, 3816, 5084 ], [ 1208, 1587, 2366 ], [ 427, 409, 690 ] ]
        },
        msa277: {
            name: "Salinas, CA",
            data: [ [ 12592, 11590, 16483 ], [ 3900, 3037, 3419 ], [ 370, 627, 876 ], [ 643, 635, 781 ] ]
        },
        msa278: {
            name: "Salisbury, MD-DE",
            data: [ [ 3724, 3451, 4021 ], [ 1616, 1115, 1254 ], [ 245, 323, 440 ], [ 221, 303, 359 ] ]
        },
        msa279: {
            name: "Salt Lake City, UT",
            data: [ [ 61545, 49269, 77254 ], [ 31312, 17964, 28276 ], [ 2336, 2691, 4968 ], [ 470, 722, 785 ] ]
        },
        msa280: {
            name: "San Angelo, TX",
            data: [ [ 2585, 2615, 3034 ], [ 994, 975, 1163 ], [ 658, 665, 787 ], [ 13, 7, 6 ] ]
        },
        msa281: {
            name: "San Antonio-New Braunfels, TX",
            data: [ [ 59459, 61334, 72798 ], [ 26449, 20372, 24898 ], [ 16458, 18161, 27022 ], [ 961, 1476, 2344 ] ]
        },
        msa282: {
            name: "San Diego-Carlsbad, CA",
            data: [ [ 167401, 150318, 222643 ], [ 33370, 23921, 30938 ], [ 13393, 18777, 31871 ], [ 61, 160, 202 ] ]
        },
        msa283: {
            name: "San Germ?n, PR",
            data: [ [ 929, 1247, 1371 ], [ 742, 712, 655 ], [ 115, 150, 140 ], [ 406, 525, 476 ] ]
        },
        msa284: {
            name: "San Jose-Sunnyvale-Santa Clara, CA",
            data: [ [ 174529, 154345, 215098 ], [ 12131, 8963, 10109 ], [ 678, 1079, 1728 ], [ 104, 191, 232 ] ]
        },
        msa285: {
            name: "San Juan-Carolina-Caguas, PR",
            data: [ [ 22811, 22881, 30122 ], [ 25207, 23658, 26084 ], [ 2116, 2475, 2594 ], [ 3519, 4070, 3711 ] ]
        },
        msa286: {
            name: "San Luis Obispo-Paso Robles-Arroyo Grande, CA",
            data: [ [ 16133, 13713, 20227 ], [ 2274, 1550, 1931 ], [ 315, 636, 1027 ], [ 256, 583, 642 ] ]
        },
        msa287: {
            name: "Santa Cruz-Watsonville, CA",
            data: [ [ 15084, 13749, 20133 ], [ 1731, 1363, 1616 ], [ 94, 174, 265 ], [ 64, 84, 143 ] ]
        },
        msa288: {
            name: "Santa Fe, NM",
            data: [ [ 7966, 7058, 9632 ], [ 1456, 1062, 1074 ], [ 248, 379, 569 ], [ 8, 19, 24 ] ]
        },
        msa289: {
            name: "Santa Rosa, CA",
            data: [ [ 28260, 24078, 36005 ], [ 4990, 3860, 4900 ], [ 316, 549, 901 ], [ 27, 74, 96 ] ]
        },
        msa290: {
            name: "Savannah, GA",
            data: [ [ 10416, 10256, 12631 ], [ 4949, 3498, 3708 ], [ 3338, 4227, 5398 ], [ 707, 682, 682 ] ]
        },
        msa291: {
            name: "Scranton--Wilkes-Barre--Hazleton, PA",
            data: [ [ 18494, 17565, 21731 ], [ 6026, 4776, 4535 ], [ 769, 897, 1241 ], [ 77, 178, 133 ] ]
        },
        msa292: {
            name: "Sebastian-Vero Beach, FL",
            data: [ [ 3830, 3641, 6296 ], [ 1173, 887, 1056 ], [ 191, 312, 518 ], [ 57, 36, 22 ] ]
        },
        msa293: {
            name: "Sheboygan, WI",
            data: [ [ 8552, 7044, 9361 ], [ 1211, 702, 879 ], [ 164, 208, 264 ], [ 61, 83, 133 ] ]
        },
        msa294: {
            name: "Sherman-Denison, TX",
            data: [ [ 2945, 3249, 3670 ], [ 1259, 961, 1058 ], [ 152, 262, 397 ], [ 91, 132, 123 ] ]
        },
        msa295: {
            name: "Shreveport-Bossier City, LA",
            data: [ [ 12395, 11559, 15156 ], [ 6095, 4622, 4714 ], [ 2336, 2405, 3588 ], [ 650, 756, 915 ] ]
        },
        msa296: {
            name: "Sioux City, IA-NE-SD",
            data: [ [ 6025, 5886, 7662 ], [ 2182, 1432, 1645 ], [ 240, 333, 412 ], [ 65, 51, 84 ] ]
        },
        msa297: {
            name: "Sioux Falls, SD",
            data: [ [ 15999, 13371, 19811 ], [ 5185, 3681, 4343 ], [ 938, 898, 1468 ], [ 346, 504, 575 ] ]
        },
        msa298: {
            name: "South Bend-Mishawaka, IN-MI",
            data: [ [ 12631, 11511, 15491 ], [ 4321, 3314, 3395 ], [ 361, 517, 690 ], [ 69, 138, 153 ] ]
        },
        msa299: {
            name: "Spartanburg, SC",
            data: [ [ 9504, 10014, 12302 ], [ 3736, 2536, 3244 ], [ 502, 734, 1001 ], [ 862, 988, 1326 ] ]
        },
        msa300: {
            name: "Spokane-Spokane Valley, WA",
            data: [ [ 25012, 20276, 27692 ], [ 8413, 5613, 6761 ], [ 2646, 2858, 4054 ], [ 98, 158, 198 ] ]
        },
        msa301: {
            name: "Springfield, IL",
            data: [ [ 20158, 14947, 21050 ], [ 2337, 2001, 2077 ], [ 612, 769, 1084 ], [ 247, 319, 417 ] ]
        },
        msa302: {
            name: "Springfield, MA",
            data: [ [ 30012, 25672, 33297 ], [ 6966, 4944, 5202 ], [ 979, 1264, 1850 ], [ 165, 283, 388 ] ]
        },
        msa303: {
            name: "Springfield, MO",
            data: [ [ 21869, 18059, 23824 ], [ 7694, 5072, 5907 ], [ 1362, 1462, 2218 ], [ 878, 981, 1206 ] ]
        },
        msa304: {
            name: "Springfield, OH",
            data: [ [ 4614, 4047, 5459 ], [ 1685, 1159, 1445 ], [ 335, 423, 647 ], [ 127, 235, 242 ] ]
        },
        msa305: {
            name: "St. Cloud, MN",
            data: [ [ 10259, 8033, 11531 ], [ 2217, 1653, 1884 ], [ 450, 480, 737 ], [ 265, 416, 499 ] ]
        },
        msa306: {
            name: "St. George, UT",
            data: [ [ 5866, 5179, 8211 ], [ 2696, 2062, 2438 ], [ 285, 399, 820 ], [ 215, 273, 235 ] ]
        },
        msa307: {
            name: "St. Joseph, MO-KS",
            data: [ [ 4288, 3825, 4988 ], [ 1647, 1207, 1267 ], [ 243, 298, 407 ], [ 93, 150, 165 ] ]
        },
        msa308: {
            name: "St. Louis, MO-IL",
            data: [ [ 186010, 148969, 198936 ], [ 51500, 36533, 44919 ], [ 8802, 9698, 14524 ], [ 1710, 2598, 2999 ] ]
        },
        msa309: {
            name: "State College, PA",
            data: [ [ 7170, 6164, 8164 ], [ 901, 773, 677 ], [ 238, 277, 371 ], [ 194, 273, 282 ] ]
        },
        msa310: {
            name: "Stockton-Lodi, CA",
            data: [ [ 16252, 14938, 28134 ], [ 13712, 10519, 12791 ], [ 1188, 1601, 2255 ], [ 166, 201, 259 ] ]
        },
        msa311: {
            name: "Sumter, SC",
            data: [ [ 2119, 2057, 2412 ], [ 1190, 789, 624 ], [ 1095, 1284, 1505 ], [ 50, 36, 42 ] ]
        },
        msa312: {
            name: "Syracuse, NY",
            data: [ [ 18264, 18236, 22471 ], [ 7610, 6331, 6077 ], [ 846, 1065, 1480 ], [ 157, 270, 396 ] ]
        },
        msa313: {
            name: "Tallahassee, FL",
            data: [ [ 10491, 9312, 13610 ], [ 4170, 2794, 3153 ], [ 709, 898, 1150 ], [ 363, 411, 446 ] ]
        },
        msa314: {
            name: "Tampa-St. Petersburg-Clearwater, FL",
            data: [ [ 69549, 65409, 112943 ], [ 31002, 24734, 28045 ], [ 8708, 10773, 16405 ], [ 1355, 1920, 2319 ] ]
        },
        msa315: {
            name: "Terre Haute, IN",
            data: [ [ 6684, 6053, 7551 ], [ 1759, 1479, 1380 ], [ 348, 338, 503 ], [ 237, 280, 173 ] ]
        },
        msa316: {
            name: "Texarkana, TX-AR",
            data: [ [ 3281, 3606, 4118 ], [ 1126, 913, 856 ], [ 282, 301, 404 ], [ 144, 109, 140 ] ]
        },
        msa317: {
            name: "Toledo, OH",
            data: [ [ 24888, 23241, 31825 ], [ 6551, 4821, 5846 ], [ 769, 903, 1452 ], [ 195, 222, 270 ] ]
        },
        msa318: {
            name: "Topeka, KS",
            data: [ [ 10233, 9824, 11307 ], [ 3731, 2622, 2428 ], [ 785, 840, 1121 ], [ 114, 176, 176 ] ]
        },
        msa319: {
            name: "Trenton, NJ",
            data: [ [ 18377, 17449, 21704 ], [ 4390, 3044, 3593 ], [ 243, 363, 447 ], [ 3, 21, 28 ] ]
        },
        msa320: {
            name: "Tucson, AZ",
            data: [ [ 38238, 31584, 49436 ], [ 13660, 10726, 13469 ], [ 5052, 5688, 8550 ], [ 499, 694, 1058 ] ]
        },
        msa321: {
            name: "Tulsa, OK",
            data: [ [ 33995, 30657, 40395 ], [ 17855, 12925, 14194 ], [ 2451, 3133, 4161 ], [ 1613, 1603, 1902 ] ]
        },
        msa322: {
            name: "Tuscaloosa, AL",
            data: [ [ 7164, 6607, 9198 ], [ 3718, 2589, 2567 ], [ 573, 598, 843 ], [ 225, 257, 609 ] ]
        },
        msa323: {
            name: "Tyler, TX",
            data: [ [ 7409, 6830, 8185 ], [ 1768, 1605, 1772 ], [ 376, 401, 593 ], [ 267, 348, 352 ] ]
        },
        msa324: {
            name: "Utica-Rome, NY",
            data: [ [ 7203, 6883, 8543 ], [ 2743, 2615, 2401 ], [ 302, 374, 592 ], [ 83, 146, 175 ] ]
        },
        msa325: {
            name: "Valdosta, GA",
            data: [ [ 3544, 3579, 4012 ], [ 1405, 964, 900 ], [ 1096, 1278, 1577 ], [ 78, 97, 160 ] ]
        },
        msa326: {
            name: "Vallejo-Fairfield, CA",
            data: [ [ 13969, 12241, 22367 ], [ 7744, 5881, 7404 ], [ 2387, 2585, 4150 ], [ 64, 104, 149 ] ]
        },
        msa327: {
            name: "Victoria, TX",
            data: [ [ 2783, 2902, 3378 ], [ 927, 700, 846 ], [ 184, 175, 248 ], [ 27, 14, 22 ] ]
        },
        msa328: {
            name: "Vineland-Bridgeton, NJ",
            data: [ [ 3629, 3072, 3499 ], [ 2314, 1653, 1840 ], [ 191, 233, 290 ], [ 22, 79, 84 ] ]
        },
        msa329: {
            name: "Virginia Beach-Norfolk-Newport News, VA-NC",
            data: [ [ 63215, 55554, 68786 ], [ 26011, 19456, 22968 ], [ 25975, 32168, 48003 ], [ 160, 246, 352 ] ]
        },
        msa330: {
            name: "Visalia-Porterville, CA",
            data: [ [ 6667, 6381, 12245 ], [ 5228, 4181, 5108 ], [ 648, 821, 1071 ], [ 287, 291, 292 ] ]
        },
        msa331: {
            name: "Waco, TX",
            data: [ [ 5719, 5633, 6751 ], [ 2230, 1981, 1872 ], [ 598, 764, 894 ], [ 143, 188, 220 ] ]
        },
        msa332: {
            name: "Warner Robins, GA",
            data: [ [ 4e3, 4006, 4885 ], [ 2210, 1469, 1586 ], [ 2513, 2632, 3568 ], [ 121, 122, 199 ] ]
        },
        msa333: {
            name: "Waterloo-Cedar Falls, IA",
            data: [ [ 10481, 9318, 11544 ], [ 2777, 1545, 1153 ], [ 231, 296, 383 ], [ 65, 75, 139 ] ]
        },
        msa334: {
            name: "Wausau, WI",
            data: [ [ 10586, 8168, 11885 ], [ 1006, 680, 733 ], [ 190, 230, 251 ], [ 103, 145, 172 ] ]
        },
        msa335: {
            name: "Wenatchee, WA",
            data: [ [ 5747, 4818, 6313 ], [ 1483, 1022, 1198 ], [ 240, 276, 433 ], [ 71, 153, 224 ] ]
        },
        msa336: {
            name: "Wheeling, WV-OH",
            data: [ [ 4327, 3966, 4862 ], [ 1096, 857, 943 ], [ 115, 158, 187 ], [ 286, 219, 251 ] ]
        },
        msa337: {
            name: "Wichita Falls, TX",
            data: [ [ 3729, 3330, 3843 ], [ 1397, 1062, 1159 ], [ 1008, 788, 1194 ], [ 40, 44, 21 ] ]
        },
        msa338: {
            name: "Wichita, KS",
            data: [ [ 27055, 22211, 27624 ], [ 11198, 7763, 7943 ], [ 2441, 2564, 3330 ], [ 350, 540, 628 ] ]
        },
        msa339: {
            name: "Williamsport, PA",
            data: [ [ 4142, 3961, 5216 ], [ 1075, 1003, 813 ], [ 150, 246, 311 ], [ 22, 49, 69 ] ]
        },
        msa340: {
            name: "Wilmington, NC",
            data: [ [ 19305, 16847, 21968 ], [ 3772, 2715, 2780 ], [ 1363, 1767, 2534 ], [ 578, 720, 882 ] ]
        },
        msa341: {
            name: "Winchester, VA-WV",
            data: [ [ 5679, 4948, 7367 ], [ 1954, 1385, 1635 ], [ 493, 654, 1016 ], [ 224, 302, 338 ] ]
        },
        msa342: {
            name: "Winston-Salem, NC",
            data: [ [ 20135, 19055, 22234 ], [ 6455, 5048, 5058 ], [ 1187, 1488, 1887 ], [ 355, 533, 425 ] ]
        },
        msa343: {
            name: "Worcester, MA-CT",
            data: [ [ 48718, 40582, 58303 ], [ 9608, 6453, 7295 ], [ 984, 1281, 1886 ], [ 295, 456, 779 ] ]
        },
        msa344: {
            name: "Yakima, WA",
            data: [ [ 7455, 7391, 9566 ], [ 3342, 2223, 2461 ], [ 480, 526, 880 ], [ 156, 308, 295 ] ]
        },
        msa345: {
            name: "York-Hanover, PA",
            data: [ [ 20667, 17901, 22776 ], [ 8523, 5557, 6268 ], [ 1299, 1564, 2273 ], [ 498, 945, 1090 ] ]
        },
        msa346: {
            name: "Youngstown-Warren-Boardman, OH-PA",
            data: [ [ 19868, 17303, 21796 ], [ 5147, 3952, 4240 ], [ 554, 747, 1042 ], [ 144, 197, 226 ] ]
        },
        msa347: {
            name: "Yuba City, CA",
            data: [ [ 3873, 3366, 6653 ], [ 2540, 1980, 2388 ], [ 940, 1087, 1498 ], [ 134, 243, 217 ] ]
        },
        msa348: {
            name: "Yuma, AZ",
            data: [ [ 3603, 2865, 4973 ], [ 2525, 1852, 2341 ], [ 1141, 1136, 1792 ], [ 206, 307, 432 ] ]
        }
    };
    var $conventional_checkbox = $("#conventional_checkbox");
    $conventional_checkbox.click(function() {
        var series = originationsByTypeChart.series[0];
        if (series.visible) {
            series.hide();
            $conventional_checkbox.removeAttr("checked");
        } else {
            series.show();
            $conventional_checkbox.attr("checked");
        }
    });
    var $fha_checkbox = $("#fha_checkbox");
    $fha_checkbox.click(function() {
        var series = originationsByTypeChart.series[1];
        if (series.visible) {
            series.hide();
            $fha_checkbox.removeAttr("checked");
        } else {
            series.show();
            $fha_checkbox.attr("checked");
        }
    });
    var $va_checkbox = $("#va_checkbox");
    $va_checkbox.click(function() {
        var series = originationsByTypeChart.series[2];
        if (series.visible) {
            series.hide();
            $va_checkbox.removeAttr("checked");
        } else {
            series.show();
            $va_checkbox.attr("checked");
        }
    });
    var $rhs_checkbox = $("#rhs_checkbox");
    $rhs_checkbox.click(function() {
        var series = originationsByTypeChart.series[3];
        if (series.visible) {
            series.hide();
            $rhs_checkbox.removeAttr("checked");
        } else {
            series.show();
            $rhs_checkbox.attr("checked");
        }
    });
    var $msa = $("#hmda_chart_2_msa");
    $msa.change(function() {
        var msaID = $msa.val();
        var msaName = chart2DataObj[msaID].name.replace("&apos;", "’");
        originationsByTypeChart.setTitle({
            text: msaName
        });
        for (var i = 0; i < 4; i++) {
            originationsByTypeChart.series[i].setData(chart2DataObj[msaID].data[i]);
        }
    });
});
